1
00:00:00,359 --> 00:00:04,470

we'll get started um so uh a few sort of

2
00:00:04,470 --> 00:00:04,480
we'll get started um so uh a few sort of
 

3
00:00:04,480 --> 00:00:07,030
we'll get started um so uh a few sort of
words of introduction before we we start

4
00:00:07,030 --> 00:00:07,040
words of introduction before we we start
 

5
00:00:07,040 --> 00:00:11,110
words of introduction before we we start
um so that's me I'm Richard Eisenberg um

6
00:00:11,110 --> 00:00:11,120
um so that's me I'm Richard Eisenberg um
 

7
00:00:11,120 --> 00:00:14,310
um so that's me I'm Richard Eisenberg um
uh and I spend quite a bit of time uh

8
00:00:14,310 --> 00:00:14,320
uh and I spend quite a bit of time uh
 

9
00:00:14,320 --> 00:00:16,269
uh and I spend quite a bit of time uh
thinking about dependent types and tasal

10
00:00:16,269 --> 00:00:16,279
thinking about dependent types and tasal
 

11
00:00:16,279 --> 00:00:17,470
thinking about dependent types and tasal
we'll talk more about that actually

12
00:00:17,470 --> 00:00:17,480
we'll talk more about that actually
 

13
00:00:17,480 --> 00:00:20,269
we'll talk more about that actually
toward the end of the talk um the the

14
00:00:20,269 --> 00:00:20,279
toward the end of the talk um the the
 

15
00:00:20,279 --> 00:00:22,790
toward the end of the talk um the the
other stuff it surprisingly uh didn't

16
00:00:22,790 --> 00:00:22,800
other stuff it surprisingly uh didn't
 

17
00:00:22,800 --> 00:00:25,950
other stuff it surprisingly uh didn't
doesn't have as many dependent types um

18
00:00:25,950 --> 00:00:25,960
doesn't have as many dependent types um
 

19
00:00:25,960 --> 00:00:29,230
doesn't have as many dependent types um
uh also if any of you were at zurah

20
00:00:29,230 --> 00:00:29,240
uh also if any of you were at zurah
 

21
00:00:29,240 --> 00:00:30,470
uh also if any of you were at zurah
Haack this

22
00:00:30,470 --> 00:00:30,480
Haack this
 

23
00:00:30,480 --> 00:00:33,350
Haack this
this spring um this is the same talk

24
00:00:33,350 --> 00:00:33,360
this spring um this is the same talk
 

25
00:00:33,360 --> 00:00:35,150
this spring um this is the same talk
that I gave there you were welcome to

26
00:00:35,150 --> 00:00:35,160
that I gave there you were welcome to
 

27
00:00:35,160 --> 00:00:37,030
that I gave there you were welcome to
get up and go to some something else I

28
00:00:37,030 --> 00:00:37,040
get up and go to some something else I
 

29
00:00:37,040 --> 00:00:39,229
get up and go to some something else I
was just asked this morning this as as

30
00:00:39,229 --> 00:00:39,239
was just asked this morning this as as
 

31
00:00:39,239 --> 00:00:40,790
was just asked this morning this as as
as we heard this morning right the

32
00:00:40,790 --> 00:00:40,800
as we heard this morning right the
 

33
00:00:40,800 --> 00:00:42,950
as we heard this morning right the
original speaker for this this slot was

34
00:00:42,950 --> 00:00:42,960
original speaker for this this slot was
 

35
00:00:42,960 --> 00:00:44,830
original speaker for this this slot was
is unwell today and so I I sort of

36
00:00:44,830 --> 00:00:44,840
is unwell today and so I I sort of
 

37
00:00:44,840 --> 00:00:46,830
is unwell today and so I I sort of
jumped in at the last minute so that

38
00:00:46,830 --> 00:00:46,840
jumped in at the last minute so that
 

39
00:00:46,840 --> 00:00:48,750
jumped in at the last minute so that
that means one it is a recycle talk but

40
00:00:48,750 --> 00:00:48,760
that means one it is a recycle talk but
 

41
00:00:48,760 --> 00:00:52,110
that means one it is a recycle talk but
two um uh I have not rehearsed this

42
00:00:52,110 --> 00:00:52,120
two um uh I have not rehearsed this
 

43
00:00:52,120 --> 00:00:55,869
two um uh I have not rehearsed this
since June um and so if I get a little

44
00:00:55,869 --> 00:00:55,879
since June um and so if I get a little
 

45
00:00:55,879 --> 00:00:58,270
since June um and so if I get a little
confused at my slides please forgive me

46
00:00:58,270 --> 00:00:58,280
confused at my slides please forgive me
 

47
00:00:58,280 --> 00:01:00,670
confused at my slides please forgive me
um and and sort of as as it's not it's

48
00:01:00,670 --> 00:01:00,680
um and and sort of as as it's not it's
 

49
00:01:00,680 --> 00:01:02,470
um and and sort of as as it's not it's
not quite a workshop it's more more of a

50
00:01:02,470 --> 00:01:02,480
not quite a workshop it's more more of a
 

51
00:01:02,480 --> 00:01:05,750
not quite a workshop it's more more of a
talk I I very much want questions but I

52
00:01:05,750 --> 00:01:05,760
talk I I very much want questions but I
 

53
00:01:05,760 --> 00:01:07,469
talk I I very much want questions but I
don't have like exercises for you all to

54
00:01:07,469 --> 00:01:07,479
don't have like exercises for you all to
 

55
00:01:07,479 --> 00:01:09,429
don't have like exercises for you all to
get out your laptops and do as I would

56
00:01:09,429 --> 00:01:09,439
get out your laptops and do as I would
 

57
00:01:09,439 --> 00:01:10,550
get out your laptops and do as I would
if I had sort of preed this as a

58
00:01:10,550 --> 00:01:10,560
if I had sort of preed this as a
 

59
00:01:10,560 --> 00:01:11,830
if I had sort of preed this as a
workshop so that's just a few

60
00:01:11,830 --> 00:01:11,840
workshop so that's just a few
 

61
00:01:11,840 --> 00:01:14,070
workshop so that's just a few
disclaimers but please do ask questions

62
00:01:14,070 --> 00:01:14,080
disclaimers but please do ask questions
 

63
00:01:14,080 --> 00:01:16,230
disclaimers but please do ask questions
so the talk is is shorter than the time

64
00:01:16,230 --> 00:01:16,240
so the talk is is shorter than the time
 

65
00:01:16,240 --> 00:01:18,190
so the talk is is shorter than the time
that we have a lot is so there's plenty

66
00:01:18,190 --> 00:01:18,200
that we have a lot is so there's plenty
 

67
00:01:18,200 --> 00:01:20,830
that we have a lot is so there's plenty
of plenty of time for questions um so

68
00:01:20,830 --> 00:01:20,840
of plenty of time for questions um so
 

69
00:01:20,840 --> 00:01:24,069
of plenty of time for questions um so
you'll see here um a link can someone

70
00:01:24,069 --> 00:01:24,079
you'll see here um a link can someone
 

71
00:01:24,079 --> 00:01:25,550
you'll see here um a link can someone
has someone has anyone actually tried

72
00:01:25,550 --> 00:01:25,560
has someone has anyone actually tried
 

73
00:01:25,560 --> 00:01:27,670
has someone has anyone actually tried
this link yes does it

74
00:01:27,670 --> 00:01:27,680
this link yes does it
 

75
00:01:27,680 --> 00:01:31,270
this link yes does it
work no it

76
00:01:31,270 --> 00:01:31,280
work no it
 

77
00:01:31,280 --> 00:01:35,789
work no it
404s that's very interesting um that's

78
00:01:35,789 --> 00:01:35,799
404s that's very interesting um that's
 

79
00:01:35,799 --> 00:01:37,350
404s that's very interesting um that's
really too

80
00:01:37,350 --> 00:01:37,360
really too
 

81
00:01:37,360 --> 00:01:40,870
really too
bad what can I do about that very

82
00:01:40,870 --> 00:01:40,880
bad what can I do about that very
 

83
00:01:40,880 --> 00:01:43,670
bad what can I do about that very
quickly give the talk just give the talk

84
00:01:43,670 --> 00:01:43,680
quickly give the talk just give the talk
 

85
00:01:43,680 --> 00:01:45,389
quickly give the talk just give the talk
I think I I think that's probably a good

86
00:01:45,389 --> 00:01:45,399
I think I I think that's probably a good
 

87
00:01:45,399 --> 00:01:47,950
I think I I think that's probably a good
idea okay um I will if there's if

88
00:01:47,950 --> 00:01:47,960
idea okay um I will if there's if
 

89
00:01:47,960 --> 00:01:49,429
idea okay um I will if there's if
there's a dry moment somewhere toward

90
00:01:49,429 --> 00:01:49,439
there's a dry moment somewhere toward
 

91
00:01:49,439 --> 00:01:50,670
there's a dry moment somewhere toward
the end I will make that available I

92
00:01:50,670 --> 00:01:50,680
the end I will make that available I
 

93
00:01:50,680 --> 00:01:53,429
the end I will make that available I
don't know why that would happen um okay

94
00:01:53,429 --> 00:01:53,439
don't know why that would happen um okay
 

95
00:01:53,439 --> 00:01:56,910
don't know why that would happen um okay
so um when whenever I get a chance to to

96
00:01:56,910 --> 00:01:56,920
so um when whenever I get a chance to to
 

97
00:01:56,920 --> 00:01:58,709
so um when whenever I get a chance to to
actually get some some feedback so Simon

98
00:01:58,709 --> 00:01:58,719
actually get some some feedback so Simon
 

99
00:01:58,719 --> 00:02:00,749
actually get some some feedback so Simon
talked this morning about there's no

100
00:02:00,749 --> 00:02:00,759
talked this morning about there's no
 

101
00:02:00,759 --> 00:02:02,950
talked this morning about there's no
Telemetry right so we don't know how

102
00:02:02,950 --> 00:02:02,960
Telemetry right so we don't know how
 

103
00:02:02,960 --> 00:02:05,230
Telemetry right so we don't know how
people use hll so I love to get a little

104
00:02:05,230 --> 00:02:05,240
people use hll so I love to get a little
 

105
00:02:05,240 --> 00:02:06,830
people use hll so I love to get a little
feedback when whenever I get a chance to

106
00:02:06,830 --> 00:02:06,840
feedback when whenever I get a chance to
 

107
00:02:06,840 --> 00:02:10,469
feedback when whenever I get a chance to
give a a talk um so how many of you use

108
00:02:10,469 --> 00:02:10,479
give a a talk um so how many of you use
 

109
00:02:10,479 --> 00:02:13,750
give a a talk um so how many of you use
hascal to make money in some

110
00:02:13,750 --> 00:02:13,760
hascal to make money in some
 

111
00:02:13,760 --> 00:02:19,949
hascal to make money in some
way wow that's amazing um so uh so I

112
00:02:19,949 --> 00:02:19,959
way wow that's amazing um so uh so I
 

113
00:02:19,959 --> 00:02:23,350
way wow that's amazing um so uh so I
assume uh most of you I maybe I won't

114
00:02:23,350 --> 00:02:23,360
assume uh most of you I maybe I won't
 

115
00:02:23,360 --> 00:02:25,229
assume uh most of you I maybe I won't
call out to to ask for raises of hands

116
00:02:25,229 --> 00:02:25,239
call out to to ask for raises of hands
 

117
00:02:25,239 --> 00:02:27,830
call out to to ask for raises of hands
here but um that um that you you're

118
00:02:27,830 --> 00:02:27,840
here but um that um that you you're
 

119
00:02:27,840 --> 00:02:29,270
here but um that um that you you're
working for someone else or or you're

120
00:02:29,270 --> 00:02:29,280
working for someone else or or you're
 

121
00:02:29,280 --> 00:02:30,830
working for someone else or or you're
working for yourself you sort of have a

122
00:02:30,830 --> 00:02:30,840
working for yourself you sort of have a
 

123
00:02:30,840 --> 00:02:32,589
working for yourself you sort of have a
business but it's not just sort of um

124
00:02:32,589 --> 00:02:32,599
business but it's not just sort of um
 

125
00:02:32,599 --> 00:02:33,710
business but it's not just sort of um
something that you do in your spare time

126
00:02:33,710 --> 00:02:33,720
something that you do in your spare time
 

127
00:02:33,720 --> 00:02:34,949
something that you do in your spare time
if you're using it to make money so

128
00:02:34,949 --> 00:02:34,959
if you're using it to make money so
 

129
00:02:34,959 --> 00:02:38,790
if you're using it to make money so
that's that's pretty cool um so one of

130
00:02:38,790 --> 00:02:38,800
that's that's pretty cool um so one of
 

131
00:02:38,800 --> 00:02:40,830
that's that's pretty cool um so one of
the things I find really fun about these

132
00:02:40,830 --> 00:02:40,840
the things I find really fun about these
 

133
00:02:40,840 --> 00:02:44,030
the things I find really fun about these
about these kinds of events is is is is

134
00:02:44,030 --> 00:02:44,040
about these kinds of events is is is is
 

135
00:02:44,040 --> 00:02:46,270
about these kinds of events is is is is
seeing people who you know use hasle to

136
00:02:46,270 --> 00:02:46,280
seeing people who you know use hasle to
 

137
00:02:46,280 --> 00:02:48,350
seeing people who you know use hasle to
to write web services and use hascal you

138
00:02:48,350 --> 00:02:48,360
to write web services and use hascal you
 

139
00:02:48,360 --> 00:02:50,110
to write web services and use hascal you
know I'm I'm I'm fascinated by the fact

140
00:02:50,110 --> 00:02:50,120
know I'm I'm I'm fascinated by the fact
 

141
00:02:50,120 --> 00:02:52,070
know I'm I'm I'm fascinated by the fact
that every now and then I see habito

142
00:02:52,070 --> 00:02:52,080
that every now and then I see habito
 

143
00:02:52,080 --> 00:02:54,350
that every now and then I see habito
advertise on television right and I know

144
00:02:54,350 --> 00:02:54,360
advertise on television right and I know
 

145
00:02:54,360 --> 00:02:56,630
advertise on television right and I know
that there's like hascal powering that

146
00:02:56,630 --> 00:02:56,640
that there's like hascal powering that
 

147
00:02:56,640 --> 00:02:57,750
that there's like hascal powering that
but sort of behind the scenes probably

148
00:02:57,750 --> 00:02:57,760
but sort of behind the scenes probably
 

149
00:02:57,760 --> 00:03:00,990
but sort of behind the scenes probably
not the ad but um so so very exciting um

150
00:03:00,990 --> 00:03:01,000
not the ad but um so so very exciting um
 

151
00:03:01,000 --> 00:03:02,509
not the ad but um so so very exciting um
edit to to to do something like that so

152
00:03:02,509 --> 00:03:02,519
edit to to to do something like that so
 

153
00:03:02,519 --> 00:03:05,110
edit to to to do something like that so
I want us to start off with um sort of a

154
00:03:05,110 --> 00:03:05,120
I want us to start off with um sort of a
 

155
00:03:05,120 --> 00:03:07,789
I want us to start off with um sort of a
history of of hasc's type

156
00:03:07,789 --> 00:03:07,799
history of of hasc's type
 

157
00:03:07,799 --> 00:03:11,630
history of of hasc's type
system um so uh actually this is before

158
00:03:11,630 --> 00:03:11,640
system um so uh actually this is before
 

159
00:03:11,640 --> 00:03:13,309
system um so uh actually this is before
hasell hasal was 1990 but this is sort

160
00:03:13,309 --> 00:03:13,319
hasell hasal was 1990 but this is sort
 

161
00:03:13,319 --> 00:03:14,949
hasell hasal was 1990 but this is sort
of along with the birth of hasell so we

162
00:03:14,949 --> 00:03:14,959
of along with the birth of hasell so we
 

163
00:03:14,959 --> 00:03:17,430
of along with the birth of hasell so we
have you know Haso started out with well

164
00:03:17,430 --> 00:03:17,440
have you know Haso started out with well
 

165
00:03:17,440 --> 00:03:18,710
have you know Haso started out with well
there's there's type classes right we

166
00:03:18,710 --> 00:03:18,720
there's there's type classes right we
 

167
00:03:18,720 --> 00:03:21,550
there's there's type classes right we
wanted some way to be able to use a plus

168
00:03:21,550 --> 00:03:21,560
wanted some way to be able to use a plus
 

169
00:03:21,560 --> 00:03:25,309
wanted some way to be able to use a plus
sign um and and have it mean different

170
00:03:25,309 --> 00:03:25,319
sign um and and have it mean different
 

171
00:03:25,319 --> 00:03:27,110
sign um and and have it mean different
things depending on what types of

172
00:03:27,110 --> 00:03:27,120
things depending on what types of
 

173
00:03:27,120 --> 00:03:28,750
things depending on what types of
numbers we're using and so it's like oh

174
00:03:28,750 --> 00:03:28,760
numbers we're using and so it's like oh
 

175
00:03:28,760 --> 00:03:30,509
numbers we're using and so it's like oh
okay so we can do that in a more

176
00:03:30,509 --> 00:03:30,519
okay so we can do that in a more
 

177
00:03:30,519 --> 00:03:33,589
okay so we can do that in a more
principled way say than than you know

178
00:03:33,589 --> 00:03:33,599
principled way say than than you know
 

179
00:03:33,599 --> 00:03:35,710
principled way say than than you know
Java or C++ does it that we can have

180
00:03:35,710 --> 00:03:35,720
Java or C++ does it that we can have
 

181
00:03:35,720 --> 00:03:38,789
Java or C++ does it that we can have
this this this type class approach um

182
00:03:38,789 --> 00:03:38,799
this this this type class approach um
 

183
00:03:38,799 --> 00:03:41,309
this this this type class approach um
and and then we we got up to to

184
00:03:41,309 --> 00:03:41,319
and and then we we got up to to
 

185
00:03:41,319 --> 00:03:42,589
and and then we we got up to to
functional dependency so I realized

186
00:03:42,589 --> 00:03:42,599
functional dependency so I realized
 

187
00:03:42,599 --> 00:03:45,429
functional dependency so I realized
there's a long gap between these um and

188
00:03:45,429 --> 00:03:45,439
there's a long gap between these um and
 

189
00:03:45,439 --> 00:03:46,990
there's a long gap between these um and
and then and then we realized that once

190
00:03:46,990 --> 00:03:47,000
and then and then we realized that once
 

191
00:03:47,000 --> 00:03:49,229
and then and then we realized that once
we wanted to have multi-parameter type

192
00:03:49,229 --> 00:03:49,239
we wanted to have multi-parameter type
 

193
00:03:49,239 --> 00:03:50,350
we wanted to have multi-parameter type
classes that would sort of go in between

194
00:03:50,350 --> 00:03:50,360
classes that would sort of go in between
 

195
00:03:50,360 --> 00:03:52,470
classes that would sort of go in between
these that you want to have some way of

196
00:03:52,470 --> 00:03:52,480
these that you want to have some way of
 

197
00:03:52,480 --> 00:03:54,990
these that you want to have some way of
one uh type parameter or one parameter

198
00:03:54,990 --> 00:03:55,000
one uh type parameter or one parameter
 

199
00:03:55,000 --> 00:03:56,910
one uh type parameter or one parameter
to the type class affecting another and

200
00:03:56,910 --> 00:03:56,920
to the type class affecting another and
 

201
00:03:56,920 --> 00:03:59,270
to the type class affecting another and
so that gives us um uh functional

202
00:03:59,270 --> 00:03:59,280
so that gives us um uh functional
 

203
00:03:59,280 --> 00:04:00,869
so that gives us um uh functional
dependency

204
00:04:00,869 --> 00:04:00,879
dependency
 

205
00:04:00,879 --> 00:04:03,750
dependency
and and that I think in my opinion that

206
00:04:03,750 --> 00:04:03,760
and and that I think in my opinion that
 

207
00:04:03,760 --> 00:04:05,990
and and that I think in my opinion that
was sort of the genie first starting to

208
00:04:05,990 --> 00:04:06,000
was sort of the genie first starting to
 

209
00:04:06,000 --> 00:04:08,390
was sort of the genie first starting to
crawl out of the bottle right once we

210
00:04:08,390 --> 00:04:08,400
crawl out of the bottle right once we
 

211
00:04:08,400 --> 00:04:10,030
crawl out of the bottle right once we
could do this then suddenly we could do

212
00:04:10,030 --> 00:04:10,040
could do this then suddenly we could do
 

213
00:04:10,040 --> 00:04:13,830
could do this then suddenly we could do
some level of computation in types um so

214
00:04:13,830 --> 00:04:13,840
some level of computation in types um so
 

215
00:04:13,840 --> 00:04:17,990
some level of computation in types um so
this got uh explored more deeply um with

216
00:04:17,990 --> 00:04:18,000
this got uh explored more deeply um with
 

217
00:04:18,000 --> 00:04:20,229
this got uh explored more deeply um with
data families so data families actually

218
00:04:20,229 --> 00:04:20,239
data families so data families actually
 

219
00:04:20,239 --> 00:04:23,790
data families so data families actually
were invented as a way to make programs

220
00:04:23,790 --> 00:04:23,800
were invented as a way to make programs
 

221
00:04:23,800 --> 00:04:27,030
were invented as a way to make programs
run faster um that we wanted to have

222
00:04:27,030 --> 00:04:27,040
run faster um that we wanted to have
 

223
00:04:27,040 --> 00:04:30,110
run faster um that we wanted to have
specialized representations for say

224
00:04:30,110 --> 00:04:30,120
specialized representations for say
 

225
00:04:30,120 --> 00:04:32,270
specialized representations for say
arrays of inss right we can do that

226
00:04:32,270 --> 00:04:32,280
arrays of inss right we can do that
 

227
00:04:32,280 --> 00:04:34,150
arrays of inss right we can do that
really fast um if we have an array of

228
00:04:34,150 --> 00:04:34,160
really fast um if we have an array of
 

229
00:04:34,160 --> 00:04:35,550
really fast um if we have an array of
some other type maybe we can't do it as

230
00:04:35,550 --> 00:04:35,560
some other type maybe we can't do it as
 

231
00:04:35,560 --> 00:04:37,390
some other type maybe we can't do it as
fast so data families are a way to do

232
00:04:37,390 --> 00:04:37,400
fast so data families are a way to do
 

233
00:04:37,400 --> 00:04:40,189
fast so data families are a way to do
that um then these got generalized a

234
00:04:40,189 --> 00:04:40,199
that um then these got generalized a
 

235
00:04:40,199 --> 00:04:41,950
that um then these got generalized a
little bit further to type family so now

236
00:04:41,950 --> 00:04:41,960
little bit further to type family so now
 

237
00:04:41,960 --> 00:04:43,790
little bit further to type family so now
we really had things that acted as

238
00:04:43,790 --> 00:04:43,800
we really had things that acted as
 

239
00:04:43,800 --> 00:04:47,310
we really had things that acted as
functions on types um and and so this

240
00:04:47,310 --> 00:04:47,320
functions on types um and and so this
 

241
00:04:47,320 --> 00:04:49,150
functions on types um and and so this
was in some ways a competitor to

242
00:04:49,150 --> 00:04:49,160
was in some ways a competitor to
 

243
00:04:49,160 --> 00:04:50,469
was in some ways a competitor to
functional dependencies and the two are

244
00:04:50,469 --> 00:04:50,479
functional dependencies and the two are
 

245
00:04:50,479 --> 00:04:51,950
functional dependencies and the two are
still sort of fighting it out today

246
00:04:51,950 --> 00:04:51,960
still sort of fighting it out today
 

247
00:04:51,960 --> 00:04:55,430
still sort of fighting it out today
actually um uh from these then we have

248
00:04:55,430 --> 00:04:55,440
actually um uh from these then we have
 

249
00:04:55,440 --> 00:05:00,550
actually um uh from these then we have
generalized algebraic data types um so

250
00:05:00,550 --> 00:05:00,560
generalized algebraic data types um so
 

251
00:05:00,560 --> 00:05:02,430
generalized algebraic data types um so
uh generalized algebraic data types

252
00:05:02,430 --> 00:05:02,440
uh generalized algebraic data types
 

253
00:05:02,440 --> 00:05:07,270
uh generalized algebraic data types
allow us to sort of control the the um

254
00:05:07,270 --> 00:05:07,280
allow us to sort of control the the um
 

255
00:05:07,280 --> 00:05:08,990
allow us to sort of control the the um
uh the type of an algebraic data type

256
00:05:08,990 --> 00:05:09,000
uh the type of an algebraic data type
 

257
00:05:09,000 --> 00:05:11,390
uh the type of an algebraic data type
depending on what Constructor we use or

258
00:05:11,390 --> 00:05:11,400
depending on what Constructor we use or
 

259
00:05:11,400 --> 00:05:13,510
depending on what Constructor we use or
conversely when we pattern match on a

260
00:05:13,510 --> 00:05:13,520
conversely when we pattern match on a
 

261
00:05:13,520 --> 00:05:15,350
conversely when we pattern match on a
Constructor we get to learn something

262
00:05:15,350 --> 00:05:15,360
Constructor we get to learn something
 

263
00:05:15,360 --> 00:05:18,230
Constructor we get to learn something
about the type so with gads in my

264
00:05:18,230 --> 00:05:18,240
about the type so with gads in my
 

265
00:05:18,240 --> 00:05:19,870
about the type so with gads in my
opinion the genie crawled a little bit

266
00:05:19,870 --> 00:05:19,880
opinion the genie crawled a little bit
 

267
00:05:19,880 --> 00:05:22,070
opinion the genie crawled a little bit
further out of the bottle here right now

268
00:05:22,070 --> 00:05:22,080
further out of the bottle here right now
 

269
00:05:22,080 --> 00:05:24,590
further out of the bottle here right now
we can have programs that when they take

270
00:05:24,590 --> 00:05:24,600
we can have programs that when they take
 

271
00:05:24,600 --> 00:05:27,990
we can have programs that when they take
a runtime action they cause um sort of

272
00:05:27,990 --> 00:05:28,000
a runtime action they cause um sort of
 

273
00:05:28,000 --> 00:05:30,150
a runtime action they cause um sort of
compile time information

274
00:05:30,150 --> 00:05:30,160
compile time information
 

275
00:05:30,160 --> 00:05:32,270
compile time information
uh to to to become available and so that

276
00:05:32,270 --> 00:05:32,280
uh to to to become available and so that
 

277
00:05:32,280 --> 00:05:34,150
uh to to to become available and so that
means different parts of a case

278
00:05:34,150 --> 00:05:34,160
means different parts of a case
 

279
00:05:34,160 --> 00:05:36,150
means different parts of a case
statement can have different

280
00:05:36,150 --> 00:05:36,160
statement can have different
 

281
00:05:36,160 --> 00:05:40,230
statement can have different
types um so that was you know three big

282
00:05:40,230 --> 00:05:40,240
types um so that was you know three big
 

283
00:05:40,240 --> 00:05:42,430
types um so that was you know three big
papers all right in a row and then

284
00:05:42,430 --> 00:05:42,440
papers all right in a row and then
 

285
00:05:42,440 --> 00:05:44,710
papers all right in a row and then
there's this Gap here and and so lots of

286
00:05:44,710 --> 00:05:44,720
there's this Gap here and and so lots of
 

287
00:05:44,720 --> 00:05:46,510
there's this Gap here and and so lots of
stuff happened in that time uh one of

288
00:05:46,510 --> 00:05:46,520
stuff happened in that time uh one of
 

289
00:05:46,520 --> 00:05:48,309
stuff happened in that time uh one of
them being a complete reimplementation

290
00:05:48,309 --> 00:05:48,319
them being a complete reimplementation
 

291
00:05:48,319 --> 00:05:50,430
them being a complete reimplementation
of the type Checker in in GHC to

292
00:05:50,430 --> 00:05:50,440
of the type Checker in in GHC to
 

293
00:05:50,440 --> 00:05:52,870
of the type Checker in in GHC to
accommodate these these new Innovations

294
00:05:52,870 --> 00:05:52,880
accommodate these these new Innovations
 

295
00:05:52,880 --> 00:05:55,390
accommodate these these new Innovations
um so then this is about where I started

296
00:05:55,390 --> 00:05:55,400
um so then this is about where I started
 

297
00:05:55,400 --> 00:05:58,950
um so then this is about where I started
studying hasell uh it was in 2011 um so

298
00:05:58,950 --> 00:05:58,960
studying hasell uh it was in 2011 um so
 

299
00:05:58,960 --> 00:06:01,309
studying hasell uh it was in 2011 um so
data type promot motion came along and

300
00:06:01,309 --> 00:06:01,319
data type promot motion came along and
 

301
00:06:01,319 --> 00:06:03,550
data type promot motion came along and
now what that means is that we can use

302
00:06:03,550 --> 00:06:03,560
now what that means is that we can use
 

303
00:06:03,560 --> 00:06:06,029
now what that means is that we can use
data Constructors in types and we can

304
00:06:06,029 --> 00:06:06,039
data Constructors in types and we can
 

305
00:06:06,039 --> 00:06:08,990
data Constructors in types and we can
use sort of types in kinds and that

306
00:06:08,990 --> 00:06:09,000
use sort of types in kinds and that
 

307
00:06:09,000 --> 00:06:11,589
use sort of types in kinds and that
opened up better expressivity better uh

308
00:06:11,589 --> 00:06:11,599
opened up better expressivity better uh
 

309
00:06:11,599 --> 00:06:13,270
opened up better expressivity better uh
checking of all this type level

310
00:06:13,270 --> 00:06:13,280
checking of all this type level
 

311
00:06:13,280 --> 00:06:16,510
checking of all this type level
programming um so then we have uh uh

312
00:06:16,510 --> 00:06:16,520
programming um so then we have uh uh
 

313
00:06:16,520 --> 00:06:18,390
programming um so then we have uh uh
right after that we we had Singletons

314
00:06:18,390 --> 00:06:18,400
right after that we we had Singletons
 

315
00:06:18,400 --> 00:06:20,110
right after that we we had Singletons
which isn't really a hasal feature but

316
00:06:20,110 --> 00:06:20,120
which isn't really a hasal feature but
 

317
00:06:20,120 --> 00:06:22,189
which isn't really a hasal feature but
it's something that's used to sort of

318
00:06:22,189 --> 00:06:22,199
it's something that's used to sort of
 

319
00:06:22,199 --> 00:06:24,469
it's something that's used to sort of
pretend that we have dependent types so

320
00:06:24,469 --> 00:06:24,479
pretend that we have dependent types so
 

321
00:06:24,479 --> 00:06:26,070
pretend that we have dependent types so
there was a lot of this that that was

322
00:06:26,070 --> 00:06:26,080
there was a lot of this that that was
 

323
00:06:26,080 --> 00:06:27,350
there was a lot of this that that was
sort of out there in the folklore and I

324
00:06:27,350 --> 00:06:27,360
sort of out there in the folklore and I
 

325
00:06:27,360 --> 00:06:29,070
sort of out there in the folklore and I
tried to sort of pull it together in in

326
00:06:29,070 --> 00:06:29,080
tried to sort of pull it together in in
 

327
00:06:29,080 --> 00:06:30,469
tried to sort of pull it together in in
this paper in

328
00:06:30,469 --> 00:06:30,479
this paper in
 

329
00:06:30,479 --> 00:06:34,510
this paper in
2012 um so then another big step forward

330
00:06:34,510 --> 00:06:34,520
2012 um so then another big step forward
 

331
00:06:34,520 --> 00:06:37,029
2012 um so then another big step forward
in my opinion is the idea of type in

332
00:06:37,029 --> 00:06:37,039
in my opinion is the idea of type in
 

333
00:06:37,039 --> 00:06:41,029
in my opinion is the idea of type in
type um so previously there were terms

334
00:06:41,029 --> 00:06:41,039
type um so previously there were terms
 

335
00:06:41,039 --> 00:06:42,350
type um so previously there were terms
and there were types and there were

336
00:06:42,350 --> 00:06:42,360
and there were types and there were
 

337
00:06:42,360 --> 00:06:44,550
and there were types and there were
kinds and they were all sort of separate

338
00:06:44,550 --> 00:06:44,560
kinds and they were all sort of separate
 

339
00:06:44,560 --> 00:06:48,029
kinds and they were all sort of separate
um now since GHC 8.0 took some years to

340
00:06:48,029 --> 00:06:48,039
um now since GHC 8.0 took some years to
 

341
00:06:48,039 --> 00:06:51,110
um now since GHC 8.0 took some years to
implement this um since GHC 8.0 we've

342
00:06:51,110 --> 00:06:51,120
implement this um since GHC 8.0 we've
 

343
00:06:51,120 --> 00:06:53,550
implement this um since GHC 8.0 we've
had types and kinds being the same thing

344
00:06:53,550 --> 00:06:53,560
had types and kinds being the same thing
 

345
00:06:53,560 --> 00:06:54,990
had types and kinds being the same thing
and so that means not only can we have

346
00:06:54,990 --> 00:06:55,000
and so that means not only can we have
 

347
00:06:55,000 --> 00:06:56,390
and so that means not only can we have
functions on types but we can have

348
00:06:56,390 --> 00:06:56,400
functions on types but we can have
 

349
00:06:56,400 --> 00:06:59,950
functions on types but we can have
functions on kinds um and and as Simon

350
00:06:59,950 --> 00:06:59,960
functions on kinds um and and as Simon
 

351
00:06:59,960 --> 00:07:01,749
functions on kinds um and and as Simon
likes to remind me we're still sort of

352
00:07:01,749 --> 00:07:01,759
likes to remind me we're still sort of
 

353
00:07:01,759 --> 00:07:04,150
likes to remind me we're still sort of
recovering from this Big C change inside

354
00:07:04,150 --> 00:07:04,160
recovering from this Big C change inside
 

355
00:07:04,160 --> 00:07:06,270
recovering from this Big C change inside
of GHC this made things a bit more

356
00:07:06,270 --> 00:07:06,280
of GHC this made things a bit more
 

357
00:07:06,280 --> 00:07:09,869
of GHC this made things a bit more
complicated but a lot more expressive um

358
00:07:09,869 --> 00:07:09,879
complicated but a lot more expressive um
 

359
00:07:09,879 --> 00:07:12,189
complicated but a lot more expressive um
so we also now have closed type families

360
00:07:12,189 --> 00:07:12,199
so we also now have closed type families
 

361
00:07:12,199 --> 00:07:14,510
so we also now have closed type families
so open type families are sort of like

362
00:07:14,510 --> 00:07:14,520
so open type families are sort of like
 

363
00:07:14,520 --> 00:07:17,550
so open type families are sort of like
um a class methods almost Clos type

364
00:07:17,550 --> 00:07:17,560
um a class methods almost Clos type
 

365
00:07:17,560 --> 00:07:19,629
um a class methods almost Clos type
families are more like proper functions

366
00:07:19,629 --> 00:07:19,639
families are more like proper functions
 

367
00:07:19,639 --> 00:07:20,830
families are more like proper functions
um and so we can do a little bit more

368
00:07:20,830 --> 00:07:20,840
um and so we can do a little bit more
 

369
00:07:20,840 --> 00:07:23,550
um and so we can do a little bit more
computation in types um all of this led

370
00:07:23,550 --> 00:07:23,560
computation in types um all of this led
 

371
00:07:23,560 --> 00:07:25,350
computation in types um all of this led
to problems because now that we had all

372
00:07:25,350 --> 00:07:25,360
to problems because now that we had all
 

373
00:07:25,360 --> 00:07:26,990
to problems because now that we had all
of these fun types we wanted to be able

374
00:07:26,990 --> 00:07:27,000
of these fun types we wanted to be able
 

375
00:07:27,000 --> 00:07:28,990
of these fun types we wanted to be able
to Do complete pattern matches so as

376
00:07:28,990 --> 00:07:29,000
to Do complete pattern matches so as
 

377
00:07:29,000 --> 00:07:30,110
to Do complete pattern matches so as
Simon explained explained to us this

378
00:07:30,110 --> 00:07:30,120
Simon explained explained to us this
 

379
00:07:30,120 --> 00:07:33,029
Simon explained explained to us this
morning this is hard um and so here was

380
00:07:33,029 --> 00:07:33,039
morning this is hard um and so here was
 

381
00:07:33,039 --> 00:07:34,950
morning this is hard um and so here was
nice paper that that refined the pattern

382
00:07:34,950 --> 00:07:34,960
nice paper that that refined the pattern
 

383
00:07:34,960 --> 00:07:36,390
nice paper that that refined the pattern
match warning Checker we're still

384
00:07:36,390 --> 00:07:36,400
match warning Checker we're still
 

385
00:07:36,400 --> 00:07:38,230
match warning Checker we're still
clearly working on that as as Simon

386
00:07:38,230 --> 00:07:38,240
clearly working on that as as Simon
 

387
00:07:38,240 --> 00:07:42,029
clearly working on that as as Simon
explained this morning um not only do we

388
00:07:42,029 --> 00:07:42,039
explained this morning um not only do we
 

389
00:07:42,039 --> 00:07:44,309
explained this morning um not only do we
want uh closed type families but we

390
00:07:44,309 --> 00:07:44,319
want uh closed type families but we
 

391
00:07:44,319 --> 00:07:45,790
want uh closed type families but we
sometimes want to be able to propagate

392
00:07:45,790 --> 00:07:45,800
sometimes want to be able to propagate
 

393
00:07:45,800 --> 00:07:47,510
sometimes want to be able to propagate
information from results of type

394
00:07:47,510 --> 00:07:47,520
information from results of type
 

395
00:07:47,520 --> 00:07:50,430
information from results of type
families back to uh back to the argument

396
00:07:50,430 --> 00:07:50,440
families back to uh back to the argument
 

397
00:07:50,440 --> 00:07:53,230
families back to uh back to the argument
so we have injective type families um

398
00:07:53,230 --> 00:07:53,240
so we have injective type families um
 

399
00:07:53,240 --> 00:07:55,270
so we have injective type families um
sometimes these all these implicits are

400
00:07:55,270 --> 00:07:55,280
sometimes these all these implicits are
 

401
00:07:55,280 --> 00:07:57,390
sometimes these all these implicits are
hard to work with so we want type

402
00:07:57,390 --> 00:07:57,400
hard to work with so we want type
 

403
00:07:57,400 --> 00:07:59,869
hard to work with so we want type
application uh we want to be able to to

404
00:07:59,869 --> 00:07:59,879
application uh we want to be able to to
 

405
00:07:59,879 --> 00:08:02,670
application uh we want to be able to to
tell GHC how we're specializing some

406
00:08:02,670 --> 00:08:02,680
tell GHC how we're specializing some
 

407
00:08:02,680 --> 00:08:05,309
tell GHC how we're specializing some
function instead of having it infer um

408
00:08:05,309 --> 00:08:05,319
function instead of having it infer um
 

409
00:08:05,319 --> 00:08:07,510
function instead of having it infer um
all of these tools can be used quite

410
00:08:07,510 --> 00:08:07,520
all of these tools can be used quite
 

411
00:08:07,520 --> 00:08:10,309
all of these tools can be used quite
usefully to to have type reflection so

412
00:08:10,309 --> 00:08:10,319
usefully to to have type reflection so
 

413
00:08:10,319 --> 00:08:12,029
usefully to to have type reflection so
there's this typable mechanism which

414
00:08:12,029 --> 00:08:12,039
there's this typable mechanism which
 

415
00:08:12,039 --> 00:08:14,029
there's this typable mechanism which
allows us essentially to do Dynamic

416
00:08:14,029 --> 00:08:14,039
allows us essentially to do Dynamic
 

417
00:08:14,039 --> 00:08:16,869
allows us essentially to do Dynamic
typing in a statically typed language um

418
00:08:16,869 --> 00:08:16,879
typing in a statically typed language um
 

419
00:08:16,879 --> 00:08:18,550
typing in a statically typed language um
and so that's built on a bunch of the

420
00:08:18,550 --> 00:08:18,560
and so that's built on a bunch of the
 

421
00:08:18,560 --> 00:08:21,110
and so that's built on a bunch of the
previous extensions we have pattern

422
00:08:21,110 --> 00:08:21,120
previous extensions we have pattern
 

423
00:08:21,120 --> 00:08:24,029
previous extensions we have pattern
synonyms now so we can abstract over

424
00:08:24,029 --> 00:08:24,039
synonyms now so we can abstract over
 

425
00:08:24,039 --> 00:08:25,990
synonyms now so we can abstract over
patterns and they have their own complex

426
00:08:25,990 --> 00:08:26,000
patterns and they have their own complex
 

427
00:08:26,000 --> 00:08:28,309
patterns and they have their own complex
relationships with types we recently

428
00:08:28,309 --> 00:08:28,319
relationships with types we recently
 

429
00:08:28,319 --> 00:08:30,710
relationships with types we recently
have Quantified class constraints

430
00:08:30,710 --> 00:08:30,720
have Quantified class constraints
 

431
00:08:30,720 --> 00:08:32,269
have Quantified class constraints
meaning not only do we have a class

432
00:08:32,269 --> 00:08:32,279
meaning not only do we have a class
 

433
00:08:32,279 --> 00:08:34,630
meaning not only do we have a class
constraint but we can then say that this

434
00:08:34,630 --> 00:08:34,640
constraint but we can then say that this
 

435
00:08:34,640 --> 00:08:36,870
constraint but we can then say that this
is true for for any type A not just for

436
00:08:36,870 --> 00:08:36,880
is true for for any type A not just for
 

437
00:08:36,880 --> 00:08:41,589
is true for for any type A not just for
a specific type a um uh more recently

438
00:08:41,589 --> 00:08:41,599
a specific type a um uh more recently
 

439
00:08:41,599 --> 00:08:43,149
a specific type a um uh more recently
this this one is is not yet implemented

440
00:08:43,149 --> 00:08:43,159
this this one is is not yet implemented
 

441
00:08:43,159 --> 00:08:46,110
this this one is is not yet implemented
it's in progress um we we we have the

442
00:08:46,110 --> 00:08:46,120
it's in progress um we we we have the
 

443
00:08:46,120 --> 00:08:48,430
it's in progress um we we we have the
idea of type abstractions so that way we

444
00:08:48,430 --> 00:08:48,440
idea of type abstractions so that way we
 

445
00:08:48,440 --> 00:08:51,070
idea of type abstractions so that way we
can have a a part of our code that is

446
00:08:51,070 --> 00:08:51,080
can have a a part of our code that is
 

447
00:08:51,080 --> 00:08:53,389
can have a a part of our code that is
generalized over a certain type variable

448
00:08:53,389 --> 00:08:53,399
generalized over a certain type variable
 

449
00:08:53,399 --> 00:08:55,470
generalized over a certain type variable
so a few things to comment here first

450
00:08:55,470 --> 00:08:55,480
so a few things to comment here first
 

451
00:08:55,480 --> 00:08:57,750
so a few things to comment here first
off I could make another whole slide

452
00:08:57,750 --> 00:08:57,760
off I could make another whole slide
 

453
00:08:57,760 --> 00:09:01,069
off I could make another whole slide
this dense with more papers about hasal

454
00:09:01,069 --> 00:09:01,079
this dense with more papers about hasal
 

455
00:09:01,079 --> 00:09:03,230
this dense with more papers about hasal
and has Cy system um the other

456
00:09:03,230 --> 00:09:03,240
and has Cy system um the other
 

457
00:09:03,240 --> 00:09:06,750
and has Cy system um the other
observation is I mean how wonderful it

458
00:09:06,750 --> 00:09:06,760
observation is I mean how wonderful it
 

459
00:09:06,760 --> 00:09:09,790
observation is I mean how wonderful it
is that we have this language that that

460
00:09:09,790 --> 00:09:09,800
is that we have this language that that
 

461
00:09:09,800 --> 00:09:12,150
is that we have this language that that
sort of every major step is accompanied

462
00:09:12,150 --> 00:09:12,160
sort of every major step is accompanied
 

463
00:09:12,160 --> 00:09:15,829
sort of every major step is accompanied
by peer-reviewed uh research um I I just

464
00:09:15,829 --> 00:09:15,839
by peer-reviewed uh research um I I just
 

465
00:09:15,839 --> 00:09:17,389
by peer-reviewed uh research um I I just
think that's so fantastic because it

466
00:09:17,389 --> 00:09:17,399
think that's so fantastic because it
 

467
00:09:17,399 --> 00:09:19,470
think that's so fantastic because it
means that we have long form

468
00:09:19,470 --> 00:09:19,480
means that we have long form
 

469
00:09:19,480 --> 00:09:24,150
means that we have long form
documentation of of our decisions and um

470
00:09:24,150 --> 00:09:24,160
documentation of of our decisions and um
 

471
00:09:24,160 --> 00:09:27,590
documentation of of our decisions and um
and it allows us to really uh sort of

472
00:09:27,590 --> 00:09:27,600
and it allows us to really uh sort of
 

473
00:09:27,600 --> 00:09:28,990
and it allows us to really uh sort of
understand where we are and and where

474
00:09:28,990 --> 00:09:29,000
understand where we are and and where
 

475
00:09:29,000 --> 00:09:30,710
understand where we are and and where
we're going going and we we have a

476
00:09:30,710 --> 00:09:30,720
we're going going and we we have a
 

477
00:09:30,720 --> 00:09:31,990
we're going going and we we have a
little bit more faith that things are

478
00:09:31,990 --> 00:09:32,000
little bit more faith that things are
 

479
00:09:32,000 --> 00:09:33,509
little bit more faith that things are
right when when everything is sort of

480
00:09:33,509 --> 00:09:33,519
right when when everything is sort of
 

481
00:09:33,519 --> 00:09:35,590
right when when everything is sort of
goes through the the peer review process

482
00:09:35,590 --> 00:09:35,600
goes through the the peer review process
 

483
00:09:35,600 --> 00:09:37,790
goes through the the peer review process
so what this talk is really about is

484
00:09:37,790 --> 00:09:37,800
so what this talk is really about is
 

485
00:09:37,800 --> 00:09:40,150
so what this talk is really about is
with all of this explosion how can we

486
00:09:40,150 --> 00:09:40,160
with all of this explosion how can we
 

487
00:09:40,160 --> 00:09:42,230
with all of this explosion how can we
make use of it where where does all of

488
00:09:42,230 --> 00:09:42,240
make use of it where where does all of
 

489
00:09:42,240 --> 00:09:43,790
make use of it where where does all of
this go to how how can we make use of it

490
00:09:43,790 --> 00:09:43,800
this go to how how can we make use of it
 

491
00:09:43,800 --> 00:09:45,550
this go to how how can we make use of it
so uh just a quick question how many

492
00:09:45,550 --> 00:09:45,560
so uh just a quick question how many
 

493
00:09:45,560 --> 00:09:47,910
so uh just a quick question how many
people here were in Marco's talk this

494
00:09:47,910 --> 00:09:47,920
people here were in Marco's talk this
 

495
00:09:47,920 --> 00:09:50,949
people here were in Marco's talk this
morning about keeping hascal

496
00:09:50,949 --> 00:09:50,959
morning about keeping hascal
 

497
00:09:50,959 --> 00:09:53,630
morning about keeping hascal
simple okay wow not a big overlap

498
00:09:53,630 --> 00:09:53,640
simple okay wow not a big overlap
 

499
00:09:53,640 --> 00:09:56,069
simple okay wow not a big overlap
between that and this I that something

500
00:09:56,069 --> 00:09:56,079
between that and this I that something
 

501
00:09:56,079 --> 00:09:57,430
between that and this I that something
something to be said about that actually

502
00:09:57,430 --> 00:09:57,440
something to be said about that actually
 

503
00:09:57,440 --> 00:09:59,949
something to be said about that actually
so I want to I want to return to that

504
00:09:59,949 --> 00:09:59,959
so I want to I want to return to that
 

505
00:09:59,959 --> 00:10:02,870
so I want to I want to return to that
um because there there's well not many

506
00:10:02,870 --> 00:10:02,880
um because there there's well not many
 

507
00:10:02,880 --> 00:10:03,910
um because there there's well not many
many people were there but I'll return

508
00:10:03,910 --> 00:10:03,920
many people were there but I'll return
 

509
00:10:03,920 --> 00:10:07,230
many people were there but I'll return
to that um so this this talk is really

510
00:10:07,230 --> 00:10:07,240
to that um so this this talk is really
 

511
00:10:07,240 --> 00:10:10,150
to that um so this this talk is really
about Stitch uh so Stitch stands for the

512
00:10:10,150 --> 00:10:10,160
about Stitch uh so Stitch stands for the
 

513
00:10:10,160 --> 00:10:14,590
about Stitch uh so Stitch stands for the
sound type indexed type Checker um and

514
00:10:14,590 --> 00:10:14,600
sound type indexed type Checker um and
 

515
00:10:14,600 --> 00:10:17,630
sound type indexed type Checker um and
it's um it's it's an application of all

516
00:10:17,630 --> 00:10:17,640
it's um it's it's an application of all
 

517
00:10:17,640 --> 00:10:19,790
it's um it's it's an application of all
this technology to something fairly

518
00:10:19,790 --> 00:10:19,800
this technology to something fairly
 

519
00:10:19,800 --> 00:10:21,870
this technology to something fairly
typical so the idea is that we I've

520
00:10:21,870 --> 00:10:21,880
typical so the idea is that we I've
 

521
00:10:21,880 --> 00:10:24,949
typical so the idea is that we I've
implemented a uh a simply typed Lambda

522
00:10:24,949 --> 00:10:24,959
implemented a uh a simply typed Lambda
 

523
00:10:24,959 --> 00:10:28,509
implemented a uh a simply typed Lambda
calculus so you know a criticism at this

524
00:10:28,509 --> 00:10:28,519
calculus so you know a criticism at this
 

525
00:10:28,519 --> 00:10:29,829
calculus so you know a criticism at this
point is well you you know you type

526
00:10:29,829 --> 00:10:29,839
point is well you you know you type
 

527
00:10:29,839 --> 00:10:31,230
point is well you you know you type
system researchers why do you always

528
00:10:31,230 --> 00:10:31,240
system researchers why do you always
 

529
00:10:31,240 --> 00:10:32,590
system researchers why do you always
just implement the simply type Lambda

530
00:10:32,590 --> 00:10:32,600
just implement the simply type Lambda
 

531
00:10:32,600 --> 00:10:33,829
just implement the simply type Lambda
calculus right why don't you do

532
00:10:33,829 --> 00:10:33,839
calculus right why don't you do
 

533
00:10:33,839 --> 00:10:37,430
calculus right why don't you do
something useful um so I would I would I

534
00:10:37,430 --> 00:10:37,440
something useful um so I would I would I
 

535
00:10:37,440 --> 00:10:39,430
something useful um so I would I would I
would argue first off implementing the

536
00:10:39,430 --> 00:10:39,440
would argue first off implementing the
 

537
00:10:39,440 --> 00:10:41,790
would argue first off implementing the
simply type Lambda calculus is really

538
00:10:41,790 --> 00:10:41,800
simply type Lambda calculus is really
 

539
00:10:41,800 --> 00:10:45,310
simply type Lambda calculus is really
useful right large systems all have

540
00:10:45,310 --> 00:10:45,320
useful right large systems all have
 

541
00:10:45,320 --> 00:10:46,829
useful right large systems all have
implementations of some sort of

542
00:10:46,829 --> 00:10:46,839
implementations of some sort of
 

543
00:10:46,839 --> 00:10:48,949
implementations of some sort of
scripting language right whether it's a

544
00:10:48,949 --> 00:10:48,959
scripting language right whether it's a
 

545
00:10:48,959 --> 00:10:50,910
scripting language right whether it's a
productivity Suite right we you know we

546
00:10:50,910 --> 00:10:50,920
productivity Suite right we you know we
 

547
00:10:50,920 --> 00:10:52,670
productivity Suite right we you know we
we know Microsoft Word Microsoft Excel

548
00:10:52,670 --> 00:10:52,680
we know Microsoft Word Microsoft Excel
 

549
00:10:52,680 --> 00:10:55,350
we know Microsoft Word Microsoft Excel
are all scriptable um whether it's it's

550
00:10:55,350 --> 00:10:55,360
are all scriptable um whether it's it's
 

551
00:10:55,360 --> 00:10:57,389
are all scriptable um whether it's it's
um something you know any text editor

552
00:10:57,389 --> 00:10:57,399
um something you know any text editor
 

553
00:10:57,399 --> 00:10:59,389
um something you know any text editor
you have a way of scripting that game

554
00:10:59,389 --> 00:10:59,399
you have a way of scripting that game
 

555
00:10:59,399 --> 00:11:00,790
you have a way of scripting that game
have a way of scripting them there's

556
00:11:00,790 --> 00:11:00,800
have a way of scripting them there's
 

557
00:11:00,800 --> 00:11:02,110
have a way of scripting them there's
been several talks today about build

558
00:11:02,110 --> 00:11:02,120
been several talks today about build
 

559
00:11:02,120 --> 00:11:04,310
been several talks today about build
systems those are run by scripts right

560
00:11:04,310 --> 00:11:04,320
systems those are run by scripts right
 

561
00:11:04,320 --> 00:11:06,710
systems those are run by scripts right
so having you know implementing a

562
00:11:06,710 --> 00:11:06,720
so having you know implementing a
 

563
00:11:06,720 --> 00:11:08,470
so having you know implementing a
language is actually a fairly common

564
00:11:08,470 --> 00:11:08,480
language is actually a fairly common
 

565
00:11:08,480 --> 00:11:10,629
language is actually a fairly common
phenomenon um and the other nice thing

566
00:11:10,629 --> 00:11:10,639
phenomenon um and the other nice thing
 

567
00:11:10,639 --> 00:11:12,030
phenomenon um and the other nice thing
about this example is it's something

568
00:11:12,030 --> 00:11:12,040
about this example is it's something
 

569
00:11:12,040 --> 00:11:13,590
about this example is it's something
that we're all familiar with we know the

570
00:11:13,590 --> 00:11:13,600
that we're all familiar with we know the
 

571
00:11:13,600 --> 00:11:15,629
that we're all familiar with we know the
Lambda calculus even if you've even if

572
00:11:15,629 --> 00:11:15,639
Lambda calculus even if you've even if
 

573
00:11:15,639 --> 00:11:16,590
Lambda calculus even if you've even if
you've never heard of the Lambda

574
00:11:16,590 --> 00:11:16,600
you've never heard of the Lambda
 

575
00:11:16,600 --> 00:11:17,910
you've never heard of the Lambda
calculus before if you've programmed

576
00:11:17,910 --> 00:11:17,920
calculus before if you've programmed
 

577
00:11:17,920 --> 00:11:19,910
calculus before if you've programmed
high school you know the Lambda calculus

578
00:11:19,910 --> 00:11:19,920
high school you know the Lambda calculus
 

579
00:11:19,920 --> 00:11:21,710
high school you know the Lambda calculus
um it's just it's a way of defining

580
00:11:21,710 --> 00:11:21,720
um it's just it's a way of defining
 

581
00:11:21,720 --> 00:11:22,910
um it's just it's a way of defining
these these Anonymous functions and

582
00:11:22,910 --> 00:11:22,920
these these Anonymous functions and
 

583
00:11:22,920 --> 00:11:25,710
these these Anonymous functions and
applying them um so let me sort of go

584
00:11:25,710 --> 00:11:25,720
applying them um so let me sort of go
 

585
00:11:25,720 --> 00:11:27,470
applying them um so let me sort of go
over and show you what this looks like

586
00:11:27,470 --> 00:11:27,480
over and show you what this looks like
 

587
00:11:27,480 --> 00:11:30,230
over and show you what this looks like
and going to have to CL a little bit

588
00:11:30,230 --> 00:11:30,240
and going to have to CL a little bit
 

589
00:11:30,240 --> 00:11:32,829
and going to have to CL a little bit
with the display here does that there we

590
00:11:32,829 --> 00:11:32,839
with the display here does that there we
 

591
00:11:32,839 --> 00:11:35,230
with the display here does that there we
go that's what it should look like okay

592
00:11:35,230 --> 00:11:35,240
go that's what it should look like okay
 

593
00:11:35,240 --> 00:11:37,509
go that's what it should look like okay
um I can make that

594
00:11:37,509 --> 00:11:37,519
um I can make that
 

595
00:11:37,519 --> 00:11:40,430
um I can make that
bigger okay

596
00:11:40,430 --> 00:11:40,440
bigger okay
 

597
00:11:40,440 --> 00:11:43,110
bigger okay
so hopefully this does something yes

598
00:11:43,110 --> 00:11:43,120
so hopefully this does something yes
 

599
00:11:43,120 --> 00:11:47,190
so hopefully this does something yes
good um so so here it is um the one

600
00:11:47,190 --> 00:11:47,200
good um so so here it is um the one
 

601
00:11:47,200 --> 00:11:48,750
good um so so here it is um the one
point I'd like to make is we're going to

602
00:11:48,750 --> 00:11:48,760
point I'd like to make is we're going to
 

603
00:11:48,760 --> 00:11:50,670
point I'd like to make is we're going to
see a lot of fancy code but this is

604
00:11:50,670 --> 00:11:50,680
see a lot of fancy code but this is
 

605
00:11:50,680 --> 00:11:53,350
see a lot of fancy code but this is
actually just an application that runs

606
00:11:53,350 --> 00:11:53,360
actually just an application that runs
 

607
00:11:53,360 --> 00:11:54,910
actually just an application that runs
right anyone can download this and run

608
00:11:54,910 --> 00:11:54,920
right anyone can download this and run
 

609
00:11:54,920 --> 00:11:57,190
right anyone can download this and run
it and I've actually used this to teach

610
00:11:57,190 --> 00:11:57,200
it and I've actually used this to teach
 

611
00:11:57,200 --> 00:11:59,829
it and I've actually used this to teach
undergrads about the Lambda calculus

612
00:11:59,829 --> 00:11:59,839
undergrads about the Lambda calculus
 

613
00:11:59,839 --> 00:12:02,470
undergrads about the Lambda calculus
I've not shown them the Code the code is

614
00:12:02,470 --> 00:12:02,480
I've not shown them the Code the code is
 

615
00:12:02,480 --> 00:12:04,509
I've not shown them the Code the code is
rather is a little bit more intricate

616
00:12:04,509 --> 00:12:04,519
rather is a little bit more intricate
 

617
00:12:04,519 --> 00:12:06,509
rather is a little bit more intricate
but the end application is just an

618
00:12:06,509 --> 00:12:06,519
but the end application is just an
 

619
00:12:06,519 --> 00:12:09,230
but the end application is just an
application um and so you know it it can

620
00:12:09,230 --> 00:12:09,240
application um and so you know it it can
 

621
00:12:09,240 --> 00:12:11,509
application um and so you know it it can
evaluate four that's not a big surprise

622
00:12:11,509 --> 00:12:11,519
evaluate four that's not a big surprise
 

623
00:12:11,519 --> 00:12:14,350
evaluate four that's not a big surprise
it can evaluate 4 plus 6 um so we see

624
00:12:14,350 --> 00:12:14,360
it can evaluate 4 plus 6 um so we see
 

625
00:12:14,360 --> 00:12:16,710
it can evaluate 4 plus 6 um so we see
here that it knows the types of things

626
00:12:16,710 --> 00:12:16,720
here that it knows the types of things
 

627
00:12:16,720 --> 00:12:18,350
here that it knows the types of things
right we can see that that it gives a

628
00:12:18,350 --> 00:12:18,360
right we can see that that it gives a
 

629
00:12:18,360 --> 00:12:20,829
right we can see that that it gives a
type to everything um and it's a Lambda

630
00:12:20,829 --> 00:12:20,839
type to everything um and it's a Lambda
 

631
00:12:20,839 --> 00:12:25,189
type to everything um and it's a Lambda
calculus so I can do something like

632
00:12:25,189 --> 00:12:25,199
calculus so I can do something like
 

633
00:12:25,199 --> 00:12:26,710
calculus so I can do something like
this

634
00:12:26,710 --> 00:12:26,720
this
 

635
00:12:26,720 --> 00:12:29,430
this
um right so I can write a little l a

636
00:12:29,430 --> 00:12:29,440
um right so I can write a little l a
 

637
00:12:29,440 --> 00:12:32,350
um right so I can write a little l a
function I do have to annotate the type

638
00:12:32,350 --> 00:12:32,360
function I do have to annotate the type
 

639
00:12:32,360 --> 00:12:34,389
function I do have to annotate the type
of the bound variable there is no type

640
00:12:34,389 --> 00:12:34,399
of the bound variable there is no type
 

641
00:12:34,399 --> 00:12:36,069
of the bound variable there is no type
inference in this yet Al though I think

642
00:12:36,069 --> 00:12:36,079
inference in this yet Al though I think
 

643
00:12:36,079 --> 00:12:38,430
inference in this yet Al though I think
it would be quite possible to do and and

644
00:12:38,430 --> 00:12:38,440
it would be quite possible to do and and
 

645
00:12:38,440 --> 00:12:41,870
it would be quite possible to do and and
fun uh so that may happen someday um and

646
00:12:41,870 --> 00:12:41,880
fun uh so that may happen someday um and
 

647
00:12:41,880 --> 00:12:44,150
fun uh so that may happen someday um and
and it's higher order so I can do things

648
00:12:44,150 --> 00:12:44,160
and it's higher order so I can do things
 

649
00:12:44,160 --> 00:12:47,269
and it's higher order so I can do things
so here um I can take a function from in

650
00:12:47,269 --> 00:12:47,279
so here um I can take a function from in
 

651
00:12:47,279 --> 00:12:51,629
so here um I can take a function from in
to int and then an argument and apply

652
00:12:51,629 --> 00:12:51,639
to int and then an argument and apply
 

653
00:12:51,639 --> 00:12:54,590
to int and then an argument and apply
that function to that argument twice and

654
00:12:54,590 --> 00:12:54,600
that function to that argument twice and
 

655
00:12:54,600 --> 00:12:57,990
that function to that argument twice and
then I can have a function that adds two

656
00:12:57,990 --> 00:12:58,000
then I can have a function that adds two
 

657
00:12:58,000 --> 00:12:59,710
then I can have a function that adds two
and then apply all of that eight and I

658
00:12:59,710 --> 00:12:59,720
and then apply all of that eight and I
 

659
00:12:59,720 --> 00:13:03,790
and then apply all of that eight and I
get 12 right um so so this is all sort

660
00:13:03,790 --> 00:13:03,800
get 12 right um so so this is all sort
 

661
00:13:03,800 --> 00:13:06,230
get 12 right um so so this is all sort
of like ghci it's not all that exciting

662
00:13:06,230 --> 00:13:06,240
of like ghci it's not all that exciting
 

663
00:13:06,240 --> 00:13:09,030
of like ghci it's not all that exciting
um but one fun thing it can do is I can

664
00:13:09,030 --> 00:13:09,040
um but one fun thing it can do is I can
 

665
00:13:09,040 --> 00:13:10,949
um but one fun thing it can do is I can
ask for how this

666
00:13:10,949 --> 00:13:10,959
ask for how this
 

667
00:13:10,959 --> 00:13:14,550
ask for how this
steps uh so here we can see using sort

668
00:13:14,550 --> 00:13:14,560
steps uh so here we can see using sort
 

669
00:13:14,560 --> 00:13:16,350
steps uh so here we can see using sort
of a small step reduction so again this

670
00:13:16,350 --> 00:13:16,360
of a small step reduction so again this
 

671
00:13:16,360 --> 00:13:18,230
of a small step reduction so again this
is used in an academic environment to

672
00:13:18,230 --> 00:13:18,240
is used in an academic environment to
 

673
00:13:18,240 --> 00:13:20,350
is used in an academic environment to
teach students about Lambic calculus is

674
00:13:20,350 --> 00:13:20,360
teach students about Lambic calculus is
 

675
00:13:20,360 --> 00:13:22,590
teach students about Lambic calculus is
we can see how this would reduce from

676
00:13:22,590 --> 00:13:22,600
we can see how this would reduce from
 

677
00:13:22,600 --> 00:13:25,030
we can see how this would reduce from
the beginning to the end um so one thing

678
00:13:25,030 --> 00:13:25,040
the beginning to the end um so one thing
 

679
00:13:25,040 --> 00:13:27,750
the beginning to the end um so one thing
that we see in the output now is that

680
00:13:27,750 --> 00:13:27,760
that we see in the output now is that
 

681
00:13:27,760 --> 00:13:30,389
that we see in the output now is that
there's these funny hash signs right so

682
00:13:30,389 --> 00:13:30,399
there's these funny hash signs right so
 

683
00:13:30,399 --> 00:13:34,590
there's these funny hash signs right so
my my my initial input has fs and x's in

684
00:13:34,590 --> 00:13:34,600
my my my initial input has fs and x's in
 

685
00:13:34,600 --> 00:13:37,389
my my my initial input has fs and x's in
it but that's all gone for these um

686
00:13:37,389 --> 00:13:37,399
it but that's all gone for these um
 

687
00:13:37,399 --> 00:13:38,750
it but that's all gone for these um
these indices how many people in here

688
00:13:38,750 --> 00:13:38,760
these indices how many people in here
 

689
00:13:38,760 --> 00:13:42,990
these indices how many people in here
know what a de brone IND index is wow

690
00:13:42,990 --> 00:13:43,000
know what a de brone IND index is wow
 

691
00:13:43,000 --> 00:13:45,670
know what a de brone IND index is wow
okay I just like to to to reflect on the

692
00:13:45,670 --> 00:13:45,680
okay I just like to to to reflect on the
 

693
00:13:45,680 --> 00:13:47,670
okay I just like to to to reflect on the
fact that we have a room full of people

694
00:13:47,670 --> 00:13:47,680
fact that we have a room full of people
 

695
00:13:47,680 --> 00:13:49,110
fact that we have a room full of people
many of whom raise their hands for they

696
00:13:49,110 --> 00:13:49,120
many of whom raise their hands for they
 

697
00:13:49,120 --> 00:13:51,310
many of whom raise their hands for they
use hasal for money so your your actual

698
00:13:51,310 --> 00:13:51,320
use hasal for money so your your actual
 

699
00:13:51,320 --> 00:13:53,590
use hasal for money so your your actual
developers um and who know de brown

700
00:13:53,590 --> 00:13:53,600
developers um and who know de brown
 

701
00:13:53,600 --> 00:13:57,749
developers um and who know de brown
indices this is very cool um so um so

702
00:13:57,749 --> 00:13:57,759
indices this is very cool um so um so
 

703
00:13:57,759 --> 00:13:59,710
indices this is very cool um so um so
we'll return to that in in a moment but

704
00:13:59,710 --> 00:13:59,720
we'll return to that in in a moment but
 

705
00:13:59,720 --> 00:14:02,430
we'll return to that in in a moment but
the the bottom line is is that you can

706
00:14:02,430 --> 00:14:02,440
the the bottom line is is that you can
 

707
00:14:02,440 --> 00:14:03,990
the the bottom line is is that you can
you can just sort of guide Yourself by

708
00:14:03,990 --> 00:14:04,000
you can just sort of guide Yourself by
 

709
00:14:04,000 --> 00:14:06,590
you can just sort of guide Yourself by
the colors so when you see a yellow hash

710
00:14:06,590 --> 00:14:06,600
the colors so when you see a yellow hash
 

711
00:14:06,600 --> 00:14:07,790
the colors so when you see a yellow hash
sign that's going to match up with the

712
00:14:07,790 --> 00:14:07,800
sign that's going to match up with the
 

713
00:14:07,800 --> 00:14:10,629
sign that's going to match up with the
yellow variable and and the green hash

714
00:14:10,629 --> 00:14:10,639
yellow variable and and the green hash
 

715
00:14:10,639 --> 00:14:11,949
yellow variable and and the green hash
sign matches up with the green variable

716
00:14:11,949 --> 00:14:11,959
sign matches up with the green variable
 

717
00:14:11,959 --> 00:14:13,710
sign matches up with the green variable
and so on so so we can see how this

718
00:14:13,710 --> 00:14:13,720
and so on so so we can see how this
 

719
00:14:13,720 --> 00:14:16,150
and so on so so we can see how this
reduces so so that's sort of what this

720
00:14:16,150 --> 00:14:16,160
reduces so so that's sort of what this
 

721
00:14:16,160 --> 00:14:18,829
reduces so so that's sort of what this
looks like on the outside um but but the

722
00:14:18,829 --> 00:14:18,839
looks like on the outside um but but the
 

723
00:14:18,839 --> 00:14:20,189
looks like on the outside um but but the
evidence here the reason I'm showing

724
00:14:20,189 --> 00:14:20,199
evidence here the reason I'm showing
 

725
00:14:20,199 --> 00:14:21,749
evidence here the reason I'm showing
this is that there's a parser there's an

726
00:14:21,749 --> 00:14:21,759
this is that there's a parser there's an
 

727
00:14:21,759 --> 00:14:23,310
this is that there's a parser there's an
evaluator there's a pretty printer it's

728
00:14:23,310 --> 00:14:23,320
evaluator there's a pretty printer it's
 

729
00:14:23,320 --> 00:14:24,949
evaluator there's a pretty printer it's
all the stuff that you

730
00:14:24,949 --> 00:14:24,959
all the stuff that you
 

731
00:14:24,959 --> 00:14:27,430
all the stuff that you
want um okay so now we have to fuss with

732
00:14:27,430 --> 00:14:27,440
want um okay so now we have to fuss with
 

733
00:14:27,440 --> 00:14:29,710
want um okay so now we have to fuss with
displays again for a moment

734
00:14:29,710 --> 00:14:29,720
displays again for a moment
 

735
00:14:29,720 --> 00:14:31,670
displays again for a moment
and hopefully it ends up the right way

736
00:14:31,670 --> 00:14:31,680
and hopefully it ends up the right way
 

737
00:14:31,680 --> 00:14:34,870
and hopefully it ends up the right way
yes okay cool um okay so so for those of

738
00:14:34,870 --> 00:14:34,880
yes okay cool um okay so so for those of
 

739
00:14:34,880 --> 00:14:35,829
yes okay cool um okay so so for those of
you that don't know about debrown

740
00:14:35,829 --> 00:14:35,839
you that don't know about debrown
 

741
00:14:35,839 --> 00:14:39,710
you that don't know about debrown
indices it's a way of keeping track of

742
00:14:39,710 --> 00:14:39,720
indices it's a way of keeping track of
 

743
00:14:39,720 --> 00:14:41,790
indices it's a way of keeping track of
variables um so we don't have to worry

744
00:14:41,790 --> 00:14:41,800
variables um so we don't have to worry
 

745
00:14:41,800 --> 00:14:43,790
variables um so we don't have to worry
about their names right of course in my

746
00:14:43,790 --> 00:14:43,800
about their names right of course in my
 

747
00:14:43,800 --> 00:14:45,590
about their names right of course in my
example there I chose F and I chose X

748
00:14:45,590 --> 00:14:45,600
example there I chose F and I chose X
 

749
00:14:45,600 --> 00:14:48,110
example there I chose F and I chose X
but those names are irrelevant um and

750
00:14:48,110 --> 00:14:48,120
but those names are irrelevant um and
 

751
00:14:48,120 --> 00:14:49,550
but those names are irrelevant um and
and when I'm Computing I don't really

752
00:14:49,550 --> 00:14:49,560
and when I'm Computing I don't really
 

753
00:14:49,560 --> 00:14:51,189
and when I'm Computing I don't really
want to have these extra irrelevant

754
00:14:51,189 --> 00:14:51,199
want to have these extra irrelevant
 

755
00:14:51,199 --> 00:14:53,949
want to have these extra irrelevant
things um cluttering up my my my data

756
00:14:53,949 --> 00:14:53,959
things um cluttering up my my my data
 

757
00:14:53,959 --> 00:14:56,990
things um cluttering up my my my data
structure and so instead what we do is

758
00:14:56,990 --> 00:14:57,000
structure and so instead what we do is
 

759
00:14:57,000 --> 00:14:59,269
structure and so instead what we do is
we want to a de brown index count counts

760
00:14:59,269 --> 00:14:59,279
we want to a de brown index count counts
 

761
00:14:59,279 --> 00:15:00,990
we want to a de brown index count counts
the number of intervening binders

762
00:15:00,990 --> 00:15:01,000
the number of intervening binders
 

763
00:15:01,000 --> 00:15:02,870
the number of intervening binders
between a variable binding and its

764
00:15:02,870 --> 00:15:02,880
between a variable binding and its
 

765
00:15:02,880 --> 00:15:04,790
between a variable binding and its
occurrence So What on earth does that

766
00:15:04,790 --> 00:15:04,800
occurrence So What on earth does that
 

767
00:15:04,800 --> 00:15:07,670
occurrence So What on earth does that
mean so that means that

768
00:15:07,670 --> 00:15:07,680
mean so that means that
 

769
00:15:07,680 --> 00:15:11,389
mean so that means that
here we have zero and we see that it's

770
00:15:11,389 --> 00:15:11,399
here we have zero and we see that it's
 

771
00:15:11,399 --> 00:15:13,910
here we have zero and we see that it's
yellow and that means that it looks for

772
00:15:13,910 --> 00:15:13,920
yellow and that means that it looks for
 

773
00:15:13,920 --> 00:15:15,710
yellow and that means that it looks for
the thing that's bound with no lambdas

774
00:15:15,710 --> 00:15:15,720
the thing that's bound with no lambdas
 

775
00:15:15,720 --> 00:15:17,710
the thing that's bound with no lambdas
in between so that's this one zero

776
00:15:17,710 --> 00:15:17,720
in between so that's this one zero
 

777
00:15:17,720 --> 00:15:20,430
in between so that's this one zero
lambdas in between the usage site and

778
00:15:20,430 --> 00:15:20,440
lambdas in between the usage site and
 

779
00:15:20,440 --> 00:15:21,590
lambdas in between the usage site and
The Binding

780
00:15:21,590 --> 00:15:21,600
The Binding
 

781
00:15:21,600 --> 00:15:25,629
The Binding
site um for one here there is one Lambda

782
00:15:25,629 --> 00:15:25,639
site um for one here there is one Lambda
 

783
00:15:25,639 --> 00:15:28,670
site um for one here there is one Lambda
that appears between the usage site and

784
00:15:28,670 --> 00:15:28,680
that appears between the usage site and
 

785
00:15:28,680 --> 00:15:33,269
that appears between the usage site and
the in site um so uh so the the zero and

786
00:15:33,269 --> 00:15:33,279
the in site um so uh so the the zero and
 

787
00:15:33,279 --> 00:15:35,990
the in site um so uh so the the zero and
the one indicate that but um the one of

788
00:15:35,990 --> 00:15:36,000
the one indicate that but um the one of
 

789
00:15:36,000 --> 00:15:37,509
the one indicate that but um the one of
the challenges with the brown indices is

790
00:15:37,509 --> 00:15:37,519
the challenges with the brown indices is
 

791
00:15:37,519 --> 00:15:38,749
the challenges with the brown indices is
that they're hard to keep track of and

792
00:15:38,749 --> 00:15:38,759
that they're hard to keep track of and
 

793
00:15:38,759 --> 00:15:41,030
that they're hard to keep track of and
so I've used colors in the output here

794
00:15:41,030 --> 00:15:41,040
so I've used colors in the output here
 

795
00:15:41,040 --> 00:15:43,069
so I've used colors in the output here
um and and that's sort of a small

796
00:15:43,069 --> 00:15:43,079
um and and that's sort of a small
 

797
00:15:43,079 --> 00:15:44,430
um and and that's sort of a small
Innovation but I've actually gotten a

798
00:15:44,430 --> 00:15:44,440
Innovation but I've actually gotten a
 

799
00:15:44,440 --> 00:15:45,670
Innovation but I've actually gotten a
bunch of people to say that that just

800
00:15:45,670 --> 00:15:45,680
bunch of people to say that that just
 

801
00:15:45,680 --> 00:15:47,110
bunch of people to say that that just
makes a whole lot more sense when

802
00:15:47,110 --> 00:15:47,120
makes a whole lot more sense when
 

803
00:15:47,120 --> 00:15:49,550
makes a whole lot more sense when
there's colors involved um okay so I I

804
00:15:49,550 --> 00:15:49,560
there's colors involved um okay so I I
 

805
00:15:49,560 --> 00:15:50,990
there's colors involved um okay so I I
guess I did that with my finger but the

806
00:15:50,990 --> 00:15:51,000
guess I did that with my finger but the
 

807
00:15:51,000 --> 00:15:53,110
guess I did that with my finger but the
slides have it as well so and we can see

808
00:15:53,110 --> 00:15:53,120
slides have it as well so and we can see
 

809
00:15:53,120 --> 00:15:54,629
slides have it as well so and we can see
that the structure in the de brown

810
00:15:54,629 --> 00:15:54,639
that the structure in the de brown
 

811
00:15:54,639 --> 00:15:57,230
that the structure in the de brown
indices matches the structure uh that I

812
00:15:57,230 --> 00:15:57,240
indices matches the structure uh that I
 

813
00:15:57,240 --> 00:16:00,269
indices matches the structure uh that I
wrote in my uh my initial code

814
00:16:00,269 --> 00:16:00,279
wrote in my uh my initial code
 

815
00:16:00,279 --> 00:16:02,150
wrote in my uh my initial code
okay uh let me just pause here are there

816
00:16:02,150 --> 00:16:02,160
okay uh let me just pause here are there
 

817
00:16:02,160 --> 00:16:06,790
okay uh let me just pause here are there
are there questions so

818
00:16:06,790 --> 00:16:06,800

 

819
00:16:06,800 --> 00:16:10,550

far okay we're good um so why do I use

820
00:16:10,550 --> 00:16:10,560
far okay we're good um so why do I use
 

821
00:16:10,560 --> 00:16:11,990
far okay we're good um so why do I use
de brown indices why don't I just use

822
00:16:11,990 --> 00:16:12,000
de brown indices why don't I just use
 

823
00:16:12,000 --> 00:16:13,829
de brown indices why don't I just use
names so one is I don't have to worry

824
00:16:13,829 --> 00:16:13,839
names so one is I don't have to worry
 

825
00:16:13,839 --> 00:16:15,110
names so one is I don't have to worry
about things like shadowing right

826
00:16:15,110 --> 00:16:15,120
about things like shadowing right
 

827
00:16:15,120 --> 00:16:16,829
about things like shadowing right
shadowing would be if I B if I bind the

828
00:16:16,829 --> 00:16:16,839
shadowing would be if I B if I bind the
 

829
00:16:16,839 --> 00:16:18,430
shadowing would be if I B if I bind the
same variable X twice then there's a lot

830
00:16:18,430 --> 00:16:18,440
same variable X twice then there's a lot
 

831
00:16:18,440 --> 00:16:21,150
same variable X twice then there's a lot
of fussing to do it's not very fun um

832
00:16:21,150 --> 00:16:21,160
of fussing to do it's not very fun um
 

833
00:16:21,160 --> 00:16:22,870
of fussing to do it's not very fun um
these names as I said are meaningless

834
00:16:22,870 --> 00:16:22,880
these names as I said are meaningless
 

835
00:16:22,880 --> 00:16:25,590
these names as I said are meaningless
anyway and the real reason is is that

836
00:16:25,590 --> 00:16:25,600
anyway and the real reason is is that
 

837
00:16:25,600 --> 00:16:27,069
anyway and the real reason is is that
it's much easier to build a system in

838
00:16:27,069 --> 00:16:27,079
it's much easier to build a system in
 

839
00:16:27,079 --> 00:16:28,309
it's much easier to build a system in
the way that I have using debrown

840
00:16:28,309 --> 00:16:28,319
the way that I have using debrown
 

841
00:16:28,319 --> 00:16:29,470
the way that I have using debrown
indices

842
00:16:29,470 --> 00:16:29,480
indices
 

843
00:16:29,480 --> 00:16:31,870
indices
um uh one could contemplate doing other

844
00:16:31,870 --> 00:16:31,880
um uh one could contemplate doing other
 

845
00:16:31,880 --> 00:16:32,990
um uh one could contemplate doing other
things but that would take even more

846
00:16:32,990 --> 00:16:33,000
things but that would take even more
 

847
00:16:33,000 --> 00:16:35,269
things but that would take even more
pyot Technics than than we have here um

848
00:16:35,269 --> 00:16:35,279
pyot Technics than than we have here um
 

849
00:16:35,279 --> 00:16:37,670
pyot Technics than than we have here um
the the real reason in my opinion not to

850
00:16:37,670 --> 00:16:37,680
the the real reason in my opinion not to
 

851
00:16:37,680 --> 00:16:39,230
the the real reason in my opinion not to
use debr indes is that they're hard for

852
00:16:39,230 --> 00:16:39,240
use debr indes is that they're hard for
 

853
00:16:39,240 --> 00:16:41,749
use debr indes is that they're hard for
humans um but uh My Hope Is that the

854
00:16:41,749 --> 00:16:41,759
humans um but uh My Hope Is that the
 

855
00:16:41,759 --> 00:16:43,189
humans um but uh My Hope Is that the
colors helps that a little bit they're

856
00:16:43,189 --> 00:16:43,199
colors helps that a little bit they're
 

857
00:16:43,199 --> 00:16:46,309
colors helps that a little bit they're
really much better for computers um okay

858
00:16:46,309 --> 00:16:46,319
really much better for computers um okay
 

859
00:16:46,319 --> 00:16:48,350
really much better for computers um okay
so this is an interpreter right there's

860
00:16:48,350 --> 00:16:48,360
so this is an interpreter right there's
 

861
00:16:48,360 --> 00:16:49,710
so this is an interpreter right there's
many phases that we have to go through

862
00:16:49,710 --> 00:16:49,720
many phases that we have to go through
 

863
00:16:49,720 --> 00:16:51,790
many phases that we have to go through
the first phase in any interpreter is

864
00:16:51,790 --> 00:16:51,800
the first phase in any interpreter is
 

865
00:16:51,800 --> 00:16:54,350
the first phase in any interpreter is
Lexing so let's see how we do Lexing

866
00:16:54,350 --> 00:16:54,360
Lexing so let's see how we do Lexing
 

867
00:16:54,360 --> 00:16:56,309
Lexing so let's see how we do Lexing
actually let's not see how we do Lexing

868
00:16:56,309 --> 00:16:56,319
actually let's not see how we do Lexing
 

869
00:16:56,319 --> 00:16:58,069
actually let's not see how we do Lexing
Lexing is boring it's the same in this

870
00:16:58,069 --> 00:16:58,079
Lexing is boring it's the same in this
 

871
00:16:58,079 --> 00:16:59,269
Lexing is boring it's the same in this
interpreter as it is in anywhere else

872
00:16:59,269 --> 00:16:59,279
interpreter as it is in anywhere else
 

873
00:16:59,279 --> 00:17:02,189
interpreter as it is in anywhere else
that's skip let's go to parsing um

874
00:17:02,189 --> 00:17:02,199
that's skip let's go to parsing um
 

875
00:17:02,199 --> 00:17:03,430
that's skip let's go to parsing um
parsing actually does turn out to be

876
00:17:03,430 --> 00:17:03,440
parsing actually does turn out to be
 

877
00:17:03,440 --> 00:17:06,189
parsing actually does turn out to be
more interesting here um so we might we

878
00:17:06,189 --> 00:17:06,199
more interesting here um so we might we
 

879
00:17:06,199 --> 00:17:08,990
more interesting here um so we might we
might imagine what is the type of my

880
00:17:08,990 --> 00:17:09,000
might imagine what is the type of my
 

881
00:17:09,000 --> 00:17:12,069
might imagine what is the type of my
parse function so my lexer is going to

882
00:17:12,069 --> 00:17:12,079
parse function so my lexer is going to
 

883
00:17:12,079 --> 00:17:14,429
parse function so my lexer is going to
produce a list of tokens actually

884
00:17:14,429 --> 00:17:14,439
produce a list of tokens actually
 

885
00:17:14,439 --> 00:17:16,470
produce a list of tokens actually
they're L tokens the L stands for

886
00:17:16,470 --> 00:17:16,480
they're L tokens the L stands for
 

887
00:17:16,480 --> 00:17:18,789
they're L tokens the L stands for
located um because I want to know where

888
00:17:18,789 --> 00:17:18,799
located um because I want to know where
 

889
00:17:18,799 --> 00:17:20,390
located um because I want to know where
my tokens have come from so I can report

890
00:17:20,390 --> 00:17:20,400
my tokens have come from so I can report
 

891
00:17:20,400 --> 00:17:22,549
my tokens have come from so I can report
errors to to the user so we get this

892
00:17:22,549 --> 00:17:22,559
errors to to the user so we get this
 

893
00:17:22,559 --> 00:17:24,230
errors to to the user so we get this
list of tokens and I'm going to produce

894
00:17:24,230 --> 00:17:24,240
list of tokens and I'm going to produce
 

895
00:17:24,240 --> 00:17:28,429
list of tokens and I'm going to produce
a ux um U here stands for unchecked

896
00:17:28,429 --> 00:17:28,439
a ux um U here stands for unchecked
 

897
00:17:28,439 --> 00:17:30,750
a ux um U here stands for unchecked
we'll see that there's an X Type later

898
00:17:30,750 --> 00:17:30,760
we'll see that there's an X Type later
 

899
00:17:30,760 --> 00:17:33,070
we'll see that there's an X Type later
that has been checked um but that's

900
00:17:33,070 --> 00:17:33,080
that has been checked um but that's
 

901
00:17:33,080 --> 00:17:34,470
that has been checked um but that's
that's where you com from but it's it's

902
00:17:34,470 --> 00:17:34,480
that's where you com from but it's it's
 

903
00:17:34,480 --> 00:17:35,909
that's where you com from but it's it's
this expression type we'll see it quite

904
00:17:35,909 --> 00:17:35,919
this expression type we'll see it quite
 

905
00:17:35,919 --> 00:17:39,190
this expression type we'll see it quite
shortly um this is no good as as the

906
00:17:39,190 --> 00:17:39,200
shortly um this is no good as as the
 

907
00:17:39,200 --> 00:17:42,230
shortly um this is no good as as the
type for for my parse um because it

908
00:17:42,230 --> 00:17:42,240
type for for my parse um because it
 

909
00:17:42,240 --> 00:17:44,270
type for for my parse um because it
doesn't it doesn't accommodate errors

910
00:17:44,270 --> 00:17:44,280
doesn't it doesn't accommodate errors
 

911
00:17:44,280 --> 00:17:45,710
doesn't it doesn't accommodate errors
right we might we might have a parse

912
00:17:45,710 --> 00:17:45,720
right we might we might have a parse
 

913
00:17:45,720 --> 00:17:47,669
right we might we might have a parse
failure and I don't want to just call

914
00:17:47,669 --> 00:17:47,679
failure and I don't want to just call
 

915
00:17:47,679 --> 00:17:49,390
failure and I don't want to just call
the error function that would be really

916
00:17:49,390 --> 00:17:49,400
the error function that would be really
 

917
00:17:49,400 --> 00:17:52,590
the error function that would be really
bad um so instead I might try this so

918
00:17:52,590 --> 00:17:52,600
bad um so instead I might try this so
 

919
00:17:52,600 --> 00:17:53,909
bad um so instead I might try this so
it's going to be a list of tokens and it

920
00:17:53,909 --> 00:17:53,919
it's going to be a list of tokens and it
 

921
00:17:53,919 --> 00:17:57,549
it's going to be a list of tokens and it
returns either um an error string or an

922
00:17:57,549 --> 00:17:57,559
returns either um an error string or an
 

923
00:17:57,559 --> 00:17:59,950
returns either um an error string or an
expression and you know some people

924
00:17:59,950 --> 00:17:59,960
expression and you know some people
 

925
00:17:59,960 --> 00:18:01,630
expression and you know some people
might stop there and be content with

926
00:18:01,630 --> 00:18:01,640
might stop there and be content with
 

927
00:18:01,640 --> 00:18:03,789
might stop there and be content with
this but but I'm never content with that

928
00:18:03,789 --> 00:18:03,799
this but but I'm never content with that
 

929
00:18:03,799 --> 00:18:05,669
this but but I'm never content with that
um because I don't want to just say that

930
00:18:05,669 --> 00:18:05,679
um because I don't want to just say that
 

931
00:18:05,679 --> 00:18:08,070
um because I don't want to just say that
it should be any expression if the user

932
00:18:08,070 --> 00:18:08,080
it should be any expression if the user
 

933
00:18:08,080 --> 00:18:11,390
it should be any expression if the user
types in x + one on the on the on the

934
00:18:11,390 --> 00:18:11,400
types in x + one on the on the on the
 

935
00:18:11,400 --> 00:18:14,390
types in x + one on the on the on the
input line there well that's not quite

936
00:18:14,390 --> 00:18:14,400
input line there well that's not quite
 

937
00:18:14,400 --> 00:18:16,510
input line there well that's not quite
right we don't know what x is so I want

938
00:18:16,510 --> 00:18:16,520
right we don't know what x is so I want
 

939
00:18:16,520 --> 00:18:20,350
right we don't know what x is so I want
to specifically say that we want closed

940
00:18:20,350 --> 00:18:20,360
to specifically say that we want closed
 

941
00:18:20,360 --> 00:18:22,110
to specifically say that we want closed
Expressions we don't want any free

942
00:18:22,110 --> 00:18:22,120
Expressions we don't want any free
 

943
00:18:22,120 --> 00:18:23,549
Expressions we don't want any free
variables every variable that gets

944
00:18:23,549 --> 00:18:23,559
variables every variable that gets
 

945
00:18:23,559 --> 00:18:26,110
variables every variable that gets
mentioned has to be bound and so what I

946
00:18:26,110 --> 00:18:26,120
mentioned has to be bound and so what I
 

947
00:18:26,120 --> 00:18:28,870
mentioned has to be bound and so what I
want is

948
00:18:28,870 --> 00:18:28,880
want is
 

949
00:18:28,880 --> 00:18:31,430
want is
is that um and I apologize the green is

950
00:18:31,430 --> 00:18:31,440
is that um and I apologize the green is
 

951
00:18:31,440 --> 00:18:33,190
is that um and I apologize the green is
a little dim up here it's it's quite a

952
00:18:33,190 --> 00:18:33,200
a little dim up here it's it's quite a
 

953
00:18:33,200 --> 00:18:34,669
a little dim up here it's it's quite a
bit brighter up here so hopefully

954
00:18:34,669 --> 00:18:34,679
bit brighter up here so hopefully
 

955
00:18:34,679 --> 00:18:36,110
bit brighter up here so hopefully
everyone can still read that it's a

956
00:18:36,110 --> 00:18:36,120
everyone can still read that it's a
 

957
00:18:36,120 --> 00:18:39,870
everyone can still read that it's a
little dimmer than I'd like um but um uh

958
00:18:39,870 --> 00:18:39,880
little dimmer than I'd like um but um uh
 

959
00:18:39,880 --> 00:18:41,350
little dimmer than I'd like um but um uh
I want this type so this is the real

960
00:18:41,350 --> 00:18:41,360
I want this type so this is the real
 

961
00:18:41,360 --> 00:18:44,029
I want this type so this is the real
type of of my parser um is that it takes

962
00:18:44,029 --> 00:18:44,039
type of of my parser um is that it takes
 

963
00:18:44,039 --> 00:18:45,230
type of of my parser um is that it takes
this list of tokens and it either

964
00:18:45,230 --> 00:18:45,240
this list of tokens and it either
 

965
00:18:45,240 --> 00:18:48,789
this list of tokens and it either
produces an error or a ux zero so let's

966
00:18:48,789 --> 00:18:48,799
produces an error or a ux zero so let's
 

967
00:18:48,799 --> 00:18:50,549
produces an error or a ux zero so let's
talk about what what that is that's

968
00:18:50,549 --> 00:18:50,559
talk about what what that is that's
 

969
00:18:50,559 --> 00:18:52,750
talk about what what that is that's
going to be the number of variables in

970
00:18:52,750 --> 00:18:52,760
going to be the number of variables in
 

971
00:18:52,760 --> 00:18:54,630
going to be the number of variables in
scope that were sort of in scope before

972
00:18:54,630 --> 00:18:54,640
scope that were sort of in scope before
 

973
00:18:54,640 --> 00:18:56,590
scope that were sort of in scope before
I started parsing so we start out with

974
00:18:56,590 --> 00:18:56,600
I started parsing so we start out with
 

975
00:18:56,600 --> 00:18:58,350
I started parsing so we start out with
no variables in scope so that's why it's

976
00:18:58,350 --> 00:18:58,360
no variables in scope so that's why it's
 

977
00:18:58,360 --> 00:19:00,070
no variables in scope so that's why it's
zero

978
00:19:00,070 --> 00:19:00,080
zero
 

979
00:19:00,080 --> 00:19:05,190
zero
um okay so what is this ux thing um so

980
00:19:05,190 --> 00:19:05,200
um okay so what is this ux thing um so
 

981
00:19:05,200 --> 00:19:06,950
um okay so what is this ux thing um so
here's here's the definition of of part

982
00:19:06,950 --> 00:19:06,960
here's here's the definition of of part
 

983
00:19:06,960 --> 00:19:10,870
here's here's the definition of of part
of ux um so first off like every good

984
00:19:10,870 --> 00:19:10,880
of ux um so first off like every good
 

985
00:19:10,880 --> 00:19:12,630
of ux um so first off like every good
talk with lots and lots of types I have

986
00:19:12,630 --> 00:19:12,640
talk with lots and lots of types I have
 

987
00:19:12,640 --> 00:19:16,310
talk with lots and lots of types I have
my unary natural numbers um here so we

988
00:19:16,310 --> 00:19:16,320
my unary natural numbers um here so we
 

989
00:19:16,320 --> 00:19:18,950
my unary natural numbers um here so we
have a a natural number is either zero

990
00:19:18,950 --> 00:19:18,960
have a a natural number is either zero
 

991
00:19:18,960 --> 00:19:21,909
have a a natural number is either zero
or one plus another natural number um

992
00:19:21,909 --> 00:19:21,919
or one plus another natural number um
 

993
00:19:21,919 --> 00:19:26,710
or one plus another natural number um
and then I use that to index um my my ux

994
00:19:26,710 --> 00:19:26,720
and then I use that to index um my my ux
 

995
00:19:26,720 --> 00:19:29,750
and then I use that to index um my my ux
type so once again this index tells me

996
00:19:29,750 --> 00:19:29,760
type so once again this index tells me
 

997
00:19:29,760 --> 00:19:31,909
type so once again this index tells me
the number of variables that are in

998
00:19:31,909 --> 00:19:31,919
the number of variables that are in
 

999
00:19:31,919 --> 00:19:34,590
the number of variables that are in
scope in this

1000
00:19:34,590 --> 00:19:34,600
scope in this
 

1001
00:19:34,600 --> 00:19:38,230
scope in this
ux um here and we'll get back to Finn in

1002
00:19:38,230 --> 00:19:38,240
ux um here and we'll get back to Finn in
 

1003
00:19:38,240 --> 00:19:40,630
ux um here and we'll get back to Finn in
in just a moment but so if I have a

1004
00:19:40,630 --> 00:19:40,640
in just a moment but so if I have a
 

1005
00:19:40,640 --> 00:19:42,789
in just a moment but so if I have a
variable so this is when I write an X in

1006
00:19:42,789 --> 00:19:42,799
variable so this is when I write an X in
 

1007
00:19:42,799 --> 00:19:45,070
variable so this is when I write an X in
my program that's going to be this de

1008
00:19:45,070 --> 00:19:45,080
my program that's going to be this de
 

1009
00:19:45,080 --> 00:19:46,549
my program that's going to be this de
brown index so this is going to be you

1010
00:19:46,549 --> 00:19:46,559
brown index so this is going to be you
 

1011
00:19:46,559 --> 00:19:48,149
brown index so this is going to be you
know a number zero or one or two

1012
00:19:48,149 --> 00:19:48,159
know a number zero or one or two
 

1013
00:19:48,159 --> 00:19:50,430
know a number zero or one or two
something like that

1014
00:19:50,430 --> 00:19:50,440
something like that
 

1015
00:19:50,440 --> 00:19:55,590
something like that
um and um when I have a Lambda then I

1016
00:19:55,590 --> 00:19:55,600
um and um when I have a Lambda then I
 

1017
00:19:55,600 --> 00:19:57,470
um and um when I have a Lambda then I
need to know the type of the bound

1018
00:19:57,470 --> 00:19:57,480
need to know the type of the bound
 

1019
00:19:57,480 --> 00:19:59,789
need to know the type of the bound
variable so that's this this AR type

1020
00:19:59,789 --> 00:19:59,799
variable so that's this this AR type
 

1021
00:19:59,799 --> 00:20:01,310
variable so that's this this AR type
here so I going to have a type tie that

1022
00:20:01,310 --> 00:20:01,320
here so I going to have a type tie that
 

1023
00:20:01,320 --> 00:20:03,470
here so I going to have a type tie that
we'll meet later on um and then the

1024
00:20:03,470 --> 00:20:03,480
we'll meet later on um and then the
 

1025
00:20:03,480 --> 00:20:04,950
we'll meet later on um and then the
function body is going to be another

1026
00:20:04,950 --> 00:20:04,960
function body is going to be another
 

1027
00:20:04,960 --> 00:20:07,470
function body is going to be another
expression but this has one more bound

1028
00:20:07,470 --> 00:20:07,480
expression but this has one more bound
 

1029
00:20:07,480 --> 00:20:10,149
expression but this has one more bound
variable than than sort of the the

1030
00:20:10,149 --> 00:20:10,159
variable than than sort of the the
 

1031
00:20:10,159 --> 00:20:13,590
variable than than sort of the the
outside right so in my recursive use of

1032
00:20:13,590 --> 00:20:13,600
outside right so in my recursive use of
 

1033
00:20:13,600 --> 00:20:17,830
outside right so in my recursive use of
ux I say suck n here right because

1034
00:20:17,830 --> 00:20:17,840
ux I say suck n here right because
 

1035
00:20:17,840 --> 00:20:19,950
ux I say suck n here right because
there's one more bound variable inside

1036
00:20:19,950 --> 00:20:19,960
there's one more bound variable inside
 

1037
00:20:19,960 --> 00:20:22,350
there's one more bound variable inside
of a Lambda than

1038
00:20:22,350 --> 00:20:22,360
of a Lambda than
 

1039
00:20:22,360 --> 00:20:24,909
of a Lambda than
outside um I have let in my language we

1040
00:20:24,909 --> 00:20:24,919
outside um I have let in my language we
 

1041
00:20:24,919 --> 00:20:26,350
outside um I have let in my language we
didn't see an example of that but we do

1042
00:20:26,350 --> 00:20:26,360
didn't see an example of that but we do
 

1043
00:20:26,360 --> 00:20:29,190
didn't see an example of that but we do
have let um and so the you know we have

1044
00:20:29,190 --> 00:20:29,200
have let um and so the you know we have
 

1045
00:20:29,200 --> 00:20:32,110
have let um and so the you know we have
let x equals some expression in some

1046
00:20:32,110 --> 00:20:32,120
let x equals some expression in some
 

1047
00:20:32,120 --> 00:20:33,630
let x equals some expression in some
other expression so the first expression

1048
00:20:33,630 --> 00:20:33,640
other expression so the first expression
 

1049
00:20:33,640 --> 00:20:35,870
other expression so the first expression
is over here that has the same number of

1050
00:20:35,870 --> 00:20:35,880
is over here that has the same number of
 

1051
00:20:35,880 --> 00:20:38,870
is over here that has the same number of
bound variables my let is not recursive

1052
00:20:38,870 --> 00:20:38,880
bound variables my let is not recursive
 

1053
00:20:38,880 --> 00:20:40,870
bound variables my let is not recursive
if my let were recursive then this would

1054
00:20:40,870 --> 00:20:40,880
if my let were recursive then this would
 

1055
00:20:40,880 --> 00:20:43,470
if my let were recursive then this would
have the suck here um but then in the

1056
00:20:43,470 --> 00:20:43,480
have the suck here um but then in the
 

1057
00:20:43,480 --> 00:20:45,789
have the suck here um but then in the
body of the let I do have one more

1058
00:20:45,789 --> 00:20:45,799
body of the let I do have one more
 

1059
00:20:45,799 --> 00:20:48,149
body of the let I do have one more
variable so I have the suck

1060
00:20:48,149 --> 00:20:48,159
variable so I have the suck
 

1061
00:20:48,159 --> 00:20:50,630
variable so I have the suck
there um it's it's also worth at this

1062
00:20:50,630 --> 00:20:50,640
there um it's it's also worth at this
 

1063
00:20:50,640 --> 00:20:52,270
there um it's it's also worth at this
point just sort of calling out my my

1064
00:20:52,270 --> 00:20:52,280
point just sort of calling out my my
 

1065
00:20:52,280 --> 00:20:54,950
point just sort of calling out my my
coloring convention here so we have um

1066
00:20:54,950 --> 00:20:54,960
coloring convention here so we have um
 

1067
00:20:54,960 --> 00:20:59,070
coloring convention here so we have um
keywords in blue um we have types in

1068
00:20:59,070 --> 00:20:59,080
keywords in blue um we have types in
 

1069
00:20:59,080 --> 00:21:01,750
keywords in blue um we have types in
green we have data Constructors and I

1070
00:21:01,750 --> 00:21:01,760
green we have data Constructors and I
 

1071
00:21:01,760 --> 00:21:03,350
green we have data Constructors and I
think that's burnt umber or something

1072
00:21:03,350 --> 00:21:03,360
think that's burnt umber or something
 

1073
00:21:03,360 --> 00:21:06,110
think that's burnt umber or something
like that um we have local variables in

1074
00:21:06,110 --> 00:21:06,120
like that um we have local variables in
 

1075
00:21:06,120 --> 00:21:07,510
like that um we have local variables in
purple and then there's one or two other

1076
00:21:07,510 --> 00:21:07,520
purple and then there's one or two other
 

1077
00:21:07,520 --> 00:21:10,830
purple and then there's one or two other
colors that that will will pop up um but

1078
00:21:10,830 --> 00:21:10,840
colors that that will will pop up um but
 

1079
00:21:10,840 --> 00:21:12,909
colors that that will will pop up um but
one thing that I'm I'm careful about

1080
00:21:12,909 --> 00:21:12,919
one thing that I'm I'm careful about
 

1081
00:21:12,919 --> 00:21:16,310
one thing that I'm I'm careful about
here is to distinguish between um

1082
00:21:16,310 --> 00:21:16,320
here is to distinguish between um
 

1083
00:21:16,320 --> 00:21:20,710
here is to distinguish between um
between types and data so here zero and

1084
00:21:20,710 --> 00:21:20,720
between types and data so here zero and
 

1085
00:21:20,720 --> 00:21:24,350
between types and data so here zero and
suck those are data it so happens that

1086
00:21:24,350 --> 00:21:24,360
suck those are data it so happens that
 

1087
00:21:24,360 --> 00:21:26,470
suck those are data it so happens that
hasell now allows us to mix data with

1088
00:21:26,470 --> 00:21:26,480
hasell now allows us to mix data with
 

1089
00:21:26,480 --> 00:21:28,789
hasell now allows us to mix data with
types so I can write suck here in the

1090
00:21:28,789 --> 00:21:28,799
types so I can write suck here in the
 

1091
00:21:28,799 --> 00:21:31,070
types so I can write suck here in the
middle of what would otherwise be a type

1092
00:21:31,070 --> 00:21:31,080
middle of what would otherwise be a type
 

1093
00:21:31,080 --> 00:21:32,909
middle of what would otherwise be a type
but it's actually a piece of data it

1094
00:21:32,909 --> 00:21:32,919
but it's actually a piece of data it
 

1095
00:21:32,919 --> 00:21:35,390
but it's actually a piece of data it
just happens to be compile time data so

1096
00:21:35,390 --> 00:21:35,400
just happens to be compile time data so
 

1097
00:21:35,400 --> 00:21:36,950
just happens to be compile time data so
this disagrees with the way a lot of

1098
00:21:36,950 --> 00:21:36,960
this disagrees with the way a lot of
 

1099
00:21:36,960 --> 00:21:39,430
this disagrees with the way a lot of
people describe what's going on but it's

1100
00:21:39,430 --> 00:21:39,440
people describe what's going on but it's
 

1101
00:21:39,440 --> 00:21:41,390
people describe what's going on but it's
the language that that I I I find is a

1102
00:21:41,390 --> 00:21:41,400
the language that that I I I find is a
 

1103
00:21:41,400 --> 00:21:43,029
the language that that I I I find is a
little clearer around this than talking

1104
00:21:43,029 --> 00:21:43,039
little clearer around this than talking
 

1105
00:21:43,039 --> 00:21:45,909
little clearer around this than talking
about promotion and things like that um

1106
00:21:45,909 --> 00:21:45,919
about promotion and things like that um
 

1107
00:21:45,919 --> 00:21:47,710
about promotion and things like that um
okay so I want to go back and describe

1108
00:21:47,710 --> 00:21:47,720
okay so I want to go back and describe
 

1109
00:21:47,720 --> 00:21:50,190
okay so I want to go back and describe
oh yes please is the application saying

1110
00:21:50,190 --> 00:21:50,200
oh yes please is the application saying
 

1111
00:21:50,200 --> 00:21:53,149
oh yes please is the application saying
that the ends must be the

1112
00:21:53,149 --> 00:21:53,159
that the ends must be the
 

1113
00:21:53,159 --> 00:21:55,830
that the ends must be the
same application of one to

1114
00:21:55,830 --> 00:21:55,840
same application of one to
 

1115
00:21:55,840 --> 00:21:57,870
same application of one to
another the natural number should be the

1116
00:21:57,870 --> 00:21:57,880
another the natural number should be the
 

1117
00:21:57,880 --> 00:21:59,789
another the natural number should be the
same number yes exactly that's exactly

1118
00:21:59,789 --> 00:21:59,799
same number yes exactly that's exactly
 

1119
00:21:59,799 --> 00:22:02,710
same number yes exactly that's exactly
what it's saying so right because when

1120
00:22:02,710 --> 00:22:02,720
what it's saying so right because when
 

1121
00:22:02,720 --> 00:22:06,710
what it's saying so right because when
we have F applied to X both F and X are

1122
00:22:06,710 --> 00:22:06,720
we have F applied to X both F and X are
 

1123
00:22:06,720 --> 00:22:09,149
we have F applied to X both F and X are
are are in the same context there the

1124
00:22:09,149 --> 00:22:09,159
are are in the same context there the
 

1125
00:22:09,159 --> 00:22:11,230
are are in the same context there the
same variables that are in scope for

1126
00:22:11,230 --> 00:22:11,240
same variables that are in scope for
 

1127
00:22:11,240 --> 00:22:14,269
same variables that are in scope for
both uh a function and and its argument

1128
00:22:14,269 --> 00:22:14,279
both uh a function and and its argument
 

1129
00:22:14,279 --> 00:22:16,909
both uh a function and and its argument
so that's why we have the same end later

1130
00:22:16,909 --> 00:22:16,919
so that's why we have the same end later
 

1131
00:22:16,919 --> 00:22:18,789
so that's why we have the same end later
we'll see that there's some typy stuff

1132
00:22:18,789 --> 00:22:18,799
we'll see that there's some typy stuff
 

1133
00:22:18,799 --> 00:22:20,190
we'll see that there's some typy stuff
and and we're not but we're not getting

1134
00:22:20,190 --> 00:22:20,200
and and we're not but we're not getting
 

1135
00:22:20,200 --> 00:22:21,870
and and we're not but we're not getting
to types

1136
00:22:21,870 --> 00:22:21,880
to types
 

1137
00:22:21,880 --> 00:22:24,310
to types
yet other questions thank you for

1138
00:22:24,310 --> 00:22:24,320
yet other questions thank you for
 

1139
00:22:24,320 --> 00:22:30,230
yet other questions thank you for
interrupting me by the way

1140
00:22:30,230 --> 00:22:30,240

 

1141
00:22:30,240 --> 00:22:33,430

okay um okay so Finn I said that this is

1142
00:22:33,430 --> 00:22:33,440
okay um okay so Finn I said that this is
 

1143
00:22:33,440 --> 00:22:35,669
okay um okay so Finn I said that this is
some storage of these de brown indices

1144
00:22:35,669 --> 00:22:35,679
some storage of these de brown indices
 

1145
00:22:35,679 --> 00:22:38,830
some storage of these de brown indices
so Finn stands for finite set the type

1146
00:22:38,830 --> 00:22:38,840
so Finn stands for finite set the type
 

1147
00:22:38,840 --> 00:22:43,669
so Finn stands for finite set the type
Fin n contains exactly n values so what

1148
00:22:43,669 --> 00:22:43,679
Fin n contains exactly n values so what
 

1149
00:22:43,679 --> 00:22:47,510
Fin n contains exactly n values so what
that means is if we if we just go back

1150
00:22:47,510 --> 00:22:47,520
that means is if we if we just go back
 

1151
00:22:47,520 --> 00:22:53,230
that means is if we if we just go back
here right so uar um uh takes a Fin n so

1152
00:22:53,230 --> 00:22:53,240
here right so uar um uh takes a Fin n so
 

1153
00:22:53,240 --> 00:22:57,870
here right so uar um uh takes a Fin n so
I know if my index N is a two then my

1154
00:22:57,870 --> 00:22:57,880
I know if my index N is a two then my
 

1155
00:22:57,880 --> 00:23:01,110
I know if my index N is a two then my
Fin n must be either zero or one it

1156
00:23:01,110 --> 00:23:01,120
Fin n must be either zero or one it
 

1157
00:23:01,120 --> 00:23:04,830
Fin n must be either zero or one it
can't be anything else if n is zero then

1158
00:23:04,830 --> 00:23:04,840
can't be anything else if n is zero then
 

1159
00:23:04,840 --> 00:23:07,549
can't be anything else if n is zero then
my Finn can't be anything at

1160
00:23:07,549 --> 00:23:07,559
my Finn can't be anything at
 

1161
00:23:07,559 --> 00:23:11,870
my Finn can't be anything at
all was there a question no okay okay um

1162
00:23:11,870 --> 00:23:11,880
all was there a question no okay okay um
 

1163
00:23:11,880 --> 00:23:14,149
all was there a question no okay okay um
okay so now I have to go through all of

1164
00:23:14,149 --> 00:23:14,159
okay so now I have to go through all of
 

1165
00:23:14,159 --> 00:23:18,710
okay so now I have to go through all of
these extra words that appear okay um so

1166
00:23:18,710 --> 00:23:18,720
these extra words that appear okay um so
 

1167
00:23:18,720 --> 00:23:20,149
these extra words that appear okay um so
anyone who's paying close attention this

1168
00:23:20,149 --> 00:23:20,159
anyone who's paying close attention this
 

1169
00:23:20,159 --> 00:23:22,630
anyone who's paying close attention this
morning would realize oh but Finn zero

1170
00:23:22,630 --> 00:23:22,640
morning would realize oh but Finn zero
 

1171
00:23:22,640 --> 00:23:24,950
morning would realize oh but Finn zero
still has bottom yes it does let's just

1172
00:23:24,950 --> 00:23:24,960
still has bottom yes it does let's just
 

1173
00:23:24,960 --> 00:23:27,029
still has bottom yes it does let's just
ignore that we're just going to pretend

1174
00:23:27,029 --> 00:23:27,039
ignore that we're just going to pretend
 

1175
00:23:27,039 --> 00:23:29,269
ignore that we're just going to pretend
that that's not going to happen um it

1176
00:23:29,269 --> 00:23:29,279
that that's not going to happen um it
 

1177
00:23:29,279 --> 00:23:31,230
that that's not going to happen um it
turns out in the code some of these

1178
00:23:31,230 --> 00:23:31,240
turns out in the code some of these
 

1179
00:23:31,240 --> 00:23:33,110
turns out in the code some of these
strange pattern match things this

1180
00:23:33,110 --> 00:23:33,120
strange pattern match things this
 

1181
00:23:33,120 --> 00:23:35,029
strange pattern match things this
morning happened and so I have to

1182
00:23:35,029 --> 00:23:35,039
morning happened and so I have to
 

1183
00:23:35,039 --> 00:23:36,870
morning happened and so I have to
reverse the order of arguments to some

1184
00:23:36,870 --> 00:23:36,880
reverse the order of arguments to some
 

1185
00:23:36,880 --> 00:23:38,470
reverse the order of arguments to some
functions to get the left to right order

1186
00:23:38,470 --> 00:23:38,480
functions to get the left to right order
 

1187
00:23:38,480 --> 00:23:40,430
functions to get the left to right order
to work out to get better completeness

1188
00:23:40,430 --> 00:23:40,440
to work out to get better completeness
 

1189
00:23:40,440 --> 00:23:45,669
to work out to get better completeness
mornings very sad um okay so so here's

1190
00:23:45,669 --> 00:23:45,679
mornings very sad um okay so so here's
 

1191
00:23:45,679 --> 00:23:49,230
mornings very sad um okay so so here's
the definition of fin um of all I I I

1192
00:23:49,230 --> 00:23:49,240
the definition of fin um of all I I I
 

1193
00:23:49,240 --> 00:23:50,789
the definition of fin um of all I I I
spend a fair amount of time looking at

1194
00:23:50,789 --> 00:23:50,799
spend a fair amount of time looking at
 

1195
00:23:50,799 --> 00:23:53,110
spend a fair amount of time looking at
these fancy types Finn always does my

1196
00:23:53,110 --> 00:23:53,120
these fancy types Finn always does my
 

1197
00:23:53,120 --> 00:23:56,350
these fancy types Finn always does my
head in so um let's just try to

1198
00:23:56,350 --> 00:23:56,360
head in so um let's just try to
 

1199
00:23:56,360 --> 00:23:57,789
head in so um let's just try to
understand it by example instead of

1200
00:23:57,789 --> 00:23:57,799
understand it by example instead of
 

1201
00:23:57,799 --> 00:23:59,269
understand it by example instead of
trying to sort of pull apart the

1202
00:23:59,269 --> 00:23:59,279
trying to sort of pull apart the
 

1203
00:23:59,279 --> 00:24:02,390
trying to sort of pull apart the
definition there um so so let's say I

1204
00:24:02,390 --> 00:24:02,400
definition there um so so let's say I
 

1205
00:24:02,400 --> 00:24:04,590
definition there um so so let's say I
want something of type fin

1206
00:24:04,590 --> 00:24:04,600
want something of type fin
 

1207
00:24:04,600 --> 00:24:09,870
want something of type fin
five well FS FS FZ in other words two

1208
00:24:09,870 --> 00:24:09,880
five well FS FS FZ in other words two
 

1209
00:24:09,880 --> 00:24:12,149
five well FS FS FZ in other words two
has Type fin five right two is less than

1210
00:24:12,149 --> 00:24:12,159
has Type fin five right two is less than
 

1211
00:24:12,159 --> 00:24:14,750
has Type fin five right two is less than
five is sort of what I'm saying here um

1212
00:24:14,750 --> 00:24:14,760
five is sort of what I'm saying here um
 

1213
00:24:14,760 --> 00:24:16,710
five is sort of what I'm saying here um
and so the way that we can understand

1214
00:24:16,710 --> 00:24:16,720
and so the way that we can understand
 

1215
00:24:16,720 --> 00:24:19,029
and so the way that we can understand
this is is by sort of following the

1216
00:24:19,029 --> 00:24:19,039
this is is by sort of following the
 

1217
00:24:19,039 --> 00:24:21,630
this is is by sort of following the
types so here by the way I've written

1218
00:24:21,630 --> 00:24:21,640
types so here by the way I've written
 

1219
00:24:21,640 --> 00:24:23,510
types so here by the way I've written
five I really should have written suck

1220
00:24:23,510 --> 00:24:23,520
five I really should have written suck
 

1221
00:24:23,520 --> 00:24:26,310
five I really should have written suck
suck suck suck suck zero but that's

1222
00:24:26,310 --> 00:24:26,320
suck suck suck suck zero but that's
 

1223
00:24:26,320 --> 00:24:29,430
suck suck suck suck zero but that's
annoying so I just wrote five

1224
00:24:29,430 --> 00:24:29,440
annoying so I just wrote five
 

1225
00:24:29,440 --> 00:24:32,510
annoying so I just wrote five
um so uh let's see how is how is this

1226
00:24:32,510 --> 00:24:32,520
um so uh let's see how is how is this
 

1227
00:24:32,520 --> 00:24:36,350
um so uh let's see how is how is this
working um we we we follow the types so

1228
00:24:36,350 --> 00:24:36,360
working um we we we follow the types so
 

1229
00:24:36,360 --> 00:24:39,789
working um we we we follow the types so
if FS of something has fin five we see

1230
00:24:39,789 --> 00:24:39,799
if FS of something has fin five we see
 

1231
00:24:39,799 --> 00:24:44,510
if FS of something has fin five we see
that FS has ends in type with fin of su

1232
00:24:44,510 --> 00:24:44,520
that FS has ends in type with fin of su
 

1233
00:24:44,520 --> 00:24:47,070
that FS has ends in type with fin of su
so that means that the n in this outer

1234
00:24:47,070 --> 00:24:47,080
so that means that the n in this outer
 

1235
00:24:47,080 --> 00:24:49,630
so that means that the n in this outer
FS has to be a four right because it

1236
00:24:49,630 --> 00:24:49,640
FS has to be a four right because it
 

1237
00:24:49,640 --> 00:24:51,830
FS has to be a four right because it
produces a five so that means that this

1238
00:24:51,830 --> 00:24:51,840
produces a five so that means that this
 

1239
00:24:51,840 --> 00:24:54,549
produces a five so that means that this
inner FS has to produce a four so that

1240
00:24:54,549 --> 00:24:54,559
inner FS has to produce a four so that
 

1241
00:24:54,559 --> 00:24:57,029
inner FS has to produce a four so that
means that this n in the inner FS has to

1242
00:24:57,029 --> 00:24:57,039
means that this n in the inner FS has to
 

1243
00:24:57,039 --> 00:24:58,990
means that this n in the inner FS has to
be a three

1244
00:24:58,990 --> 00:24:59,000
be a three
 

1245
00:24:59,000 --> 00:25:01,549
be a three
which means that the fs the FZ which

1246
00:25:01,549 --> 00:25:01,559
which means that the fs the FZ which
 

1247
00:25:01,559 --> 00:25:03,350
which means that the fs the FZ which
also produces a su well that n has to be

1248
00:25:03,350 --> 00:25:03,360
also produces a su well that n has to be
 

1249
00:25:03,360 --> 00:25:05,549
also produces a su well that n has to be
a

1250
00:25:05,549 --> 00:25:05,559
a
 

1251
00:25:05,559 --> 00:25:11,269
a
two has to be a two there we go um so um

1252
00:25:11,269 --> 00:25:11,279
two has to be a two there we go um so um
 

1253
00:25:11,279 --> 00:25:13,669
two has to be a two there we go um so um
so here we can see that if we start out

1254
00:25:13,669 --> 00:25:13,679
so here we can see that if we start out
 

1255
00:25:13,679 --> 00:25:17,430
so here we can see that if we start out
with FZ having nb2 well then suck of two

1256
00:25:17,430 --> 00:25:17,440
with FZ having nb2 well then suck of two
 

1257
00:25:17,440 --> 00:25:19,350
with FZ having nb2 well then suck of two
is going to be three and then FS will

1258
00:25:19,350 --> 00:25:19,360
is going to be three and then FS will
 

1259
00:25:19,360 --> 00:25:21,269
is going to be three and then FS will
take something with a three here and it

1260
00:25:21,269 --> 00:25:21,279
take something with a three here and it
 

1261
00:25:21,279 --> 00:25:22,590
take something with a three here and it
will produce a four and then the other

1262
00:25:22,590 --> 00:25:22,600
will produce a four and then the other
 

1263
00:25:22,600 --> 00:25:23,750
will produce a four and then the other
FS takes something with a four and

1264
00:25:23,750 --> 00:25:23,760
FS takes something with a four and
 

1265
00:25:23,760 --> 00:25:26,789
FS takes something with a four and
produces a five everyone's

1266
00:25:26,789 --> 00:25:26,799
produces a five everyone's
 

1267
00:25:26,799 --> 00:25:29,909
produces a five everyone's
happy um so so now we can wonder about

1268
00:25:29,909 --> 00:25:29,919
happy um so so now we can wonder about
 

1269
00:25:29,919 --> 00:25:34,070
happy um so so now we can wonder about
does two have type fin 3 well sure it

1270
00:25:34,070 --> 00:25:34,080
does two have type fin 3 well sure it
 

1271
00:25:34,080 --> 00:25:39,029
does two have type fin 3 well sure it
does here the N for f for FZ can be zero

1272
00:25:39,029 --> 00:25:39,039
does here the N for f for FZ can be zero
 

1273
00:25:39,039 --> 00:25:40,590
does here the N for f for FZ can be zero
and then it gets incremented three times

1274
00:25:40,590 --> 00:25:40,600
and then it gets incremented three times
 

1275
00:25:40,600 --> 00:25:44,669
and then it gets incremented three times
and we get up to three but if we try to

1276
00:25:44,669 --> 00:25:44,679
and we get up to three but if we try to
 

1277
00:25:44,679 --> 00:25:47,830
and we get up to three but if we try to
figure out if two has Type fin two

1278
00:25:47,830 --> 00:25:47,840
figure out if two has Type fin two
 

1279
00:25:47,840 --> 00:25:49,389
figure out if two has Type fin two
there's just no way we can get it to

1280
00:25:49,389 --> 00:25:49,399
there's just no way we can get it to
 

1281
00:25:49,399 --> 00:25:50,990
there's just no way we can get it to
work

1282
00:25:50,990 --> 00:25:51,000
work
 

1283
00:25:51,000 --> 00:25:53,269
work
out right there's nothing that we can

1284
00:25:53,269 --> 00:25:53,279
out right there's nothing that we can
 

1285
00:25:53,279 --> 00:25:54,990
out right there's nothing that we can
put here such that when we increment it

1286
00:25:54,990 --> 00:25:55,000
put here such that when we increment it
 

1287
00:25:55,000 --> 00:25:58,710
put here such that when we increment it
three times ends up with two um so so

1288
00:25:58,710 --> 00:25:58,720
three times ends up with two um so so
 

1289
00:25:58,720 --> 00:26:01,590
three times ends up with two um so so
that's how this type in captures the

1290
00:26:01,590 --> 00:26:01,600
that's how this type in captures the
 

1291
00:26:01,600 --> 00:26:04,389
that's how this type in captures the
idea of this finite set so let me just

1292
00:26:04,389 --> 00:26:04,399
idea of this finite set so let me just
 

1293
00:26:04,399 --> 00:26:06,750
idea of this finite set so let me just
pause here for questions we're not we're

1294
00:26:06,750 --> 00:26:06,760
pause here for questions we're not we're
 

1295
00:26:06,760 --> 00:26:08,110
pause here for questions we're not we're
not going to be building a ton on top of

1296
00:26:08,110 --> 00:26:08,120
not going to be building a ton on top of
 

1297
00:26:08,120 --> 00:26:09,350
not going to be building a ton on top of
fin other than the fact that it's a

1298
00:26:09,350 --> 00:26:09,360
fin other than the fact that it's a
 

1299
00:26:09,360 --> 00:26:10,389
fin other than the fact that it's a
finite

1300
00:26:10,389 --> 00:26:10,399
finite
 

1301
00:26:10,399 --> 00:26:15,029
finite
set but I'm happy to take

1302
00:26:15,029 --> 00:26:15,039

 

1303
00:26:15,039 --> 00:26:16,549

questions

1304
00:26:16,549 --> 00:26:16,559
questions
 

1305
00:26:16,559 --> 00:26:18,230
questions
okay

1306
00:26:18,230 --> 00:26:18,240
okay
 

1307
00:26:18,240 --> 00:26:21,389
okay
um okay so going back to this definition

1308
00:26:21,389 --> 00:26:21,399
um okay so going back to this definition
 

1309
00:26:21,399 --> 00:26:24,830
um okay so going back to this definition
here um so we see because the de brown

1310
00:26:24,830 --> 00:26:24,840
here um so we see because the de brown
 

1311
00:26:24,840 --> 00:26:27,630
here um so we see because the de brown
index is a Fin n then we know that

1312
00:26:27,630 --> 00:26:27,640
index is a Fin n then we know that
 

1313
00:26:27,640 --> 00:26:30,230
index is a Fin n then we know that
everything has to be well scoped I can't

1314
00:26:30,230 --> 00:26:30,240
everything has to be well scoped I can't
 

1315
00:26:30,240 --> 00:26:33,870
everything has to be well scoped I can't
have um the brown index of two in a

1316
00:26:33,870 --> 00:26:33,880
have um the brown index of two in a
 

1317
00:26:33,880 --> 00:26:36,110
have um the brown index of two in a
context where I'm expecting no variables

1318
00:26:36,110 --> 00:26:36,120
context where I'm expecting no variables
 

1319
00:26:36,120 --> 00:26:38,470
context where I'm expecting no variables
at all that will just be ill

1320
00:26:38,470 --> 00:26:38,480
at all that will just be ill
 

1321
00:26:38,480 --> 00:26:41,149
at all that will just be ill
typed um and so once I've produced one

1322
00:26:41,149 --> 00:26:41,159
typed um and so once I've produced one
 

1323
00:26:41,159 --> 00:26:44,029
typed um and so once I've produced one
of these uxs I know that there can be no

1324
00:26:44,029 --> 00:26:44,039
of these uxs I know that there can be no
 

1325
00:26:44,039 --> 00:26:46,430
of these uxs I know that there can be no
out of scope errors it is

1326
00:26:46,430 --> 00:26:46,440
out of scope errors it is
 

1327
00:26:46,440 --> 00:26:48,430
out of scope errors it is
impossible or or I would need to have

1328
00:26:48,430 --> 00:26:48,440
impossible or or I would need to have
 

1329
00:26:48,440 --> 00:26:49,789
impossible or or I would need to have
bottom somewhere but I said we were just

1330
00:26:49,789 --> 00:26:49,799
bottom somewhere but I said we were just
 

1331
00:26:49,799 --> 00:26:51,070
bottom somewhere but I said we were just
going to ignore

1332
00:26:51,070 --> 00:26:51,080
going to ignore
 

1333
00:26:51,080 --> 00:26:53,830
going to ignore
that um okay so now that we know the

1334
00:26:53,830 --> 00:26:53,840
that um okay so now that we know the
 

1335
00:26:53,840 --> 00:26:56,190
that um okay so now that we know the
type that we're parsing into let's just

1336
00:26:56,190 --> 00:26:56,200
type that we're parsing into let's just
 

1337
00:26:56,200 --> 00:26:58,990
type that we're parsing into let's just
return back to the challenge of parsing

1338
00:26:58,990 --> 00:26:59,000
return back to the challenge of parsing
 

1339
00:26:59,000 --> 00:27:02,350
return back to the challenge of parsing
so I said that parex is um is going to

1340
00:27:02,350 --> 00:27:02,360
so I said that parex is um is going to
 

1341
00:27:02,360 --> 00:27:04,830
so I said that parex is um is going to
take a list of of these tokens and

1342
00:27:04,830 --> 00:27:04,840
take a list of of these tokens and
 

1343
00:27:04,840 --> 00:27:07,830
take a list of of these tokens and
produce if there's no errors a ux zero a

1344
00:27:07,830 --> 00:27:07,840
produce if there's no errors a ux zero a
 

1345
00:27:07,840 --> 00:27:10,750
produce if there's no errors a ux zero a
closed expression with no free

1346
00:27:10,750 --> 00:27:10,760
closed expression with no free
 

1347
00:27:10,760 --> 00:27:14,669
closed expression with no free
variables um now parse X is is going to

1348
00:27:14,669 --> 00:27:14,679
variables um now parse X is is going to
 

1349
00:27:14,679 --> 00:27:16,710
variables um now parse X is is going to
be you know some some bunch of

1350
00:27:16,710 --> 00:27:16,720
be you know some some bunch of
 

1351
00:27:16,720 --> 00:27:18,909
be you know some some bunch of
combinators around a I'm using a a

1352
00:27:18,909 --> 00:27:18,919
combinators around a I'm using a a
 

1353
00:27:18,919 --> 00:27:20,909
combinators around a I'm using a a
monatic parser combinator I think it was

1354
00:27:20,909 --> 00:27:20,919
monatic parser combinator I think it was
 

1355
00:27:20,919 --> 00:27:23,870
monatic parser combinator I think it was
parseek um and so I'm going to have this

1356
00:27:23,870 --> 00:27:23,880
parseek um and so I'm going to have this
 

1357
00:27:23,880 --> 00:27:26,549
parseek um and so I'm going to have this
expert somewhere in here and there's run

1358
00:27:26,549 --> 00:27:26,559
expert somewhere in here and there's run
 

1359
00:27:26,559 --> 00:27:29,510
expert somewhere in here and there's run
parsec t or something like that in there

1360
00:27:29,510 --> 00:27:29,520
parsec t or something like that in there
 

1361
00:27:29,520 --> 00:27:31,750
parsec t or something like that in there
um and exper is going to have type

1362
00:27:31,750 --> 00:27:31,760
um and exper is going to have type
 

1363
00:27:31,760 --> 00:27:34,269
um and exper is going to have type
parser

1364
00:27:34,269 --> 00:27:34,279
parser
 

1365
00:27:34,279 --> 00:27:37,470
parser
ux0 um well that's not really going to

1366
00:27:37,470 --> 00:27:37,480
ux0 um well that's not really going to
 

1367
00:27:37,480 --> 00:27:40,269
ux0 um well that's not really going to
work out because I need to be able to

1368
00:27:40,269 --> 00:27:40,279
work out because I need to be able to
 

1369
00:27:40,279 --> 00:27:42,909
work out because I need to be able to
recursively parse sub Expressions that

1370
00:27:42,909 --> 00:27:42,919
recursively parse sub Expressions that
 

1371
00:27:42,919 --> 00:27:45,750
recursively parse sub Expressions that
are not closed so I don't want exper

1372
00:27:45,750 --> 00:27:45,760
are not closed so I don't want exper
 

1373
00:27:45,760 --> 00:27:47,669
are not closed so I don't want exper
just to be able to parse closed

1374
00:27:47,669 --> 00:27:47,679
just to be able to parse closed
 

1375
00:27:47,679 --> 00:27:48,990
just to be able to parse closed
Expressions I need to be able to parse

1376
00:27:48,990 --> 00:27:49,000
Expressions I need to be able to parse
 

1377
00:27:49,000 --> 00:27:52,509
Expressions I need to be able to parse
open ones as well so that's no good um

1378
00:27:52,509 --> 00:27:52,519
open ones as well so that's no good um
 

1379
00:27:52,519 --> 00:27:53,950
open ones as well so that's no good um
so then I might think oh let me just

1380
00:27:53,950 --> 00:27:53,960
so then I might think oh let me just
 

1381
00:27:53,960 --> 00:27:56,029
so then I might think oh let me just
generalize this and I want exper to be a

1382
00:27:56,029 --> 00:27:56,039
generalize this and I want exper to be a
 

1383
00:27:56,039 --> 00:27:58,750
generalize this and I want exper to be a
parser that can that can parse um uh an

1384
00:27:58,750 --> 00:27:58,760
parser that can that can parse um uh an
 

1385
00:27:58,760 --> 00:28:01,909
parser that can that can parse um uh an
expression with any number of variables

1386
00:28:01,909 --> 00:28:01,919
expression with any number of variables
 

1387
00:28:01,919 --> 00:28:04,909
expression with any number of variables
n the problem is that's not really good

1388
00:28:04,909 --> 00:28:04,919
n the problem is that's not really good
 

1389
00:28:04,919 --> 00:28:06,310
n the problem is that's not really good
either I'm never going to be able to

1390
00:28:06,310 --> 00:28:06,320
either I'm never going to be able to
 

1391
00:28:06,320 --> 00:28:08,389
either I'm never going to be able to
implement that kind of expert because I

1392
00:28:08,389 --> 00:28:08,399
implement that kind of expert because I
 

1393
00:28:08,399 --> 00:28:12,230
implement that kind of expert because I
don't know how many variables um uh are

1394
00:28:12,230 --> 00:28:12,240
don't know how many variables um uh are
 

1395
00:28:12,240 --> 00:28:14,750
don't know how many variables um uh are
in that output right this is it's a it's

1396
00:28:14,750 --> 00:28:14,760
in that output right this is it's a it's
 

1397
00:28:14,760 --> 00:28:16,830
in that output right this is it's a it's
um if if you just try to implement it

1398
00:28:16,830 --> 00:28:16,840
um if if you just try to implement it
 

1399
00:28:16,840 --> 00:28:19,870
um if if you just try to implement it
you you won't be able to um uh we sort

1400
00:28:19,870 --> 00:28:19,880
you you won't be able to um uh we sort
 

1401
00:28:19,880 --> 00:28:21,029
you you won't be able to um uh we sort
of don't have enough information to be

1402
00:28:21,029 --> 00:28:21,039
of don't have enough information to be
 

1403
00:28:21,039 --> 00:28:24,789
of don't have enough information to be
able to do it instead what we need to do

1404
00:28:24,789 --> 00:28:24,799
able to do it instead what we need to do
 

1405
00:28:24,799 --> 00:28:27,029
able to do it instead what we need to do
is now instead of just having parser not

1406
00:28:27,029 --> 00:28:27,039
is now instead of just having parser not
 

1407
00:28:27,039 --> 00:28:28,430
is now instead of just having parser not
only do we need to have a par that

1408
00:28:28,430 --> 00:28:28,440
only do we need to have a par that
 

1409
00:28:28,440 --> 00:28:30,990
only do we need to have a par that
produces a an output but we need to have

1410
00:28:30,990 --> 00:28:31,000
produces a an output but we need to have
 

1411
00:28:31,000 --> 00:28:33,909
produces a an output but we need to have
our parser monad needs to be indexed

1412
00:28:33,909 --> 00:28:33,919
our parser monad needs to be indexed
 

1413
00:28:33,919 --> 00:28:36,750
our parser monad needs to be indexed
with the number of variables that are in

1414
00:28:36,750 --> 00:28:36,760
with the number of variables that are in
 

1415
00:28:36,760 --> 00:28:39,430
with the number of variables that are in
scope okay so what do I mean by

1416
00:28:39,430 --> 00:28:39,440
scope okay so what do I mean by
 

1417
00:28:39,440 --> 00:28:43,190
scope okay so what do I mean by
that um so uh so I think we'll

1418
00:28:43,190 --> 00:28:43,200
that um so uh so I think we'll
 

1419
00:28:43,200 --> 00:28:44,350
that um so uh so I think we'll
understand this better by looking at

1420
00:28:44,350 --> 00:28:44,360
understand this better by looking at
 

1421
00:28:44,360 --> 00:28:46,389
understand this better by looking at
what what is this parser thing

1422
00:28:46,389 --> 00:28:46,399
what what is this parser thing
 

1423
00:28:46,399 --> 00:28:48,669
what what is this parser thing
anyway so um it's going to be a type

1424
00:28:48,669 --> 00:28:48,679
anyway so um it's going to be a type
 

1425
00:28:48,679 --> 00:28:51,909
anyway so um it's going to be a type
synonym so a parser na this is

1426
00:28:51,909 --> 00:28:51,919
synonym so a parser na this is
 

1427
00:28:51,919 --> 00:28:54,149
synonym so a parser na this is
describing a parser that produces

1428
00:28:54,149 --> 00:28:54,159
describing a parser that produces
 

1429
00:28:54,159 --> 00:28:57,350
describing a parser that produces
something of type A and N vars are in

1430
00:28:57,350 --> 00:28:57,360
something of type A and N vars are in
 

1431
00:28:57,360 --> 00:28:59,310
something of type A and N vars are in
scope

1432
00:28:59,310 --> 00:28:59,320
scope
 

1433
00:28:59,320 --> 00:29:02,110
scope
and here's its definition um so this is

1434
00:29:02,110 --> 00:29:02,120
and here's its definition um so this is
 

1435
00:29:02,120 --> 00:29:05,630
and here's its definition um so this is
based on on Park T so that's the parseek

1436
00:29:05,630 --> 00:29:05,640
based on on Park T so that's the parseek
 

1437
00:29:05,640 --> 00:29:09,990
based on on Park T so that's the parseek
monad Transformer uh it has four indices

1438
00:29:09,990 --> 00:29:10,000
monad Transformer uh it has four indices
 

1439
00:29:10,000 --> 00:29:12,590
monad Transformer uh it has four indices
so the first is the type of the input

1440
00:29:12,590 --> 00:29:12,600
so the first is the type of the input
 

1441
00:29:12,600 --> 00:29:13,870
so the first is the type of the input
that one's fairly straightforward that's

1442
00:29:13,870 --> 00:29:13,880
that one's fairly straightforward that's
 

1443
00:29:13,880 --> 00:29:17,549
that one's fairly straightforward that's
just our list of located tokens um Parc

1444
00:29:17,549 --> 00:29:17,559
just our list of located tokens um Parc
 

1445
00:29:17,559 --> 00:29:19,350
just our list of located tokens um Parc
allows us to carry around a state turns

1446
00:29:19,350 --> 00:29:19,360
allows us to carry around a state turns
 

1447
00:29:19,360 --> 00:29:20,870
allows us to carry around a state turns
that we don't need that to do our

1448
00:29:20,870 --> 00:29:20,880
that we don't need that to do our
 

1449
00:29:20,880 --> 00:29:23,310
that we don't need that to do our
parsing so we just give it a trivial

1450
00:29:23,310 --> 00:29:23,320
parsing so we just give it a trivial
 

1451
00:29:23,320 --> 00:29:28,590
parsing so we just give it a trivial
State um and then a par T wraps around

1452
00:29:28,590 --> 00:29:28,600
State um and then a par T wraps around
 

1453
00:29:28,600 --> 00:29:31,029
State um and then a par T wraps around
another monad so the other monad that

1454
00:29:31,029 --> 00:29:31,039
another monad so the other monad that
 

1455
00:29:31,039 --> 00:29:33,430
another monad so the other monad that
I'm wrapping around is a reader

1456
00:29:33,430 --> 00:29:33,440
I'm wrapping around is a reader
 

1457
00:29:33,440 --> 00:29:37,909
I'm wrapping around is a reader
monad that stores a VEC of n

1458
00:29:37,909 --> 00:29:37,919
monad that stores a VEC of n
 

1459
00:29:37,919 --> 00:29:40,269
monad that stores a VEC of n
strings so those of you who haven't met

1460
00:29:40,269 --> 00:29:40,279
strings so those of you who haven't met
 

1461
00:29:40,279 --> 00:29:42,350
strings so those of you who haven't met
it before ve is another type that

1462
00:29:42,350 --> 00:29:42,360
it before ve is another type that
 

1463
00:29:42,360 --> 00:29:43,630
it before ve is another type that
appears in every single one of these

1464
00:29:43,630 --> 00:29:43,640
appears in every single one of these
 

1465
00:29:43,640 --> 00:29:47,110
appears in every single one of these
kinds of talks um that it's just like a

1466
00:29:47,110 --> 00:29:47,120
kinds of talks um that it's just like a
 

1467
00:29:47,120 --> 00:29:49,430
kinds of talks um that it's just like a
list except the length of the list

1468
00:29:49,430 --> 00:29:49,440
list except the length of the list
 

1469
00:29:49,440 --> 00:29:51,909
list except the length of the list
appears in the type so it's not just any

1470
00:29:51,909 --> 00:29:51,919
appears in the type so it's not just any
 

1471
00:29:51,919 --> 00:29:53,190
appears in the type so it's not just any
list of strings but it's a list

1472
00:29:53,190 --> 00:29:53,200
list of strings but it's a list
 

1473
00:29:53,200 --> 00:29:55,789
list of strings but it's a list
specifically of n strings right these of

1474
00:29:55,789 --> 00:29:55,799
specifically of n strings right these of
 

1475
00:29:55,799 --> 00:29:58,470
specifically of n strings right these of
course are

1476
00:29:58,470 --> 00:29:58,480
course are
 

1477
00:29:58,480 --> 00:30:01,990
course are
the variables that are in scope so when

1478
00:30:01,990 --> 00:30:02,000
the variables that are in scope so when
 

1479
00:30:02,000 --> 00:30:04,190
the variables that are in scope so when
I after I've said back slf and then a

1480
00:30:04,190 --> 00:30:04,200
I after I've said back slf and then a
 

1481
00:30:04,200 --> 00:30:06,509
I after I've said back slf and then a
little later back SLX to bring F and X

1482
00:30:06,509 --> 00:30:06,519
little later back SLX to bring F and X
 

1483
00:30:06,519 --> 00:30:08,750
little later back SLX to bring F and X
into scope my Vector is going to contain

1484
00:30:08,750 --> 00:30:08,760
into scope my Vector is going to contain
 

1485
00:30:08,760 --> 00:30:12,269
into scope my Vector is going to contain
F and x and it allows me when I uh when

1486
00:30:12,269 --> 00:30:12,279
F and x and it allows me when I uh when
 

1487
00:30:12,279 --> 00:30:14,830
F and x and it allows me when I uh when
I parse a variable usage it allows me to

1488
00:30:14,830 --> 00:30:14,840
I parse a variable usage it allows me to
 

1489
00:30:14,840 --> 00:30:17,789
I parse a variable usage it allows me to
look up which index should should be um

1490
00:30:17,789 --> 00:30:17,799
look up which index should should be um
 

1491
00:30:17,799 --> 00:30:20,750
look up which index should should be um
assigned to that variable um but the key

1492
00:30:20,750 --> 00:30:20,760
assigned to that variable um but the key
 

1493
00:30:20,760 --> 00:30:22,830
assigned to that variable um but the key
thing here is is that the length of the

1494
00:30:22,830 --> 00:30:22,840
thing here is is that the length of the
 

1495
00:30:22,840 --> 00:30:24,710
thing here is is that the length of the
vector must match the number of

1496
00:30:24,710 --> 00:30:24,720
vector must match the number of
 

1497
00:30:24,720 --> 00:30:26,669
vector must match the number of
variables that I know I have in scope so

1498
00:30:26,669 --> 00:30:26,679
variables that I know I have in scope so
 

1499
00:30:26,679 --> 00:30:28,750
variables that I know I have in scope so
here's the N that comes in from the the

1500
00:30:28,750 --> 00:30:28,760
here's the N that comes in from the the
 

1501
00:30:28,760 --> 00:30:30,789
here's the N that comes in from the the
index dep

1502
00:30:30,789 --> 00:30:30,799
index dep
 

1503
00:30:30,799 --> 00:30:33,990
index dep
pars um

1504
00:30:33,990 --> 00:30:34,000
pars um
 

1505
00:30:34,000 --> 00:30:35,509
pars um
okay

1506
00:30:35,509 --> 00:30:35,519
okay
 

1507
00:30:35,519 --> 00:30:38,630
okay
okay U so here's a quick introduction to

1508
00:30:38,630 --> 00:30:38,640
okay U so here's a quick introduction to
 

1509
00:30:38,640 --> 00:30:40,590
okay U so here's a quick introduction to
to vectors uh for those of you actually

1510
00:30:40,590 --> 00:30:40,600
to vectors uh for those of you actually
 

1511
00:30:40,600 --> 00:30:42,950
to vectors uh for those of you actually
how many people have seen this

1512
00:30:42,950 --> 00:30:42,960
how many people have seen this
 

1513
00:30:42,960 --> 00:30:46,430
how many people have seen this
before okay most but not all um so this

1514
00:30:46,430 --> 00:30:46,440
before okay most but not all um so this
 

1515
00:30:46,440 --> 00:30:49,669
before okay most but not all um so this
is another one of these gads right so if

1516
00:30:49,669 --> 00:30:49,679
is another one of these gads right so if
 

1517
00:30:49,679 --> 00:30:52,269
is another one of these gads right so if
I have an empty uh Vector that's length

1518
00:30:52,269 --> 00:30:52,279
I have an empty uh Vector that's length
 

1519
00:30:52,279 --> 00:30:54,590
I have an empty uh Vector that's length
is zero that that vector's length is

1520
00:30:54,590 --> 00:30:54,600
is zero that that vector's length is
 

1521
00:30:54,600 --> 00:30:56,950
is zero that that vector's length is
zero otherwise I have some other Vector

1522
00:30:56,950 --> 00:30:56,960
zero otherwise I have some other Vector
 

1523
00:30:56,960 --> 00:30:58,950
zero otherwise I have some other Vector
of length n and then the result has one

1524
00:30:58,950 --> 00:30:58,960
of length n and then the result has one
 

1525
00:30:58,960 --> 00:31:02,830
of length n and then the result has one
more element in it but otherwise um

1526
00:31:02,830 --> 00:31:02,840
more element in it but otherwise um
 

1527
00:31:02,840 --> 00:31:04,350
more element in it but otherwise um
right if if I sort of you know in

1528
00:31:04,350 --> 00:31:04,360
right if if I sort of you know in
 

1529
00:31:04,360 --> 00:31:06,509
right if if I sort of you know in
different syntax and such this does look

1530
00:31:06,509 --> 00:31:06,519
different syntax and such this does look
 

1531
00:31:06,519 --> 00:31:08,480
different syntax and such this does look
quite like um the list

1532
00:31:08,480 --> 00:31:08,490
quite like um the list
 

1533
00:31:08,490 --> 00:31:09,710
quite like um the list
[Music]

1534
00:31:09,710 --> 00:31:09,720
[Music]
 

1535
00:31:09,720 --> 00:31:12,870
[Music]
type uh okay

1536
00:31:12,870 --> 00:31:12,880
type uh okay
 

1537
00:31:12,880 --> 00:31:15,149
type uh okay
so where are we going from here we're

1538
00:31:15,149 --> 00:31:15,159
so where are we going from here we're
 

1539
00:31:15,159 --> 00:31:19,549
so where are we going from here we're
going to this slide um so here's here's

1540
00:31:19,549 --> 00:31:19,559
going to this slide um so here's here's
 

1541
00:31:19,559 --> 00:31:22,110
going to this slide um so here's here's
our definition of parser with our Varn

1542
00:31:22,110 --> 00:31:22,120
our definition of parser with our Varn
 

1543
00:31:22,120 --> 00:31:25,190
our definition of parser with our Varn
and and and our

1544
00:31:25,190 --> 00:31:25,200

 

1545
00:31:25,200 --> 00:31:29,470

vac okay um okay so so let's just let's

1546
00:31:29,470 --> 00:31:29,480
vac okay um okay so so let's just let's
 

1547
00:31:29,480 --> 00:31:31,669
vac okay um okay so so let's just let's
just recap so if that if you got lost

1548
00:31:31,669 --> 00:31:31,679
just recap so if that if you got lost
 

1549
00:31:31,679 --> 00:31:34,230
just recap so if that if you got lost
there if it's afternoon let this is this

1550
00:31:34,230 --> 00:31:34,240
there if it's afternoon let this is this
 

1551
00:31:34,240 --> 00:31:35,950
there if it's afternoon let this is this
is sort of the one of my my summary

1552
00:31:35,950 --> 00:31:35,960
is sort of the one of my my summary
 

1553
00:31:35,960 --> 00:31:38,750
is sort of the one of my my summary
slides um okay so what we've just seen

1554
00:31:38,750 --> 00:31:38,760
slides um okay so what we've just seen
 

1555
00:31:38,760 --> 00:31:41,470
slides um okay so what we've just seen
is that I wanted to have well scoped

1556
00:31:41,470 --> 00:31:41,480
is that I wanted to have well scoped
 

1557
00:31:41,480 --> 00:31:45,149
is that I wanted to have well scoped
Expressions my ux type I wanted to know

1558
00:31:45,149 --> 00:31:45,159
Expressions my ux type I wanted to know
 

1559
00:31:45,159 --> 00:31:47,310
Expressions my ux type I wanted to know
that as soon as I have a ux that it was

1560
00:31:47,310 --> 00:31:47,320
that as soon as I have a ux that it was
 

1561
00:31:47,320 --> 00:31:49,190
that as soon as I have a ux that it was
always well scoped there could be no out

1562
00:31:49,190 --> 00:31:49,200
always well scoped there could be no out
 

1563
00:31:49,200 --> 00:31:51,430
always well scoped there could be no out
of scope variables in other words no de

1564
00:31:51,430 --> 00:31:51,440
of scope variables in other words no de
 

1565
00:31:51,440 --> 00:31:54,430
of scope variables in other words no de
brown indices that are too high and so I

1566
00:31:54,430 --> 00:31:54,440
brown indices that are too high and so I
 

1567
00:31:54,440 --> 00:31:59,230
brown indices that are too high and so I
did that by um oh by by index ing my my

1568
00:31:59,230 --> 00:31:59,240
did that by um oh by by index ing my my
 

1569
00:31:59,240 --> 00:32:01,750
did that by um oh by by index ing my my
my ux but then we needed to index the

1570
00:32:01,750 --> 00:32:01,760
my ux but then we needed to index the
 

1571
00:32:01,760 --> 00:32:04,070
my ux but then we needed to index the
parser monad so that I could parse into

1572
00:32:04,070 --> 00:32:04,080
parser monad so that I could parse into
 

1573
00:32:04,080 --> 00:32:06,190
parser monad so that I could parse into
these expressions and I had to use a

1574
00:32:06,190 --> 00:32:06,200
these expressions and I had to use a
 

1575
00:32:06,200 --> 00:32:08,789
these expressions and I had to use a
length index vector and that was built

1576
00:32:08,789 --> 00:32:08,799
length index vector and that was built
 

1577
00:32:08,799 --> 00:32:11,430
length index vector and that was built
on top of my fin and and all this other

1578
00:32:11,430 --> 00:32:11,440
on top of my fin and and all this other
 

1579
00:32:11,440 --> 00:32:14,509
on top of my fin and and all this other
stuff right so my first idea was just oh

1580
00:32:14,509 --> 00:32:14,519
stuff right so my first idea was just oh
 

1581
00:32:14,519 --> 00:32:15,669
stuff right so my first idea was just oh
I just want to make sure that there's

1582
00:32:15,669 --> 00:32:15,679
I just want to make sure that there's
 

1583
00:32:15,679 --> 00:32:18,310
I just want to make sure that there's
nothing out of scope around here but

1584
00:32:18,310 --> 00:32:18,320
nothing out of scope around here but
 

1585
00:32:18,320 --> 00:32:20,149
nothing out of scope around here but
then in order to do that I needed to do

1586
00:32:20,149 --> 00:32:20,159
then in order to do that I needed to do
 

1587
00:32:20,159 --> 00:32:22,909
then in order to do that I needed to do
all of these other things too so one of

1588
00:32:22,909 --> 00:32:22,919
all of these other things too so one of
 

1589
00:32:22,919 --> 00:32:23,710
all of these other things too so one of
the

1590
00:32:23,710 --> 00:32:23,720
the
 

1591
00:32:23,720 --> 00:32:27,389
the
takeaways types are social creatures

1592
00:32:27,389 --> 00:32:27,399
takeaways types are social creatures
 

1593
00:32:27,399 --> 00:32:29,629
takeaways types are social creatures
right and as soon as we start with some

1594
00:32:29,629 --> 00:32:29,639
right and as soon as we start with some
 

1595
00:32:29,639 --> 00:32:32,909
right and as soon as we start with some
types we want more of them I don't know

1596
00:32:32,909 --> 00:32:32,919
types we want more of them I don't know
 

1597
00:32:32,919 --> 00:32:35,710
types we want more of them I don't know
if anyone here has tried doing fancy

1598
00:32:35,710 --> 00:32:35,720
if anyone here has tried doing fancy
 

1599
00:32:35,720 --> 00:32:38,350
if anyone here has tried doing fancy
type stuff in Java so before before I

1600
00:32:38,350 --> 00:32:38,360
type stuff in Java so before before I
 

1601
00:32:38,360 --> 00:32:40,470
type stuff in Java so before before I
met hascal um I was actually a high

1602
00:32:40,470 --> 00:32:40,480
met hascal um I was actually a high
 

1603
00:32:40,480 --> 00:32:42,230
met hascal um I was actually a high
school teacher for a while and so in in

1604
00:32:42,230 --> 00:32:42,240
school teacher for a while and so in in
 

1605
00:32:42,240 --> 00:32:44,070
school teacher for a while and so in in
the American High School curriculum Java

1606
00:32:44,070 --> 00:32:44,080
the American High School curriculum Java
 

1607
00:32:44,080 --> 00:32:46,310
the American High School curriculum Java
is sort of the language of choice and um

1608
00:32:46,310 --> 00:32:46,320
is sort of the language of choice and um
 

1609
00:32:46,320 --> 00:32:47,990
is sort of the language of choice and um
I was always trying to sneak more types

1610
00:32:47,990 --> 00:32:48,000
I was always trying to sneak more types
 

1611
00:32:48,000 --> 00:32:51,230
I was always trying to sneak more types
in uh because because I like types um

1612
00:32:51,230 --> 00:32:51,240
in uh because because I like types um
 

1613
00:32:51,240 --> 00:32:53,149
in uh because because I like types um
and and if you've ever done fancy type

1614
00:32:53,149 --> 00:32:53,159
and and if you've ever done fancy type
 

1615
00:32:53,159 --> 00:32:55,190
and and if you've ever done fancy type
things in in in languages that don't

1616
00:32:55,190 --> 00:32:55,200
things in in in languages that don't
 

1617
00:32:55,200 --> 00:32:57,549
things in in in languages that don't
have a rich type system like hascal you

1618
00:32:57,549 --> 00:32:57,559
have a rich type system like hascal you
 

1619
00:32:57,559 --> 00:32:59,710
have a rich type system like hascal you
end end up hitting the these walls

1620
00:32:59,710 --> 00:32:59,720
end end up hitting the these walls
 

1621
00:32:59,720 --> 00:33:01,269
end end up hitting the these walls
things that you want to be able to say

1622
00:33:01,269 --> 00:33:01,279
things that you want to be able to say
 

1623
00:33:01,279 --> 00:33:03,870
things that you want to be able to say
but you can't um and this always makes

1624
00:33:03,870 --> 00:33:03,880
but you can't um and this always makes
 

1625
00:33:03,880 --> 00:33:05,990
but you can't um and this always makes
us want to have more and more sort of

1626
00:33:05,990 --> 00:33:06,000
us want to have more and more sort of
 

1627
00:33:06,000 --> 00:33:09,509
us want to have more and more sort of
power in our type system um so here's

1628
00:33:09,509 --> 00:33:09,519
power in our type system um so here's
 

1629
00:33:09,519 --> 00:33:10,750
power in our type system um so here's
something to think about sometimes these

1630
00:33:10,750 --> 00:33:10,760
something to think about sometimes these
 

1631
00:33:10,760 --> 00:33:12,310
something to think about sometimes these
talks can go on for a long time if you

1632
00:33:12,310 --> 00:33:12,320
talks can go on for a long time if you
 

1633
00:33:12,320 --> 00:33:13,590
talks can go on for a long time if you
define yourself getting bored I have a

1634
00:33:13,590 --> 00:33:13,600
define yourself getting bored I have a
 

1635
00:33:13,600 --> 00:33:15,830
define yourself getting bored I have a
task for you so uh those of you who

1636
00:33:15,830 --> 00:33:15,840
task for you so uh those of you who
 

1637
00:33:15,840 --> 00:33:17,590
task for you so uh those of you who
aren't native English speakers maybe

1638
00:33:17,590 --> 00:33:17,600
aren't native English speakers maybe
 

1639
00:33:17,600 --> 00:33:19,590
aren't native English speakers maybe
don't know that English has a great deal

1640
00:33:19,590 --> 00:33:19,600
don't know that English has a great deal
 

1641
00:33:19,600 --> 00:33:22,389
don't know that English has a great deal
of fun coming up with fun collective

1642
00:33:22,389 --> 00:33:22,399
of fun coming up with fun collective
 

1643
00:33:22,399 --> 00:33:25,990
of fun coming up with fun collective
nouns um so uh so for example we we

1644
00:33:25,990 --> 00:33:26,000
nouns um so uh so for example we we
 

1645
00:33:26,000 --> 00:33:27,830
nouns um so uh so for example we we
might have a herd of geese herd isn't

1646
00:33:27,830 --> 00:33:27,840
might have a herd of geese herd isn't
 

1647
00:33:27,840 --> 00:33:29,909
might have a herd of geese herd isn't
all that exciting but we also have a

1648
00:33:29,909 --> 00:33:29,919
all that exciting but we also have a
 

1649
00:33:29,919 --> 00:33:33,789
all that exciting but we also have a
murder of crows and a shrewdness of apes

1650
00:33:33,789 --> 00:33:33,799
murder of crows and a shrewdness of apes
 

1651
00:33:33,799 --> 00:33:35,029
murder of crows and a shrewdness of apes
and the reason we do this is just

1652
00:33:35,029 --> 00:33:35,039
and the reason we do this is just
 

1653
00:33:35,039 --> 00:33:36,549
and the reason we do this is just
because it's fun so I propose here that

1654
00:33:36,549 --> 00:33:36,559
because it's fun so I propose here that
 

1655
00:33:36,559 --> 00:33:38,789
because it's fun so I propose here that
we might have a closure of haskers but I

1656
00:33:38,789 --> 00:33:38,799
we might have a closure of haskers but I
 

1657
00:33:38,799 --> 00:33:40,149
we might have a closure of haskers but I
I'm unable to come up with a good one

1658
00:33:40,149 --> 00:33:40,159
I'm unable to come up with a good one
 

1659
00:33:40,159 --> 00:33:42,830
I'm unable to come up with a good one
for for Collective uh noun for types so

1660
00:33:42,830 --> 00:33:42,840
for for Collective uh noun for types so
 

1661
00:33:42,840 --> 00:33:43,990
for for Collective uh noun for types so
if you want to just sort of ponder that

1662
00:33:43,990 --> 00:33:44,000
if you want to just sort of ponder that
 

1663
00:33:44,000 --> 00:33:45,909
if you want to just sort of ponder that
while you're daydreaming go ahead maybe

1664
00:33:45,909 --> 00:33:45,919
while you're daydreaming go ahead maybe
 

1665
00:33:45,919 --> 00:33:49,070
while you're daydreaming go ahead maybe
a paradox a paradox of types but they're

1666
00:33:49,070 --> 00:33:49,080
a paradox a paradox of types but they're
 

1667
00:33:49,080 --> 00:33:54,750
a paradox a paradox of types but they're
no no no they're not a par correct a COR

1668
00:33:54,750 --> 00:33:54,760
no no no they're not a par correct a COR
 

1669
00:33:54,760 --> 00:33:56,470
no no no they're not a par correct a COR
yes I thought about that a correctness

1670
00:33:56,470 --> 00:33:56,480
yes I thought about that a correctness
 

1671
00:33:56,480 --> 00:33:59,990
yes I thought about that a correctness
of types or a sness of types I guess

1672
00:33:59,990 --> 00:34:00,000
of types or a sness of types I guess
 

1673
00:34:00,000 --> 00:34:03,629
of types or a sness of types I guess
univ ah a universe of types that that uh

1674
00:34:03,629 --> 00:34:03,639
univ ah a universe of types that that uh
 

1675
00:34:03,639 --> 00:34:05,149
univ ah a universe of types that that uh
somehow sounds too mathematical that's

1676
00:34:05,149 --> 00:34:05,159
somehow sounds too mathematical that's
 

1677
00:34:05,159 --> 00:34:09,430
somehow sounds too mathematical that's
not fun enough um okay so um so we have

1678
00:34:09,430 --> 00:34:09,440
not fun enough um okay so um so we have
 

1679
00:34:09,440 --> 00:34:10,869
not fun enough um okay so um so we have
types of social creatures so let's talk

1680
00:34:10,869 --> 00:34:10,879
types of social creatures so let's talk
 

1681
00:34:10,879 --> 00:34:12,069
types of social creatures so let's talk
more about

1682
00:34:12,069 --> 00:34:12,079
more about
 

1683
00:34:12,079 --> 00:34:15,589
more about
them um so uh how do we then type check

1684
00:34:15,589 --> 00:34:15,599
them um so uh how do we then type check
 

1685
00:34:15,599 --> 00:34:16,829
them um so uh how do we then type check
our language so I didn't show any

1686
00:34:16,829 --> 00:34:16,839
our language so I didn't show any
 

1687
00:34:16,839 --> 00:34:18,270
our language so I didn't show any
examples but of course this is all type

1688
00:34:18,270 --> 00:34:18,280
examples but of course this is all type
 

1689
00:34:18,280 --> 00:34:19,710
examples but of course this is all type
checked if I had written a type

1690
00:34:19,710 --> 00:34:19,720
checked if I had written a type
 

1691
00:34:19,720 --> 00:34:21,750
checked if I had written a type
incorrect expression uh we would have

1692
00:34:21,750 --> 00:34:21,760
incorrect expression uh we would have
 

1693
00:34:21,760 --> 00:34:23,990
incorrect expression uh we would have
gotten errors so the first step is I

1694
00:34:23,990 --> 00:34:24,000
gotten errors so the first step is I
 

1695
00:34:24,000 --> 00:34:26,750
gotten errors so the first step is I
need to know what my types are um so

1696
00:34:26,750 --> 00:34:26,760
need to know what my types are um so
 

1697
00:34:26,760 --> 00:34:28,829
need to know what my types are um so
here's my data type to to describe types

1698
00:34:28,829 --> 00:34:28,839
here's my data type to to describe types
 

1699
00:34:28,839 --> 00:34:31,030
here's my data type to to describe types
very simple we have ins we have booleans

1700
00:34:31,030 --> 00:34:31,040
very simple we have ins we have booleans
 

1701
00:34:31,040 --> 00:34:32,510
very simple we have ins we have booleans
and we have

1702
00:34:32,510 --> 00:34:32,520
and we have
 

1703
00:34:32,520 --> 00:34:34,869
and we have
functions um I didn't show any booleans

1704
00:34:34,869 --> 00:34:34,879
functions um I didn't show any booleans
 

1705
00:34:34,879 --> 00:34:36,190
functions um I didn't show any booleans
but there's if and there's booleans and

1706
00:34:36,190 --> 00:34:36,200
but there's if and there's booleans and
 

1707
00:34:36,200 --> 00:34:38,790
but there's if and there's booleans and
there's comparisons all that's fun stuff

1708
00:34:38,790 --> 00:34:38,800
there's comparisons all that's fun stuff
 

1709
00:34:38,800 --> 00:34:41,790
there's comparisons all that's fun stuff
um okay so the way that that I'm doing

1710
00:34:41,790 --> 00:34:41,800
um okay so the way that that I'm doing
 

1711
00:34:41,800 --> 00:34:45,109
um okay so the way that that I'm doing
this after type checking is I have what

1712
00:34:45,109 --> 00:34:45,119
this after type checking is I have what
 

1713
00:34:45,119 --> 00:34:47,629
this after type checking is I have what
I'm calling a type index abstract syntax

1714
00:34:47,629 --> 00:34:47,639
I'm calling a type index abstract syntax
 

1715
00:34:47,639 --> 00:34:51,030
I'm calling a type index abstract syntax
tree um so just like my unchecked

1716
00:34:51,030 --> 00:34:51,040
tree um so just like my unchecked
 

1717
00:34:51,040 --> 00:34:54,349
tree um so just like my unchecked
Expressions were always scope correct my

1718
00:34:54,349 --> 00:34:54,359
Expressions were always scope correct my
 

1719
00:34:54,359 --> 00:34:56,389
Expressions were always scope correct my
type checked Expressions will always be

1720
00:34:56,389 --> 00:34:56,399
type checked Expressions will always be
 

1721
00:34:56,399 --> 00:34:59,190
type checked Expressions will always be
type correct I do not want to permit the

1722
00:34:59,190 --> 00:34:59,200
type correct I do not want to permit the
 

1723
00:34:59,200 --> 00:35:02,470
type correct I do not want to permit the
possibility of having um say you know

1724
00:35:02,470 --> 00:35:02,480
possibility of having um say you know
 

1725
00:35:02,480 --> 00:35:05,030
possibility of having um say you know
true plus one right I don't want to be

1726
00:35:05,030 --> 00:35:05,040
true plus one right I don't want to be
 

1727
00:35:05,040 --> 00:35:07,270
true plus one right I don't want to be
able to express that in my language

1728
00:35:07,270 --> 00:35:07,280
able to express that in my language
 

1729
00:35:07,280 --> 00:35:08,990
able to express that in my language
because if I can express that then maybe

1730
00:35:08,990 --> 00:35:09,000
because if I can express that then maybe
 

1731
00:35:09,000 --> 00:35:10,750
because if I can express that then maybe
there's some transformation that I have

1732
00:35:10,750 --> 00:35:10,760
there's some transformation that I have
 

1733
00:35:10,760 --> 00:35:12,430
there's some transformation that I have
in my in my interpreter that then

1734
00:35:12,430 --> 00:35:12,440
in my in my interpreter that then
 

1735
00:35:12,440 --> 00:35:14,750
in my in my interpreter that then
violates type safety whereas if I know

1736
00:35:14,750 --> 00:35:14,760
violates type safety whereas if I know
 

1737
00:35:14,760 --> 00:35:16,510
violates type safety whereas if I know
every expression is type correct then I

1738
00:35:16,510 --> 00:35:16,520
every expression is type correct then I
 

1739
00:35:16,520 --> 00:35:18,910
every expression is type correct then I
can't violate type safety so so here's

1740
00:35:18,910 --> 00:35:18,920
can't violate type safety so so here's
 

1741
00:35:18,920 --> 00:35:22,069
can't violate type safety so so here's
how it's going to look like so first um

1742
00:35:22,069 --> 00:35:22,079
how it's going to look like so first um
 

1743
00:35:22,079 --> 00:35:24,589
how it's going to look like so first um
I'm going to need to know what the types

1744
00:35:24,589 --> 00:35:24,599
I'm going to need to know what the types
 

1745
00:35:24,599 --> 00:35:26,430
I'm going to need to know what the types
are of all of my variables that are in

1746
00:35:26,430 --> 00:35:26,440
are of all of my variables that are in
 

1747
00:35:26,440 --> 00:35:30,349
are of all of my variables that are in
scope so that's a typing context or CTX

1748
00:35:30,349 --> 00:35:30,359
scope so that's a typing context or CTX
 

1749
00:35:30,359 --> 00:35:31,510
scope so that's a typing context or CTX
and I'm just using that as a type

1750
00:35:31,510 --> 00:35:31,520
and I'm just using that as a type
 

1751
00:35:31,520 --> 00:35:35,470
and I'm just using that as a type
synonym for a vector uh of n types right

1752
00:35:35,470 --> 00:35:35,480
synonym for a vector uh of n types right
 

1753
00:35:35,480 --> 00:35:37,710
synonym for a vector uh of n types right
I'm going to have n variables in scope

1754
00:35:37,710 --> 00:35:37,720
I'm going to have n variables in scope
 

1755
00:35:37,720 --> 00:35:39,430
I'm going to have n variables in scope
each one is going to have a type so

1756
00:35:39,430 --> 00:35:39,440
each one is going to have a type so
 

1757
00:35:39,440 --> 00:35:40,670
each one is going to have a type so
everything has to work with respect to

1758
00:35:40,670 --> 00:35:40,680
everything has to work with respect to
 

1759
00:35:40,680 --> 00:35:42,230
everything has to work with respect to
this context so this might just list

1760
00:35:42,230 --> 00:35:42,240
this context so this might just list
 

1761
00:35:42,240 --> 00:35:44,390
this context so this might just list
sort of int and bu an INT arrow in for

1762
00:35:44,390 --> 00:35:44,400
sort of int and bu an INT arrow in for
 

1763
00:35:44,400 --> 00:35:47,150
sort of int and bu an INT arrow in for
the three variables I have in

1764
00:35:47,150 --> 00:35:47,160
the three variables I have in
 

1765
00:35:47,160 --> 00:35:51,589
the three variables I have in
scope um so here's my my expression Type

1766
00:35:51,589 --> 00:35:51,599
scope um so here's my my expression Type
 

1767
00:35:51,599 --> 00:35:55,349
scope um so here's my my expression Type
X so my expression type it uh it works

1768
00:35:55,349 --> 00:35:55,359
X so my expression type it uh it works
 

1769
00:35:55,359 --> 00:35:57,349
X so my expression type it uh it works
for any n right I can have any number of

1770
00:35:57,349 --> 00:35:57,359
for any n right I can have any number of
 

1771
00:35:57,359 --> 00:36:00,349
for any n right I can have any number of
variable in scope and it is going to be

1772
00:36:00,349 --> 00:36:00,359
variable in scope and it is going to be
 

1773
00:36:00,359 --> 00:36:02,950
variable in scope and it is going to be
indexed by a context a typ in context so

1774
00:36:02,950 --> 00:36:02,960
indexed by a context a typ in context so
 

1775
00:36:02,960 --> 00:36:05,190
indexed by a context a typ in context so
I need to know again all of the types of

1776
00:36:05,190 --> 00:36:05,200
I need to know again all of the types of
 

1777
00:36:05,200 --> 00:36:08,270
I need to know again all of the types of
my of my encope variables and every

1778
00:36:08,270 --> 00:36:08,280
my of my encope variables and every
 

1779
00:36:08,280 --> 00:36:11,910
my of my encope variables and every
expression itself has a type and then of

1780
00:36:11,910 --> 00:36:11,920
expression itself has a type and then of
 

1781
00:36:11,920 --> 00:36:14,470
expression itself has a type and then of
course an expression itself is a type so

1782
00:36:14,470 --> 00:36:14,480
course an expression itself is a type so
 

1783
00:36:14,480 --> 00:36:16,309
course an expression itself is a type so
this is perhaps a little confusing Tai

1784
00:36:16,309 --> 00:36:16,319
this is perhaps a little confusing Tai
 

1785
00:36:16,319 --> 00:36:19,790
this is perhaps a little confusing Tai
here is referring to this in orb stuff

1786
00:36:19,790 --> 00:36:19,800
here is referring to this in orb stuff
 

1787
00:36:19,800 --> 00:36:23,510
here is referring to this in orb stuff
whereas type is a hasal type sort of

1788
00:36:23,510 --> 00:36:23,520
whereas type is a hasal type sort of
 

1789
00:36:23,520 --> 00:36:26,150
whereas type is a hasal type sort of
some levels crossing a little bit here

1790
00:36:26,150 --> 00:36:26,160
some levels crossing a little bit here
 

1791
00:36:26,160 --> 00:36:28,150
some levels crossing a little bit here
um okay so here's a way understand this

1792
00:36:28,150 --> 00:36:28,160
um okay so here's a way understand this
 

1793
00:36:28,160 --> 00:36:32,109
um okay so here's a way understand this
an X CTX tii is an expression of type

1794
00:36:32,109 --> 00:36:32,119
an X CTX tii is an expression of type
 

1795
00:36:32,119 --> 00:36:35,349
an X CTX tii is an expression of type
tii in a context

1796
00:36:35,349 --> 00:36:35,359
tii in a context
 

1797
00:36:35,359 --> 00:36:37,870
tii in a context
CTX um for those of you who have seen

1798
00:36:37,870 --> 00:36:37,880
CTX um for those of you who have seen
 

1799
00:36:37,880 --> 00:36:40,069
CTX um for those of you who have seen
this kind of notation right we can say

1800
00:36:40,069 --> 00:36:40,079
this kind of notation right we can say
 

1801
00:36:40,079 --> 00:36:45,230
this kind of notation right we can say
that if if e has the Type X CTX tii then

1802
00:36:45,230 --> 00:36:45,240
that if if e has the Type X CTX tii then
 

1803
00:36:45,240 --> 00:36:48,150
that if if e has the Type X CTX tii then
we have this typing judgment right this

1804
00:36:48,150 --> 00:36:48,160
we have this typing judgment right this
 

1805
00:36:48,160 --> 00:36:50,349
we have this typing judgment right this
is this is exactly what it means if

1806
00:36:50,349 --> 00:36:50,359
is this is exactly what it means if
 

1807
00:36:50,359 --> 00:36:52,109
is this is exactly what it means if
you're familiar with that notation if

1808
00:36:52,109 --> 00:36:52,119
you're familiar with that notation if
 

1809
00:36:52,119 --> 00:36:53,589
you're familiar with that notation if
you're not I'm not using that notation

1810
00:36:53,589 --> 00:36:53,599
you're not I'm not using that notation
 

1811
00:36:53,599 --> 00:36:54,950
you're not I'm not using that notation
again this in this

1812
00:36:54,950 --> 00:36:54,960
again this in this
 

1813
00:36:54,960 --> 00:36:58,470
again this in this
talk um Okay so again every expression

1814
00:36:58,470 --> 00:36:58,480
talk um Okay so again every expression
 

1815
00:36:58,480 --> 00:37:00,230
talk um Okay so again every expression
is well typed in this system so let's

1816
00:37:00,230 --> 00:37:00,240
is well typed in this system so let's
 

1817
00:37:00,240 --> 00:37:02,270
is well typed in this system so let's
see how we're going to build that up so

1818
00:37:02,270 --> 00:37:02,280
see how we're going to build that up so
 

1819
00:37:02,280 --> 00:37:05,309
see how we're going to build that up so
we have variables so here a variable is

1820
00:37:05,309 --> 00:37:05,319
we have variables so here a variable is
 

1821
00:37:05,319 --> 00:37:09,270
we have variables so here a variable is
going to take this Lum so LM is another

1822
00:37:09,270 --> 00:37:09,280
going to take this Lum so LM is another
 

1823
00:37:09,280 --> 00:37:12,230
going to take this Lum so LM is another
way of expressing a de brown

1824
00:37:12,230 --> 00:37:12,240
way of expressing a de brown
 

1825
00:37:12,240 --> 00:37:15,069
way of expressing a de brown
index um so what's what's LM it's

1826
00:37:15,069 --> 00:37:15,079
index um so what's what's LM it's
 

1827
00:37:15,079 --> 00:37:17,390
index um so what's what's LM it's
essentially we could think of LM as a

1828
00:37:17,390 --> 00:37:17,400
essentially we could think of LM as a
 

1829
00:37:17,400 --> 00:37:19,950
essentially we could think of LM as a
proof that a certain element is in a

1830
00:37:19,950 --> 00:37:19,960
proof that a certain element is in a
 

1831
00:37:19,960 --> 00:37:23,510
proof that a certain element is in a
list or in a vector in this case um so

1832
00:37:23,510 --> 00:37:23,520
list or in a vector in this case um so
 

1833
00:37:23,520 --> 00:37:24,990
list or in a vector in this case um so
what we really want to say is is that

1834
00:37:24,990 --> 00:37:25,000
what we really want to say is is that
 

1835
00:37:25,000 --> 00:37:28,109
what we really want to say is is that
every variable here has to have the type

1836
00:37:28,109 --> 00:37:28,119
every variable here has to have the type
 

1837
00:37:28,119 --> 00:37:30,589
every variable here has to have the type
of some element in our in our context

1838
00:37:30,589 --> 00:37:30,599
of some element in our in our context
 

1839
00:37:30,599 --> 00:37:32,510
of some element in our in our context
right I describ this context as this

1840
00:37:32,510 --> 00:37:32,520
right I describ this context as this
 

1841
00:37:32,520 --> 00:37:35,190
right I describ this context as this
Vector of the types of the ins scope

1842
00:37:35,190 --> 00:37:35,200
Vector of the types of the ins scope
 

1843
00:37:35,200 --> 00:37:37,790
Vector of the types of the ins scope
variables um and so I want to pluck one

1844
00:37:37,790 --> 00:37:37,800
variables um and so I want to pluck one
 

1845
00:37:37,800 --> 00:37:40,150
variables um and so I want to pluck one
out and say that this variable is that

1846
00:37:40,150 --> 00:37:40,160
out and say that this variable is that
 

1847
00:37:40,160 --> 00:37:42,910
out and say that this variable is that
particular type so that's what this Elm

1848
00:37:42,910 --> 00:37:42,920
particular type so that's what this Elm
 

1849
00:37:42,920 --> 00:37:44,309
particular type so that's what this Elm
type

1850
00:37:44,309 --> 00:37:44,319
type
 

1851
00:37:44,319 --> 00:37:46,510
type
does um so there's two different

1852
00:37:46,510 --> 00:37:46,520
does um so there's two different
 

1853
00:37:46,520 --> 00:37:48,790
does um so there's two different
possibilities for LM this one what we

1854
00:37:48,790 --> 00:37:48,800
possibilities for LM this one what we
 

1855
00:37:48,800 --> 00:37:52,990
possibilities for LM this one what we
can call here right it's saying that X

1856
00:37:52,990 --> 00:37:53,000
can call here right it's saying that X
 

1857
00:37:53,000 --> 00:37:56,829
can call here right it's saying that X
is in the Type X con X's right we see

1858
00:37:56,829 --> 00:37:56,839
is in the Type X con X's right we see
 

1859
00:37:56,839 --> 00:37:59,510
is in the Type X con X's right we see
here's X there and there's X there so X

1860
00:37:59,510 --> 00:37:59,520
here's X there and there's X there so X
 

1861
00:37:59,520 --> 00:38:02,069
here's X there and there's X there so X
is in the Type X cons X's it's right

1862
00:38:02,069 --> 00:38:02,079
is in the Type X cons X's it's right
 

1863
00:38:02,079 --> 00:38:03,950
is in the Type X cons X's it's right
here it's the first element it's at

1864
00:38:03,950 --> 00:38:03,960
here it's the first element it's at
 

1865
00:38:03,960 --> 00:38:05,910
here it's the first element it's at
index

1866
00:38:05,910 --> 00:38:05,920
index
 

1867
00:38:05,920 --> 00:38:08,670
index
zero so this is my representation for

1868
00:38:08,670 --> 00:38:08,680
zero so this is my representation for
 

1869
00:38:08,680 --> 00:38:10,589
zero so this is my representation for
the de brown index zero saying it's the

1870
00:38:10,589 --> 00:38:10,599
the de brown index zero saying it's the
 

1871
00:38:10,599 --> 00:38:12,630
the de brown index zero saying it's the
first thing in my

1872
00:38:12,630 --> 00:38:12,640
first thing in my
 

1873
00:38:12,640 --> 00:38:15,790
first thing in my
context or we have another Constructor

1874
00:38:15,790 --> 00:38:15,800
context or we have another Constructor
 

1875
00:38:15,800 --> 00:38:18,109
context or we have another Constructor
which we can call there right an element

1876
00:38:18,109 --> 00:38:18,119
which we can call there right an element
 

1877
00:38:18,119 --> 00:38:20,670
which we can call there right an element
is either here or it's there which says

1878
00:38:20,670 --> 00:38:20,680
is either here or it's there which says
 

1879
00:38:20,680 --> 00:38:24,990
is either here or it's there which says
that if x is in X's somewhere then

1880
00:38:24,990 --> 00:38:25,000
that if x is in X's somewhere then
 

1881
00:38:25,000 --> 00:38:28,470
that if x is in X's somewhere then
surely X is in y cons X right we can add

1882
00:38:28,470 --> 00:38:28,480
surely X is in y cons X right we can add
 

1883
00:38:28,480 --> 00:38:30,470
surely X is in y cons X right we can add
another element to our context and we

1884
00:38:30,470 --> 00:38:30,480
another element to our context and we
 

1885
00:38:30,480 --> 00:38:32,630
another element to our context and we
can still find that X in

1886
00:38:32,630 --> 00:38:32,640
can still find that X in
 

1887
00:38:32,640 --> 00:38:35,470
can still find that X in
there um but what that's saying is that

1888
00:38:35,470 --> 00:38:35,480
there um but what that's saying is that
 

1889
00:38:35,480 --> 00:38:38,030
there um but what that's saying is that
that's actually means look one step

1890
00:38:38,030 --> 00:38:38,040
that's actually means look one step
 

1891
00:38:38,040 --> 00:38:40,550
that's actually means look one step
further or thinking of it as as a

1892
00:38:40,550 --> 00:38:40,560
further or thinking of it as as a
 

1893
00:38:40,560 --> 00:38:44,309
further or thinking of it as as a
debrown index that's plus one right so

1894
00:38:44,309 --> 00:38:44,319
debrown index that's plus one right so
 

1895
00:38:44,319 --> 00:38:45,790
debrown index that's plus one right so
this is this is another sort of

1896
00:38:45,790 --> 00:38:45,800
this is this is another sort of
 

1897
00:38:45,800 --> 00:38:48,710
this is this is another sort of
representation of these unary Naturals

1898
00:38:48,710 --> 00:38:48,720
representation of these unary Naturals
 

1899
00:38:48,720 --> 00:38:52,030
representation of these unary Naturals
um but it has all this fancy type

1900
00:38:52,030 --> 00:38:52,040
um but it has all this fancy type
 

1901
00:38:52,040 --> 00:38:54,069
um but it has all this fancy type
stuff if this is going over your head a

1902
00:38:54,069 --> 00:38:54,079
stuff if this is going over your head a
 

1903
00:38:54,079 --> 00:38:55,230
stuff if this is going over your head a
little bit that's okay we're not

1904
00:38:55,230 --> 00:38:55,240
little bit that's okay we're not
 

1905
00:38:55,240 --> 00:38:57,790
little bit that's okay we're not
building on top of LM here we just just

1906
00:38:57,790 --> 00:38:57,800
building on top of LM here we just just
 

1907
00:38:57,800 --> 00:38:59,069
building on top of LM here we just just
need to know that it's sort of a

1908
00:38:59,069 --> 00:38:59,079
need to know that it's sort of a
 

1909
00:38:59,079 --> 00:39:03,190
need to know that it's sort of a
representation for debrown

1910
00:39:03,190 --> 00:39:03,200

 

1911
00:39:03,200 --> 00:39:06,950

indices um so here we have lamb so this

1912
00:39:06,950 --> 00:39:06,960
indices um so here we have lamb so this
 

1913
00:39:06,960 --> 00:39:09,230
indices um so here we have lamb so this
is our representation for for

1914
00:39:09,230 --> 00:39:09,240
is our representation for for
 

1915
00:39:09,240 --> 00:39:10,870
is our representation for for
lambdas

1916
00:39:10,870 --> 00:39:10,880
lambdas
 

1917
00:39:10,880 --> 00:39:14,109
lambdas
um uh so it needs to know the type of

1918
00:39:14,109 --> 00:39:14,119
um uh so it needs to know the type of
 

1919
00:39:14,119 --> 00:39:15,470
um uh so it needs to know the type of
the

1920
00:39:15,470 --> 00:39:15,480
the
 

1921
00:39:15,480 --> 00:39:18,230
the
argument then we have an expression now

1922
00:39:18,230 --> 00:39:18,240
argument then we have an expression now
 

1923
00:39:18,240 --> 00:39:21,589
argument then we have an expression now
this expression in here um is in an

1924
00:39:21,589 --> 00:39:21,599
this expression in here um is in an
 

1925
00:39:21,599 --> 00:39:25,349
this expression in here um is in an
expanded context right so the expression

1926
00:39:25,349 --> 00:39:25,359
expanded context right so the expression
 

1927
00:39:25,359 --> 00:39:27,990
expanded context right so the expression
inside of the Lambda it has one more

1928
00:39:27,990 --> 00:39:28,000
inside of the Lambda it has one more
 

1929
00:39:28,000 --> 00:39:30,390
inside of the Lambda it has one more
type it has one more variable in scope

1930
00:39:30,390 --> 00:39:30,400
type it has one more variable in scope
 

1931
00:39:30,400 --> 00:39:33,630
type it has one more variable in scope
the type of that variable will be ARG so

1932
00:39:33,630 --> 00:39:33,640
the type of that variable will be ARG so
 

1933
00:39:33,640 --> 00:39:35,829
the type of that variable will be ARG so
we add ARG to the

1934
00:39:35,829 --> 00:39:35,839
we add ARG to the
 

1935
00:39:35,839 --> 00:39:40,230
we add ARG to the
context and then the result of of this

1936
00:39:40,230 --> 00:39:40,240
context and then the result of of this
 

1937
00:39:40,240 --> 00:39:41,990
context and then the result of of this
Lambda the type of the overall Lambda is

1938
00:39:41,990 --> 00:39:42,000
Lambda the type of the overall Lambda is
 

1939
00:39:42,000 --> 00:39:44,069
Lambda the type of the overall Lambda is
going to be a function that takes ARG

1940
00:39:44,069 --> 00:39:44,079
going to be a function that takes ARG
 

1941
00:39:44,079 --> 00:39:46,150
going to be a function that takes ARG
and produces res where res was the type

1942
00:39:46,150 --> 00:39:46,160
and produces res where res was the type
 

1943
00:39:46,160 --> 00:39:48,950
and produces res where res was the type
of the inner

1944
00:39:48,950 --> 00:39:48,960

 

1945
00:39:48,960 --> 00:39:52,950

expression um okay so this thing here

1946
00:39:52,950 --> 00:39:52,960
expression um okay so this thing here
 

1947
00:39:52,960 --> 00:39:53,870
expression um okay so this thing here
this is a

1948
00:39:53,870 --> 00:39:53,880
this is a
 

1949
00:39:53,880 --> 00:39:56,750
this is a
Singleton so what a Singleton is is it's

1950
00:39:56,750 --> 00:39:56,760
Singleton so what a Singleton is is it's
 

1951
00:39:56,760 --> 00:39:59,390
Singleton so what a Singleton is is it's
a piece of data that's available both at

1952
00:39:59,390 --> 00:39:59,400
a piece of data that's available both at
 

1953
00:39:59,400 --> 00:40:01,630
a piece of data that's available both at
compile time and

1954
00:40:01,630 --> 00:40:01,640
compile time and
 

1955
00:40:01,640 --> 00:40:05,349
compile time and
runtime so in this case we need this

1956
00:40:05,349 --> 00:40:05,359
runtime so in this case we need this
 

1957
00:40:05,359 --> 00:40:08,670
runtime so in this case we need this
this type at compile time because that's

1958
00:40:08,670 --> 00:40:08,680
this type at compile time because that's
 

1959
00:40:08,680 --> 00:40:11,390
this type at compile time because that's
the type of the bound variable in my

1960
00:40:11,390 --> 00:40:11,400
the type of the bound variable in my
 

1961
00:40:11,400 --> 00:40:13,470
the type of the bound variable in my
inner expression and we needed it

1962
00:40:13,470 --> 00:40:13,480
inner expression and we needed it
 

1963
00:40:13,480 --> 00:40:15,829
inner expression and we needed it
runtime so that we can print the thing

1964
00:40:15,829 --> 00:40:15,839
runtime so that we can print the thing
 

1965
00:40:15,839 --> 00:40:17,829
runtime so that we can print the thing
um it turns out that we only need it for

1966
00:40:17,829 --> 00:40:17,839
um it turns out that we only need it for
 

1967
00:40:17,839 --> 00:40:19,270
um it turns out that we only need it for
printing which I found quite interesting

1968
00:40:19,270 --> 00:40:19,280
printing which I found quite interesting
 

1969
00:40:19,280 --> 00:40:21,550
printing which I found quite interesting
when I first implemented this um that we

1970
00:40:21,550 --> 00:40:21,560
when I first implemented this um that we
 

1971
00:40:21,560 --> 00:40:23,109
when I first implemented this um that we
can do all the evaluation everything

1972
00:40:23,109 --> 00:40:23,119
can do all the evaluation everything
 

1973
00:40:23,119 --> 00:40:24,990
can do all the evaluation everything
else without that because this language

1974
00:40:24,990 --> 00:40:25,000
else without that because this language
 

1975
00:40:25,000 --> 00:40:27,630
else without that because this language
supports type erer um there's no typ

1976
00:40:27,630 --> 00:40:27,640
supports type erer um there's no typ
 

1977
00:40:27,640 --> 00:40:30,829
supports type erer um there's no typ
directed operations at runtime um but uh

1978
00:40:30,829 --> 00:40:30,839
directed operations at runtime um but uh
 

1979
00:40:30,839 --> 00:40:32,030
directed operations at runtime um but uh
but we still do want to be able to print

1980
00:40:32,030 --> 00:40:32,040
but we still do want to be able to print
 

1981
00:40:32,040 --> 00:40:33,390
but we still do want to be able to print
it so so it's a

1982
00:40:33,390 --> 00:40:33,400
it so so it's a
 

1983
00:40:33,400 --> 00:40:35,670
it so so it's a
single um okay so what do I mean by that

1984
00:40:35,670 --> 00:40:35,680
single um okay so what do I mean by that
 

1985
00:40:35,680 --> 00:40:36,910
single um okay so what do I mean by that
let's let's look at the definition of

1986
00:40:36,910 --> 00:40:36,920
let's let's look at the definition of
 

1987
00:40:36,920 --> 00:40:40,270
let's let's look at the definition of
this s ti so the idea is that if our

1988
00:40:40,270 --> 00:40:40,280
this s ti so the idea is that if our
 

1989
00:40:40,280 --> 00:40:43,069
this s ti so the idea is that if our
types are either ins or bulls or arrows

1990
00:40:43,069 --> 00:40:43,079
types are either ins or bulls or arrows
 

1991
00:40:43,079 --> 00:40:45,069
types are either ins or bulls or arrows
we need Singletons for each of these so

1992
00:40:45,069 --> 00:40:45,079
we need Singletons for each of these so
 

1993
00:40:45,079 --> 00:40:47,710
we need Singletons for each of these so
we have Sint which relates to TT and we

1994
00:40:47,710 --> 00:40:47,720
we have Sint which relates to TT and we
 

1995
00:40:47,720 --> 00:40:49,710
we have Sint which relates to TT and we
have SB which relates to TB and we have

1996
00:40:49,710 --> 00:40:49,720
have SB which relates to TB and we have
 

1997
00:40:49,720 --> 00:40:51,630
have SB which relates to TB and we have
this double colon arrow thing which

1998
00:40:51,630 --> 00:40:51,640
this double colon arrow thing which
 

1999
00:40:51,640 --> 00:40:54,589
this double colon arrow thing which
relates to the single colon arrow thing

2000
00:40:54,589 --> 00:40:54,599
relates to the single colon arrow thing
 

2001
00:40:54,599 --> 00:40:57,790
relates to the single colon arrow thing
um the idea here is that

2002
00:40:57,790 --> 00:40:57,800
um the idea here is that
 

2003
00:40:57,800 --> 00:41:02,750
um the idea here is that
once I know a term then I know the type

2004
00:41:02,750 --> 00:41:02,760
once I know a term then I know the type
 

2005
00:41:02,760 --> 00:41:05,470
once I know a term then I know the type
right after I pattern match and I get S

2006
00:41:05,470 --> 00:41:05,480
right after I pattern match and I get S
 

2007
00:41:05,480 --> 00:41:08,190
right after I pattern match and I get S
in then I know that the type has to be T

2008
00:41:08,190 --> 00:41:08,200
in then I know that the type has to be T
 

2009
00:41:08,200 --> 00:41:10,470
in then I know that the type has to be T
int after I pattern match on SB I know

2010
00:41:10,470 --> 00:41:10,480
int after I pattern match on SB I know
 

2011
00:41:10,480 --> 00:41:12,589
int after I pattern match on SB I know
that the type has to be TB and so it

2012
00:41:12,589 --> 00:41:12,599
that the type has to be TB and so it
 

2013
00:41:12,599 --> 00:41:14,829
that the type has to be TB and so it
allows this information to sort of flow

2014
00:41:14,829 --> 00:41:14,839
allows this information to sort of flow
 

2015
00:41:14,839 --> 00:41:17,030
allows this information to sort of flow
back and forth between run time and

2016
00:41:17,030 --> 00:41:17,040
back and forth between run time and
 

2017
00:41:17,040 --> 00:41:20,870
back and forth between run time and
compile

2018
00:41:20,870 --> 00:41:20,880

 

2019
00:41:20,880 --> 00:41:24,829

time um for applications this one's more

2020
00:41:24,829 --> 00:41:24,839
time um for applications this one's more
 

2021
00:41:24,839 --> 00:41:26,510
time um for applications this one's more
interesting than it was for unchecked

2022
00:41:26,510 --> 00:41:26,520
interesting than it was for unchecked
 

2023
00:41:26,520 --> 00:41:28,150
interesting than it was for unchecked
expressions

2024
00:41:28,150 --> 00:41:28,160
expressions
 

2025
00:41:28,160 --> 00:41:31,109
expressions
right so here I have the function

2026
00:41:31,109 --> 00:41:31,119
right so here I have the function
 

2027
00:41:31,119 --> 00:41:32,790
right so here I have the function
expression which has a function type

2028
00:41:32,790 --> 00:41:32,800
expression which has a function type
 

2029
00:41:32,800 --> 00:41:34,510
expression which has a function type
from ARG to

2030
00:41:34,510 --> 00:41:34,520
from ARG to
 

2031
00:41:34,520 --> 00:41:37,230
from ARG to
Res I have another expression of type

2032
00:41:37,230 --> 00:41:37,240
Res I have another expression of type
 

2033
00:41:37,240 --> 00:41:38,750
Res I have another expression of type
ARG and that's going to produce an

2034
00:41:38,750 --> 00:41:38,760
ARG and that's going to produce an
 

2035
00:41:38,760 --> 00:41:40,190
ARG and that's going to produce an
expression of type

2036
00:41:40,190 --> 00:41:40,200
expression of type
 

2037
00:41:40,200 --> 00:41:42,829
expression of type
res right sort of all the pieces connect

2038
00:41:42,829 --> 00:41:42,839
res right sort of all the pieces connect
 

2039
00:41:42,839 --> 00:41:46,349
res right sort of all the pieces connect
now if I have an ill typed uh function

2040
00:41:46,349 --> 00:41:46,359
now if I have an ill typed uh function
 

2041
00:41:46,359 --> 00:41:48,309
now if I have an ill typed uh function
application this is going to be no good

2042
00:41:48,309 --> 00:41:48,319
application this is going to be no good
 

2043
00:41:48,319 --> 00:41:50,390
application this is going to be no good
if I have a function that expects an INT

2044
00:41:50,390 --> 00:41:50,400
if I have a function that expects an INT
 

2045
00:41:50,400 --> 00:41:53,390
if I have a function that expects an INT
but I pass it a then this these two args

2046
00:41:53,390 --> 00:41:53,400
but I pass it a then this these two args
 

2047
00:41:53,400 --> 00:41:55,030
but I pass it a then this these two args
aren't going to agree and I'm not going

2048
00:41:55,030 --> 00:41:55,040
aren't going to agree and I'm not going
 

2049
00:41:55,040 --> 00:41:58,990
aren't going to agree and I'm not going
to be able to build my my app

2050
00:41:58,990 --> 00:41:59,000
to be able to build my my app
 

2051
00:41:59,000 --> 00:42:00,910
to be able to build my my app
um okay this is I think the last we're

2052
00:42:00,910 --> 00:42:00,920
um okay this is I think the last we're
 

2053
00:42:00,920 --> 00:42:03,150
um okay this is I think the last we're
going to see of this exp type before we

2054
00:42:03,150 --> 00:42:03,160
going to see of this exp type before we
 

2055
00:42:03,160 --> 00:42:04,790
going to see of this exp type before we
go on to how this how we actually type

2056
00:42:04,790 --> 00:42:04,800
go on to how this how we actually type
 

2057
00:42:04,800 --> 00:42:06,109
go on to how this how we actually type
check this thing are there questions

2058
00:42:06,109 --> 00:42:06,119
check this thing are there questions
 

2059
00:42:06,119 --> 00:42:12,790
check this thing are there questions
here before we we go

2060
00:42:12,790 --> 00:42:12,800

 

2061
00:42:12,800 --> 00:42:15,470

on it's probably worth saying at this

2062
00:42:15,470 --> 00:42:15,480
on it's probably worth saying at this
 

2063
00:42:15,480 --> 00:42:17,630
on it's probably worth saying at this
point I am not expecting everyone to

2064
00:42:17,630 --> 00:42:17,640
point I am not expecting everyone to
 

2065
00:42:17,640 --> 00:42:19,750
point I am not expecting everyone to
leave this room knowing how to do all of

2066
00:42:19,750 --> 00:42:19,760
leave this room knowing how to do all of
 

2067
00:42:19,760 --> 00:42:22,790
leave this room knowing how to do all of
this my goal here is to is to sort of

2068
00:42:22,790 --> 00:42:22,800
this my goal here is to is to sort of
 

2069
00:42:22,800 --> 00:42:25,390
this my goal here is to is to sort of
show that this stuff is possible that it

2070
00:42:25,390 --> 00:42:25,400
show that this stuff is possible that it
 

2071
00:42:25,400 --> 00:42:27,470
show that this stuff is possible that it
works that it it's it's actually Fair

2072
00:42:27,470 --> 00:42:27,480
works that it it's it's actually Fair
 

2073
00:42:27,480 --> 00:42:30,270
works that it it's it's actually Fair
clean um and and you know and then

2074
00:42:30,270 --> 00:42:30,280
clean um and and you know and then
 

2075
00:42:30,280 --> 00:42:31,710
clean um and and you know and then
there's pointers I will make sure that

2076
00:42:31,710 --> 00:42:31,720
there's pointers I will make sure that
 

2077
00:42:31,720 --> 00:42:34,109
there's pointers I will make sure that
that code becomes available um so that

2078
00:42:34,109 --> 00:42:34,119
that code becomes available um so that
 

2079
00:42:34,119 --> 00:42:36,309
that code becomes available um so that
you can access it access it later but

2080
00:42:36,309 --> 00:42:36,319
you can access it access it later but
 

2081
00:42:36,319 --> 00:42:38,190
you can access it access it later but
but this is supposed to be sort of an

2082
00:42:38,190 --> 00:42:38,200
but this is supposed to be sort of an
 

2083
00:42:38,200 --> 00:42:39,790
but this is supposed to be sort of an
overview I'm not expecting the full

2084
00:42:39,790 --> 00:42:39,800
overview I'm not expecting the full
 

2085
00:42:39,800 --> 00:42:41,150
overview I'm not expecting the full
details to get absorbed I don't think

2086
00:42:41,150 --> 00:42:41,160
details to get absorbed I don't think
 

2087
00:42:41,160 --> 00:42:45,309
details to get absorbed I don't think
that would be fair um okay so one

2088
00:42:45,309 --> 00:42:45,319
that would be fair um okay so one
 

2089
00:42:45,319 --> 00:42:48,790
that would be fair um okay so one
interesting thing about this is that of

2090
00:42:48,790 --> 00:42:48,800
interesting thing about this is that of
 

2091
00:42:48,800 --> 00:42:51,390
interesting thing about this is that of
course this we can even produce this

2092
00:42:51,390 --> 00:42:51,400
course this we can even produce this
 

2093
00:42:51,400 --> 00:42:55,349
course this we can even produce this
this this data type um so uh sometimes

2094
00:42:55,349 --> 00:42:55,359
this this data type um so uh sometimes
 

2095
00:42:55,359 --> 00:42:59,030
this this data type um so uh sometimes
you know this example of how having a um

2096
00:42:59,030 --> 00:42:59,040
you know this example of how having a um
 

2097
00:42:59,040 --> 00:43:01,390
you know this example of how having a um
an indexed abstract expression or

2098
00:43:01,390 --> 00:43:01,400
an indexed abstract expression or
 

2099
00:43:01,400 --> 00:43:03,190
an indexed abstract expression or
abstract syntax tree this has been

2100
00:43:03,190 --> 00:43:03,200
abstract syntax tree this has been
 

2101
00:43:03,200 --> 00:43:06,790
abstract syntax tree this has been
around for a long time uh but one common

2102
00:43:06,790 --> 00:43:06,800
around for a long time uh but one common
 

2103
00:43:06,800 --> 00:43:08,349
around for a long time uh but one common
criticism of this is oh but you could

2104
00:43:08,349 --> 00:43:08,359
criticism of this is oh but you could
 

2105
00:43:08,359 --> 00:43:10,030
criticism of this is oh but you could
never actually use that in a real

2106
00:43:10,030 --> 00:43:10,040
never actually use that in a real
 

2107
00:43:10,040 --> 00:43:11,750
never actually use that in a real
compiler because how do you know that

2108
00:43:11,750 --> 00:43:11,760
compiler because how do you know that
 

2109
00:43:11,760 --> 00:43:14,630
compiler because how do you know that
everything is correct by construction um

2110
00:43:14,630 --> 00:43:14,640
everything is correct by construction um
 

2111
00:43:14,640 --> 00:43:16,109
everything is correct by construction um
and so one of the interesting things

2112
00:43:16,109 --> 00:43:16,119
and so one of the interesting things
 

2113
00:43:16,119 --> 00:43:17,790
and so one of the interesting things
here is yes you can use it in a real

2114
00:43:17,790 --> 00:43:17,800
here is yes you can use it in a real
 

2115
00:43:17,800 --> 00:43:20,309
here is yes you can use it in a real
interpreter right so remember this was

2116
00:43:20,309 --> 00:43:20,319
interpreter right so remember this was
 

2117
00:43:20,319 --> 00:43:21,549
interpreter right so remember this was
this is a real interpreter I can just

2118
00:43:21,549 --> 00:43:21,559
this is a real interpreter I can just
 

2119
00:43:21,559 --> 00:43:22,790
this is a real interpreter I can just
sort of type into it it's a normal

2120
00:43:22,790 --> 00:43:22,800
sort of type into it it's a normal
 

2121
00:43:22,800 --> 00:43:24,510
sort of type into it it's a normal
application that does all the parsing

2122
00:43:24,510 --> 00:43:24,520
application that does all the parsing
 

2123
00:43:24,520 --> 00:43:26,630
application that does all the parsing
and the type checking stuff um and the

2124
00:43:26,630 --> 00:43:26,640
and the type checking stuff um and the
 

2125
00:43:26,640 --> 00:43:28,109
and the type checking stuff um and the
reason it can can do that is no we don't

2126
00:43:28,109 --> 00:43:28,119
reason it can can do that is no we don't
 

2127
00:43:28,119 --> 00:43:29,630
reason it can can do that is no we don't
know that it's correct by construction

2128
00:43:29,630 --> 00:43:29,640
know that it's correct by construction
 

2129
00:43:29,640 --> 00:43:31,549
know that it's correct by construction
but we have a type Checker that checks

2130
00:43:31,549 --> 00:43:31,559
but we have a type Checker that checks
 

2131
00:43:31,559 --> 00:43:33,710
but we have a type Checker that checks
that it's correct and then as it checks

2132
00:43:33,710 --> 00:43:33,720
that it's correct and then as it checks
 

2133
00:43:33,720 --> 00:43:36,270
that it's correct and then as it checks
it produces the uh the

2134
00:43:36,270 --> 00:43:36,280
it produces the uh the
 

2135
00:43:36,280 --> 00:43:39,990
it produces the uh the
output um so uh we might imagine what

2136
00:43:39,990 --> 00:43:40,000
output um so uh we might imagine what
 

2137
00:43:40,000 --> 00:43:42,230
output um so uh we might imagine what
that that checking function is so here

2138
00:43:42,230 --> 00:43:42,240
that that checking function is so here
 

2139
00:43:42,240 --> 00:43:44,030
that that checking function is so here
I'm just going to leave the monad

2140
00:43:44,030 --> 00:43:44,040
I'm just going to leave the monad
 

2141
00:43:44,040 --> 00:43:46,030
I'm just going to leave the monad
abstract we can imagine a monad that has

2142
00:43:46,030 --> 00:43:46,040
abstract we can imagine a monad that has
 

2143
00:43:46,040 --> 00:43:49,349
abstract we can imagine a monad that has
error reporting and um and I think the

2144
00:43:49,349 --> 00:43:49,359
error reporting and um and I think the
 

2145
00:43:49,359 --> 00:43:52,109
error reporting and um and I think the
ability to produce unique uh identifiers

2146
00:43:52,109 --> 00:43:52,119
ability to produce unique uh identifiers
 

2147
00:43:52,119 --> 00:43:53,670
ability to produce unique uh identifiers
and things like that or no I guess it

2148
00:43:53,670 --> 00:43:53,680
and things like that or no I guess it
 

2149
00:43:53,680 --> 00:43:55,270
and things like that or no I guess it
wouldn't need that um I forget exactly

2150
00:43:55,270 --> 00:43:55,280
wouldn't need that um I forget exactly
 

2151
00:43:55,280 --> 00:43:56,790
wouldn't need that um I forget exactly
what the Monet has in it but it's it's

2152
00:43:56,790 --> 00:43:56,800
what the Monet has in it but it's it's
 

2153
00:43:56,800 --> 00:44:00,190
what the Monet has in it but it's it's
it's it's not very interesting um so so

2154
00:44:00,190 --> 00:44:00,200
it's it's not very interesting um so so
 

2155
00:44:00,200 --> 00:44:01,990
it's it's not very interesting um so so
we can imagine a check function that

2156
00:44:01,990 --> 00:44:02,000
we can imagine a check function that
 

2157
00:44:02,000 --> 00:44:05,430
we can imagine a check function that
takes one of these uxs and produces an

2158
00:44:05,430 --> 00:44:05,440
takes one of these uxs and produces an
 

2159
00:44:05,440 --> 00:44:09,270
takes one of these uxs and produces an
X um the problem is is that once again

2160
00:44:09,270 --> 00:44:09,280
X um the problem is is that once again
 

2161
00:44:09,280 --> 00:44:11,750
X um the problem is is that once again
we can't really just have this CTX and

2162
00:44:11,750 --> 00:44:11,760
we can't really just have this CTX and
 

2163
00:44:11,760 --> 00:44:14,069
we can't really just have this CTX and
this tie appear in the output because

2164
00:44:14,069 --> 00:44:14,079
this tie appear in the output because
 

2165
00:44:14,079 --> 00:44:18,309
this tie appear in the output because
maybe my input is an INT maybe it's a bu

2166
00:44:18,309 --> 00:44:18,319
maybe my input is an INT maybe it's a bu
 

2167
00:44:18,319 --> 00:44:20,030
maybe my input is an INT maybe it's a bu
um we don't know yet we're going to

2168
00:44:20,030 --> 00:44:20,040
um we don't know yet we're going to
 

2169
00:44:20,040 --> 00:44:21,270
um we don't know yet we're going to
discover that in the course of type

2170
00:44:21,270 --> 00:44:21,280
discover that in the course of type
 

2171
00:44:21,280 --> 00:44:23,470
discover that in the course of type
checking and depending on uh what we

2172
00:44:23,470 --> 00:44:23,480
checking and depending on uh what we
 

2173
00:44:23,480 --> 00:44:25,430
checking and depending on uh what we
find that tie has to be different so so

2174
00:44:25,430 --> 00:44:25,440
find that tie has to be different so so
 

2175
00:44:25,440 --> 00:44:27,910
find that tie has to be different so so
this type doesn't really work what we

2176
00:44:27,910 --> 00:44:27,920
this type doesn't really work what we
 

2177
00:44:27,920 --> 00:44:30,109
this type doesn't really work what we
really want is this

2178
00:44:30,109 --> 00:44:30,119
really want is this
 

2179
00:44:30,119 --> 00:44:33,910
really want is this
type right that we know the context

2180
00:44:33,910 --> 00:44:33,920
type right that we know the context
 

2181
00:44:33,920 --> 00:44:35,990
type right that we know the context
coming in because we we've seen all the

2182
00:44:35,990 --> 00:44:36,000
coming in because we we've seen all the
 

2183
00:44:36,000 --> 00:44:38,470
coming in because we we've seen all the
variables up until this point then we

2184
00:44:38,470 --> 00:44:38,480
variables up until this point then we
 

2185
00:44:38,480 --> 00:44:41,390
variables up until this point then we
have some Expression A ux and then we're

2186
00:44:41,390 --> 00:44:41,400
have some Expression A ux and then we're
 

2187
00:44:41,400 --> 00:44:44,309
have some Expression A ux and then we're
going to produce an output type checked

2188
00:44:44,309 --> 00:44:44,319
going to produce an output type checked
 

2189
00:44:44,319 --> 00:44:47,710
going to produce an output type checked
expression um for some tie so this works

2190
00:44:47,710 --> 00:44:47,720
expression um for some tie so this works
 

2191
00:44:47,720 --> 00:44:51,109
expression um for some tie so this works
for any um uh length of context and any

2192
00:44:51,109 --> 00:44:51,119
for any um uh length of context and any
 

2193
00:44:51,119 --> 00:44:53,470
for any um uh length of context and any
input context but it produces some type

2194
00:44:53,470 --> 00:44:53,480
input context but it produces some type
 

2195
00:44:53,480 --> 00:44:56,430
input context but it produces some type
out but we don't know what it is um this

2196
00:44:56,430 --> 00:44:56,440
out but we don't know what it is um this
 

2197
00:44:56,440 --> 00:44:58,589
out but we don't know what it is um this
would actually work work quite well

2198
00:44:58,589 --> 00:44:58,599
would actually work work quite well
 

2199
00:44:58,599 --> 00:45:00,589
would actually work work quite well
except that exists

2200
00:45:00,589 --> 00:45:00,599
except that exists
 

2201
00:45:00,599 --> 00:45:04,829
except that exists
doesn't um so um this is that's actually

2202
00:45:04,829 --> 00:45:04,839
doesn't um so um this is that's actually
 

2203
00:45:04,839 --> 00:45:06,470
doesn't um so um this is that's actually
an interesting area of research that

2204
00:45:06,470 --> 00:45:06,480
an interesting area of research that
 

2205
00:45:06,480 --> 00:45:08,270
an interesting area of research that
that that that I'm working on right now

2206
00:45:08,270 --> 00:45:08,280
that that that I'm working on right now
 

2207
00:45:08,280 --> 00:45:10,670
that that that I'm working on right now
um uh with a a researcher at University

2208
00:45:10,670 --> 00:45:10,680
um uh with a a researcher at University
 

2209
00:45:10,680 --> 00:45:13,230
um uh with a a researcher at University
of Cambridge Neil Krishna Swami uh has

2210
00:45:13,230 --> 00:45:13,240
of Cambridge Neil Krishna Swami uh has
 

2211
00:45:13,240 --> 00:45:15,069
of Cambridge Neil Krishna Swami uh has
and and and a co-author Joshua dunfield

2212
00:45:15,069 --> 00:45:15,079
and and and a co-author Joshua dunfield
 

2213
00:45:15,079 --> 00:45:17,109
and and and a co-author Joshua dunfield
have some very interesting ideas for how

2214
00:45:17,109 --> 00:45:17,119
have some very interesting ideas for how
 

2215
00:45:17,119 --> 00:45:18,950
have some very interesting ideas for how
to get existent hasco but we're not

2216
00:45:18,950 --> 00:45:18,960
to get existent hasco but we're not
 

2217
00:45:18,960 --> 00:45:23,230
to get existent hasco but we're not
there yet um so instead we might have to

2218
00:45:23,230 --> 00:45:23,240
there yet um so instead we might have to
 

2219
00:45:23,240 --> 00:45:25,470
there yet um so instead we might have to
write it in in continuation passing

2220
00:45:25,470 --> 00:45:25,480
write it in in continuation passing
 

2221
00:45:25,480 --> 00:45:28,670
write it in in continuation passing
style um which is it does your head in a

2222
00:45:28,670 --> 00:45:28,680
style um which is it does your head in a
 

2223
00:45:28,680 --> 00:45:30,069
style um which is it does your head in a
little bit the first time but actually

2224
00:45:30,069 --> 00:45:30,079
little bit the first time but actually
 

2225
00:45:30,079 --> 00:45:31,670
little bit the first time but actually
not nearly so much as Finn does at least

2226
00:45:31,670 --> 00:45:31,680
not nearly so much as Finn does at least
 

2227
00:45:31,680 --> 00:45:35,150
not nearly so much as Finn does at least
not for me um by which I'm saying Finn

2228
00:45:35,150 --> 00:45:35,160
not for me um by which I'm saying Finn
 

2229
00:45:35,160 --> 00:45:38,710
not for me um by which I'm saying Finn
is is ah I don't like Finn um okay so

2230
00:45:38,710 --> 00:45:38,720
is is ah I don't like Finn um okay so
 

2231
00:45:38,720 --> 00:45:40,470
is is ah I don't like Finn um okay so
here in check the idea here is that we

2232
00:45:40,470 --> 00:45:40,480
here in check the idea here is that we
 

2233
00:45:40,480 --> 00:45:41,750
here in check the idea here is that we
have a bunch of variables being brought

2234
00:45:41,750 --> 00:45:41,760
have a bunch of variables being brought
 

2235
00:45:41,760 --> 00:45:43,390
have a bunch of variables being brought
into the scope but then we have one of

2236
00:45:43,390 --> 00:45:43,400
into the scope but then we have one of
 

2237
00:45:43,400 --> 00:45:44,870
into the scope but then we have one of
these unchecked

2238
00:45:44,870 --> 00:45:44,880
these unchecked
 

2239
00:45:44,880 --> 00:45:47,790
these unchecked
Expressions um and then what we're going

2240
00:45:47,790 --> 00:45:47,800
Expressions um and then what we're going
 

2241
00:45:47,800 --> 00:45:50,670
Expressions um and then what we're going
to do is we're going to pass our result

2242
00:45:50,670 --> 00:45:50,680
to do is we're going to pass our result
 

2243
00:45:50,680 --> 00:45:53,870
to do is we're going to pass our result
into some continuation so here now I can

2244
00:45:53,870 --> 00:45:53,880
into some continuation so here now I can
 

2245
00:45:53,880 --> 00:45:55,829
into some continuation so here now I can
sort of use this magic trick and turn

2246
00:45:55,829 --> 00:45:55,839
sort of use this magic trick and turn
 

2247
00:45:55,839 --> 00:45:57,829
sort of use this magic trick and turn
exists into for all because hascal has

2248
00:45:57,829 --> 00:45:57,839
exists into for all because hascal has
 

2249
00:45:57,839 --> 00:46:01,589
exists into for all because hascal has
for all um and so if I pass this into

2250
00:46:01,589 --> 00:46:01,599
for all um and so if I pass this into
 

2251
00:46:01,599 --> 00:46:03,990
for all um and so if I pass this into
some function that that runs in my monad

2252
00:46:03,990 --> 00:46:04,000
some function that that runs in my monad
 

2253
00:46:04,000 --> 00:46:05,790
some function that that runs in my monad
and produces a result R then I can

2254
00:46:05,790 --> 00:46:05,800
and produces a result R then I can
 

2255
00:46:05,800 --> 00:46:08,270
and produces a result R then I can
produce that result R um and so this is

2256
00:46:08,270 --> 00:46:08,280
produce that result R um and so this is
 

2257
00:46:08,280 --> 00:46:09,950
produce that result R um and so this is
continuation passing style and it's just

2258
00:46:09,950 --> 00:46:09,960
continuation passing style and it's just
 

2259
00:46:09,960 --> 00:46:11,270
continuation passing style and it's just
a trick to get around the fact that

2260
00:46:11,270 --> 00:46:11,280
a trick to get around the fact that
 

2261
00:46:11,280 --> 00:46:15,150
a trick to get around the fact that
exists doesn't um I could also use

2262
00:46:15,150 --> 00:46:15,160
exists doesn't um I could also use
 

2263
00:46:15,160 --> 00:46:17,109
exists doesn't um I could also use
existential data types that would work

2264
00:46:17,109 --> 00:46:17,119
existential data types that would work
 

2265
00:46:17,119 --> 00:46:20,069
existential data types that would work
just as well I found um when writing

2266
00:46:20,069 --> 00:46:20,079
just as well I found um when writing
 

2267
00:46:20,079 --> 00:46:21,790
just as well I found um when writing
this I actually tried it both ways I

2268
00:46:21,790 --> 00:46:21,800
this I actually tried it both ways I
 

2269
00:46:21,800 --> 00:46:23,150
this I actually tried it both ways I
found that doing this continuation

2270
00:46:23,150 --> 00:46:23,160
found that doing this continuation
 

2271
00:46:23,160 --> 00:46:24,670
found that doing this continuation
passing thing to work a little bit

2272
00:46:24,670 --> 00:46:24,680
passing thing to work a little bit
 

2273
00:46:24,680 --> 00:46:27,069
passing thing to work a little bit
better um it's just sort of syntax

2274
00:46:27,069 --> 00:46:27,079
better um it's just sort of syntax
 

2275
00:46:27,079 --> 00:46:28,710
better um it's just sort of syntax
syntactic stuff it would everything

2276
00:46:28,710 --> 00:46:28,720
syntactic stuff it would everything
 

2277
00:46:28,720 --> 00:46:30,190
syntactic stuff it would everything
would work just fine with existential

2278
00:46:30,190 --> 00:46:30,200
would work just fine with existential
 

2279
00:46:30,200 --> 00:46:33,030
would work just fine with existential
types if you're more familiar with those

2280
00:46:33,030 --> 00:46:33,040
types if you're more familiar with those
 

2281
00:46:33,040 --> 00:46:37,430
types if you're more familiar with those
um so this is almost the type but not

2282
00:46:37,430 --> 00:46:37,440
um so this is almost the type but not
 

2283
00:46:37,440 --> 00:46:39,630
um so this is almost the type but not
quite um because there's not exactly

2284
00:46:39,630 --> 00:46:39,640
quite um because there's not exactly
 

2285
00:46:39,640 --> 00:46:41,870
quite um because there's not exactly
enough information at runtime to be able

2286
00:46:41,870 --> 00:46:41,880
enough information at runtime to be able
 

2287
00:46:41,880 --> 00:46:44,750
enough information at runtime to be able
to do this in particular um you'll see

2288
00:46:44,750 --> 00:46:44,760
to do this in particular um you'll see
 

2289
00:46:44,760 --> 00:46:46,589
to do this in particular um you'll see
that the input to this function is

2290
00:46:46,589 --> 00:46:46,599
that the input to this function is
 

2291
00:46:46,599 --> 00:46:49,390
that the input to this function is
really just the unchecked

2292
00:46:49,390 --> 00:46:49,400
really just the unchecked
 

2293
00:46:49,400 --> 00:46:51,829
really just the unchecked
expression um I also need to know at

2294
00:46:51,829 --> 00:46:51,839
expression um I also need to know at
 

2295
00:46:51,839 --> 00:46:53,430
expression um I also need to know at
runtime the types of all the bound

2296
00:46:53,430 --> 00:46:53,440
runtime the types of all the bound
 

2297
00:46:53,440 --> 00:46:55,510
runtime the types of all the bound
variables so I need to have information

2298
00:46:55,510 --> 00:46:55,520
variables so I need to have information
 

2299
00:46:55,520 --> 00:46:59,270
variables so I need to have information
about my context CTS X so to do that um

2300
00:46:59,270 --> 00:46:59,280
about my context CTS X so to do that um
 

2301
00:46:59,280 --> 00:47:01,270
about my context CTS X so to do that um
I use this type so this really is the

2302
00:47:01,270 --> 00:47:01,280
I use this type so this really is the
 

2303
00:47:01,280 --> 00:47:04,230
I use this type so this really is the
type um

2304
00:47:04,230 --> 00:47:04,240
type um
 

2305
00:47:04,240 --> 00:47:07,990
type um
and let's see so this sctx thing that's

2306
00:47:07,990 --> 00:47:08,000
and let's see so this sctx thing that's
 

2307
00:47:08,000 --> 00:47:11,750
and let's see so this sctx thing that's
the that's a Singleton for my Vector

2308
00:47:11,750 --> 00:47:11,760
the that's a Singleton for my Vector
 

2309
00:47:11,760 --> 00:47:14,109
the that's a Singleton for my Vector
right I need to know the CTX at compile

2310
00:47:14,109 --> 00:47:14,119
right I need to know the CTX at compile
 

2311
00:47:14,119 --> 00:47:15,790
right I need to know the CTX at compile
time to to sort of know that everything

2312
00:47:15,790 --> 00:47:15,800
time to to sort of know that everything
 

2313
00:47:15,800 --> 00:47:17,549
time to to sort of know that everything
is well formed and I need to know it at

2314
00:47:17,549 --> 00:47:17,559
is well formed and I need to know it at
 

2315
00:47:17,559 --> 00:47:19,430
is well formed and I need to know it at
runtime so I can be able to look up

2316
00:47:19,430 --> 00:47:19,440
runtime so I can be able to look up
 

2317
00:47:19,440 --> 00:47:22,309
runtime so I can be able to look up
variables in the context at run time um

2318
00:47:22,309 --> 00:47:22,319
variables in the context at run time um
 

2319
00:47:22,319 --> 00:47:26,309
variables in the context at run time um
I also need um over here in my

2320
00:47:26,309 --> 00:47:26,319
I also need um over here in my
 

2321
00:47:26,319 --> 00:47:28,670
I also need um over here in my
continuation so as essentially as a

2322
00:47:28,670 --> 00:47:28,680
continuation so as essentially as a
 

2323
00:47:28,680 --> 00:47:31,510
continuation so as essentially as a
result of typ cheing I need to get out

2324
00:47:31,510 --> 00:47:31,520
result of typ cheing I need to get out
 

2325
00:47:31,520 --> 00:47:33,990
result of typ cheing I need to get out
the type um so so again I can use that

2326
00:47:33,990 --> 00:47:34,000
the type um so so again I can use that
 

2327
00:47:34,000 --> 00:47:35,150
the type um so so again I can use that
in things like Printing and error

2328
00:47:35,150 --> 00:47:35,160
in things like Printing and error
 

2329
00:47:35,160 --> 00:47:38,910
in things like Printing and error
messages and such um okay so let me show

2330
00:47:38,910 --> 00:47:38,920
messages and such um okay so let me show
 

2331
00:47:38,920 --> 00:47:41,109
messages and such um okay so let me show
sort of an example of all of this in

2332
00:47:41,109 --> 00:47:41,119
sort of an example of all of this in
 

2333
00:47:41,119 --> 00:47:43,430
sort of an example of all of this in
action instead of trying to render it in

2334
00:47:43,430 --> 00:47:43,440
action instead of trying to render it in
 

2335
00:47:43,440 --> 00:47:46,670
action instead of trying to render it in
slides let's look at some code oh but

2336
00:47:46,670 --> 00:47:46,680
slides let's look at some code oh but
 

2337
00:47:46,680 --> 00:47:49,230
slides let's look at some code oh but
you can't see anything can

2338
00:47:49,230 --> 00:47:49,240
you can't see anything can
 

2339
00:47:49,240 --> 00:47:51,549
you can't see anything can
you let

2340
00:47:51,549 --> 00:47:51,559
you let
 

2341
00:47:51,559 --> 00:47:54,630
you let
me do that there we go that looks pretty

2342
00:47:54,630 --> 00:47:54,640
me do that there we go that looks pretty
 

2343
00:47:54,640 --> 00:47:57,790
me do that there we go that looks pretty
good okay um probably want a little

2344
00:47:57,790 --> 00:47:57,800
good okay um probably want a little
 

2345
00:47:57,800 --> 00:48:00,349
good okay um probably want a little
bigger I

2346
00:48:00,349 --> 00:48:00,359

 

2347
00:48:00,359 --> 00:48:03,430

think there we go is that is that big

2348
00:48:03,430 --> 00:48:03,440
think there we go is that is that big
 

2349
00:48:03,440 --> 00:48:06,349
think there we go is that is that big
enough okay

2350
00:48:06,349 --> 00:48:06,359
enough okay
 

2351
00:48:06,359 --> 00:48:10,230
enough okay
um so here's here's my check function um

2352
00:48:10,230 --> 00:48:10,240
um so here's here's my check function um
 

2353
00:48:10,240 --> 00:48:11,829
um so here's here's my check function um
you can see that there's a bunch of of

2354
00:48:11,829 --> 00:48:11,839
you can see that there's a bunch of of
 

2355
00:48:11,839 --> 00:48:14,270
you can see that there's a bunch of of
monad stuff but actually here um I've

2356
00:48:14,270 --> 00:48:14,280
monad stuff but actually here um I've
 

2357
00:48:14,280 --> 00:48:15,790
monad stuff but actually here um I've
generalized this a little bit to use

2358
00:48:15,790 --> 00:48:15,800
generalized this a little bit to use
 

2359
00:48:15,800 --> 00:48:18,470
generalized this a little bit to use
sing instead of sctx but this is very

2360
00:48:18,470 --> 00:48:18,480
sing instead of sctx but this is very
 

2361
00:48:18,480 --> 00:48:20,309
sing instead of sctx but this is very
much the type that we just saw on the

2362
00:48:20,309 --> 00:48:20,319
much the type that we just saw on the
 

2363
00:48:20,319 --> 00:48:25,270
much the type that we just saw on the
slots um the the outer one uh is um uh

2364
00:48:25,270 --> 00:48:25,280
slots um the the outer one uh is um uh
 

2365
00:48:25,280 --> 00:48:26,870
slots um the the outer one uh is um uh
specialized just to work over Clos

2366
00:48:26,870 --> 00:48:26,880
specialized just to work over Clos
 

2367
00:48:26,880 --> 00:48:28,390
specialized just to work over Clos
Expressions but of course internally we

2368
00:48:28,390 --> 00:48:28,400
Expressions but of course internally we
 

2369
00:48:28,400 --> 00:48:32,069
Expressions but of course internally we
need to generalize them um so I think

2370
00:48:32,069 --> 00:48:32,079
need to generalize them um so I think
 

2371
00:48:32,079 --> 00:48:34,109
need to generalize them um so I think
it's instructive to look at the

2372
00:48:34,109 --> 00:48:34,119
it's instructive to look at the
 

2373
00:48:34,119 --> 00:48:35,790
it's instructive to look at the
application case because that's where a

2374
00:48:35,790 --> 00:48:35,800
application case because that's where a
 

2375
00:48:35,800 --> 00:48:39,069
application case because that's where a
lot of type errors really surface so

2376
00:48:39,069 --> 00:48:39,079
lot of type errors really surface so
 

2377
00:48:39,079 --> 00:48:42,750
lot of type errors really surface so
coming in right we have this U app so

2378
00:48:42,750 --> 00:48:42,760
coming in right we have this U app so
 

2379
00:48:42,760 --> 00:48:45,069
coming in right we have this U app so
this is unchecked we know it's scope

2380
00:48:45,069 --> 00:48:45,079
this is unchecked we know it's scope
 

2381
00:48:45,079 --> 00:48:48,230
this is unchecked we know it's scope
correct but maybe this is true applied

2382
00:48:48,230 --> 00:48:48,240
correct but maybe this is true applied
 

2383
00:48:48,240 --> 00:48:48,990
correct but maybe this is true applied
to

2384
00:48:48,990 --> 00:48:49,000
to
 

2385
00:48:49,000 --> 00:48:51,430
to
one right that would

2386
00:48:51,430 --> 00:48:51,440
one right that would
 

2387
00:48:51,440 --> 00:48:54,349
one right that would
parse um so we that could be the input

2388
00:48:54,349 --> 00:48:54,359
parse um so we that could be the input
 

2389
00:48:54,359 --> 00:48:57,309
parse um so we that could be the input
um and then this K here uh

2390
00:48:57,309 --> 00:48:57,319
um and then this K here uh
 

2391
00:48:57,319 --> 00:48:59,069
um and then this K here uh
you know people in this room might think

2392
00:48:59,069 --> 00:48:59,079
you know people in this room might think
 

2393
00:48:59,079 --> 00:49:01,589
you know people in this room might think
that's a kind no it's k for

2394
00:49:01,589 --> 00:49:01,599
that's a kind no it's k for
 

2395
00:49:01,599 --> 00:49:04,309
that's a kind no it's k for
continuation um so and we also have the

2396
00:49:04,309 --> 00:49:04,319
continuation um so and we also have the
 

2397
00:49:04,319 --> 00:49:06,630
continuation um so and we also have the
the context so this is the this gives us

2398
00:49:06,630 --> 00:49:06,640
the context so this is the this gives us
 

2399
00:49:06,640 --> 00:49:07,789
the context so this is the this gives us
information about the types of all the

2400
00:49:07,789 --> 00:49:07,799
information about the types of all the
 

2401
00:49:07,799 --> 00:49:09,990
information about the types of all the
variables that are in scope so what I

2402
00:49:09,990 --> 00:49:10,000
variables that are in scope so what I
 

2403
00:49:10,000 --> 00:49:13,910
variables that are in scope so what I
want to do is first I'm going to check

2404
00:49:13,910 --> 00:49:13,920
want to do is first I'm going to check
 

2405
00:49:13,920 --> 00:49:17,150
want to do is first I'm going to check
E1 and when I check E1 that's going to

2406
00:49:17,150 --> 00:49:17,160
E1 and when I check E1 that's going to
 

2407
00:49:17,160 --> 00:49:19,309
E1 and when I check E1 that's going to
get me the functions type E1 is my

2408
00:49:19,309 --> 00:49:19,319
get me the functions type E1 is my
 

2409
00:49:19,319 --> 00:49:22,630
get me the functions type E1 is my
function as well as the checked type E1

2410
00:49:22,630 --> 00:49:22,640
function as well as the checked type E1
 

2411
00:49:22,640 --> 00:49:25,950
function as well as the checked type E1
Prime so if E1 internally Were Somehow

2412
00:49:25,950 --> 00:49:25,960
Prime so if E1 internally Were Somehow
 

2413
00:49:25,960 --> 00:49:27,950
Prime so if E1 internally Were Somehow
bad this step would

2414
00:49:27,950 --> 00:49:27,960
bad this step would
 

2415
00:49:27,960 --> 00:49:31,390
bad this step would
fail then we're going to check E2 in the

2416
00:49:31,390 --> 00:49:31,400
fail then we're going to check E2 in the
 

2417
00:49:31,400 --> 00:49:33,349
fail then we're going to check E2 in the
same context right because both a

2418
00:49:33,349 --> 00:49:33,359
same context right because both a
 

2419
00:49:33,359 --> 00:49:35,630
same context right because both a
function and an argument are in the same

2420
00:49:35,630 --> 00:49:35,640
function and an argument are in the same
 

2421
00:49:35,640 --> 00:49:38,870
function and an argument are in the same
uh lexical context in in this language

2422
00:49:38,870 --> 00:49:38,880
uh lexical context in in this language
 

2423
00:49:38,880 --> 00:49:41,030
uh lexical context in in this language
um and that's going to produce the

2424
00:49:41,030 --> 00:49:41,040
um and that's going to produce the
 

2425
00:49:41,040 --> 00:49:44,190
um and that's going to produce the
argument type arai and a type checked

2426
00:49:44,190 --> 00:49:44,200
argument type arai and a type checked
 

2427
00:49:44,200 --> 00:49:47,190
argument type arai and a type checked
type or a type checked term E2 Prime so

2428
00:49:47,190 --> 00:49:47,200
type or a type checked term E2 Prime so
 

2429
00:49:47,200 --> 00:49:49,910
type or a type checked term E2 Prime so
we know at this point that E1 Prime is

2430
00:49:49,910 --> 00:49:49,920
we know at this point that E1 Prime is
 

2431
00:49:49,920 --> 00:49:52,150
we know at this point that E1 Prime is
has no type errors and E2 Prime has no

2432
00:49:52,150 --> 00:49:52,160
has no type errors and E2 Prime has no
 

2433
00:49:52,160 --> 00:49:53,470
has no type errors and E2 Prime has no
type errors but we still have to make

2434
00:49:53,470 --> 00:49:53,480
type errors but we still have to make
 

2435
00:49:53,480 --> 00:49:55,510
type errors but we still have to make
sure that E1 Prime can be applied to E2

2436
00:49:55,510 --> 00:49:55,520
sure that E1 Prime can be applied to E2
 

2437
00:49:55,520 --> 00:49:57,470
sure that E1 Prime can be applied to E2
Prime

2438
00:49:57,470 --> 00:49:57,480
Prime
 

2439
00:49:57,480 --> 00:49:59,910
Prime
um so I have to look I let's look at

2440
00:49:59,910 --> 00:49:59,920
um so I have to look I let's look at
 

2441
00:49:59,920 --> 00:50:01,150
um so I have to look I let's look at
that

2442
00:50:01,150 --> 00:50:01,160
that
 

2443
00:50:01,160 --> 00:50:05,670
that
funai well I really hope it's a function

2444
00:50:05,670 --> 00:50:05,680
funai well I really hope it's a function
 

2445
00:50:05,680 --> 00:50:09,510
funai well I really hope it's a function
right not an INT so I'm going to check

2446
00:50:09,510 --> 00:50:09,520
right not an INT so I'm going to check
 

2447
00:50:09,520 --> 00:50:10,589
right not an INT so I'm going to check
I'm going to check for it being a

2448
00:50:10,589 --> 00:50:10,599
I'm going to check for it being a
 

2449
00:50:10,599 --> 00:50:12,670
I'm going to check for it being a
function and then if it is a function

2450
00:50:12,670 --> 00:50:12,680
function and then if it is a function
 

2451
00:50:12,680 --> 00:50:15,349
function and then if it is a function
now I have to check does the argument

2452
00:50:15,349 --> 00:50:15,359
now I have to check does the argument
 

2453
00:50:15,359 --> 00:50:18,349
now I have to check does the argument
type that's the type of E2 does that

2454
00:50:18,349 --> 00:50:18,359
type that's the type of E2 does that
 

2455
00:50:18,359 --> 00:50:21,430
type that's the type of E2 does that
match the expected argument type of my

2456
00:50:21,430 --> 00:50:21,440
match the expected argument type of my
 

2457
00:50:21,440 --> 00:50:23,190
match the expected argument type of my
function right if I have a function from

2458
00:50:23,190 --> 00:50:23,200
function right if I have a function from
 

2459
00:50:23,200 --> 00:50:25,829
function right if I have a function from
int to BU but I give it a bu I want that

2460
00:50:25,829 --> 00:50:25,839
int to BU but I give it a bu I want that
 

2461
00:50:25,839 --> 00:50:27,950
int to BU but I give it a bu I want that
to be an error also so and so there's

2462
00:50:27,950 --> 00:50:27,960
to be an error also so and so there's
 

2463
00:50:27,960 --> 00:50:29,670
to be an error also so and so there's
sort of two checks here on two separate

2464
00:50:29,670 --> 00:50:29,680
sort of two checks here on two separate
 

2465
00:50:29,680 --> 00:50:31,270
sort of two checks here on two separate
lines right the first is is it a

2466
00:50:31,270 --> 00:50:31,280
lines right the first is is it a
 

2467
00:50:31,280 --> 00:50:33,549
lines right the first is is it a
function and do the argument types match

2468
00:50:33,549 --> 00:50:33,559
function and do the argument types match
 

2469
00:50:33,559 --> 00:50:37,390
function and do the argument types match
if so then I can

2470
00:50:37,390 --> 00:50:37,400
if so then I can
 

2471
00:50:37,400 --> 00:50:40,630
if so then I can
continue the type of the of E1 applied

2472
00:50:40,630 --> 00:50:40,640
continue the type of the of E1 applied
 

2473
00:50:40,640 --> 00:50:46,109
continue the type of the of E1 applied
to E2 is resti the result of my

2474
00:50:46,109 --> 00:50:46,119
to E2 is resti the result of my
 

2475
00:50:46,119 --> 00:50:49,430
to E2 is resti the result of my
function and then my type checked term

2476
00:50:49,430 --> 00:50:49,440
function and then my type checked term
 

2477
00:50:49,440 --> 00:50:52,710
function and then my type checked term
is an application of E1 Prime to E2

2478
00:50:52,710 --> 00:50:52,720
is an application of E1 Prime to E2
 

2479
00:50:52,720 --> 00:50:55,270
is an application of E1 Prime to E2
Prime otherwise if any of these checks

2480
00:50:55,270 --> 00:50:55,280
Prime otherwise if any of these checks
 

2481
00:50:55,280 --> 00:50:58,270
Prime otherwise if any of these checks
fail then I issue a type error and so

2482
00:50:58,270 --> 00:50:58,280
fail then I issue a type error and so
 

2483
00:50:58,280 --> 00:51:00,309
fail then I issue a type error and so
here I have this very general you know

2484
00:51:00,309 --> 00:51:00,319
here I have this very general you know
 

2485
00:51:00,319 --> 00:51:02,390
here I have this very general you know
bad function application I could have of

2486
00:51:02,390 --> 00:51:02,400
bad function application I could have of
 

2487
00:51:02,400 --> 00:51:04,589
bad function application I could have of
course split this up into that really

2488
00:51:04,589 --> 00:51:04,599
course split this up into that really
 

2489
00:51:04,599 --> 00:51:06,109
course split this up into that really
should have been a function but it isn't

2490
00:51:06,109 --> 00:51:06,119
should have been a function but it isn't
 

2491
00:51:06,119 --> 00:51:07,630
should have been a function but it isn't
and then a separate error this is a

2492
00:51:07,630 --> 00:51:07,640
and then a separate error this is a
 

2493
00:51:07,640 --> 00:51:08,870
and then a separate error this is a
function but you have the wrong type of

2494
00:51:08,870 --> 00:51:08,880
function but you have the wrong type of
 

2495
00:51:08,880 --> 00:51:10,230
function but you have the wrong type of
argument be easy to do that I just

2496
00:51:10,230 --> 00:51:10,240
argument be easy to do that I just
 

2497
00:51:10,240 --> 00:51:11,270
argument be easy to do that I just
didn't

2498
00:51:11,270 --> 00:51:11,280
didn't
 

2499
00:51:11,280 --> 00:51:14,870
didn't
bother um okay so this is sort of where

2500
00:51:14,870 --> 00:51:14,880
bother um okay so this is sort of where
 

2501
00:51:14,880 --> 00:51:17,710
bother um okay so this is sort of where
where where the heart of it is now these

2502
00:51:17,710 --> 00:51:17,720
where where the heart of it is now these
 

2503
00:51:17,720 --> 00:51:21,230
where where the heart of it is now these
checks and my type Checker must be

2504
00:51:21,230 --> 00:51:21,240
checks and my type Checker must be
 

2505
00:51:21,240 --> 00:51:25,510
checks and my type Checker must be
correct let's say I'm silly and I forget

2506
00:51:25,510 --> 00:51:25,520
correct let's say I'm silly and I forget
 

2507
00:51:25,520 --> 00:51:27,470
correct let's say I'm silly and I forget
this

2508
00:51:27,470 --> 00:51:27,480
this
 

2509
00:51:27,480 --> 00:51:30,190
this
right so now I've forgotten to check so

2510
00:51:30,190 --> 00:51:30,200
right so now I've forgotten to check so
 

2511
00:51:30,200 --> 00:51:32,510
right so now I've forgotten to check so
now I have checked that it's a function

2512
00:51:32,510 --> 00:51:32,520
now I have checked that it's a function
 

2513
00:51:32,520 --> 00:51:34,390
now I have checked that it's a function
but I forgot to check that the argument

2514
00:51:34,390 --> 00:51:34,400
but I forgot to check that the argument
 

2515
00:51:34,400 --> 00:51:37,829
but I forgot to check that the argument
type um uh matches the expected type so

2516
00:51:37,829 --> 00:51:37,839
type um uh matches the expected type so
 

2517
00:51:37,839 --> 00:51:41,190
type um uh matches the expected type so
if I save this and then now go over here

2518
00:51:41,190 --> 00:51:41,200
if I save this and then now go over here
 

2519
00:51:41,200 --> 00:51:48,309
if I save this and then now go over here
let's quit and cabal

2520
00:51:48,309 --> 00:51:48,319

 

2521
00:51:48,319 --> 00:51:52,309

build could not deduce that the argument

2522
00:51:52,309 --> 00:51:52,319
build could not deduce that the argument
 

2523
00:51:52,319 --> 00:51:54,069
build could not deduce that the argument
um was

2524
00:51:54,069 --> 00:51:54,079
um was
 

2525
00:51:54,079 --> 00:51:58,470
um was
T1 when if T equals ARG and let's see is

2526
00:51:58,470 --> 00:51:58,480
T1 when if T equals ARG and let's see is
 

2527
00:51:58,480 --> 00:51:59,750
T1 when if T equals ARG and let's see is
there some other stuff there should be

2528
00:51:59,750 --> 00:51:59,760
there some other stuff there should be
 

2529
00:51:59,760 --> 00:52:01,270
there some other stuff there should be
one other thing

2530
00:52:01,270 --> 00:52:01,280
one other thing
 

2531
00:52:01,280 --> 00:52:05,750
one other thing
here oh here expected

2532
00:52:05,750 --> 00:52:05,760
here oh here expected
 

2533
00:52:05,760 --> 00:52:09,829
here oh here expected
type having T1 here but actual type is T

2534
00:52:09,829 --> 00:52:09,839
type having T1 here but actual type is T
 

2535
00:52:09,839 --> 00:52:11,309
type having T1 here but actual type is T
no there's something else funny around

2536
00:52:11,309 --> 00:52:11,319
no there's something else funny around
 

2537
00:52:11,319 --> 00:52:14,349
no there's something else funny around
here oh that's right T equals ARG Arrow

2538
00:52:14,349 --> 00:52:14,359
here oh that's right T equals ARG Arrow
 

2539
00:52:14,359 --> 00:52:16,190
here oh that's right T equals ARG Arrow
res so right so if we if we sort of

2540
00:52:16,190 --> 00:52:16,200
res so right so if we if we sort of
 

2541
00:52:16,200 --> 00:52:18,710
res so right so if we if we sort of
Imagine replacing this ARG aror reses

2542
00:52:18,710 --> 00:52:18,720
Imagine replacing this ARG aror reses
 

2543
00:52:18,720 --> 00:52:21,270
Imagine replacing this ARG aror reses
into this error message then we'll see

2544
00:52:21,270 --> 00:52:21,280
into this error message then we'll see
 

2545
00:52:21,280 --> 00:52:25,910
into this error message then we'll see
that um the actual type is ARG Arrow res

2546
00:52:25,910 --> 00:52:25,920
that um the actual type is ARG Arrow res
 

2547
00:52:25,920 --> 00:52:27,589
that um the actual type is ARG Arrow res
but we were expecting T1 Arrow res and

2548
00:52:27,589 --> 00:52:27,599
but we were expecting T1 Arrow res and
 

2549
00:52:27,599 --> 00:52:29,309
but we were expecting T1 Arrow res and
that's because we haven't proved that T1

2550
00:52:29,309 --> 00:52:29,319
that's because we haven't proved that T1
 

2551
00:52:29,319 --> 00:52:34,270
that's because we haven't proved that T1
equals AR right because my type Checker

2552
00:52:34,270 --> 00:52:34,280
equals AR right because my type Checker
 

2553
00:52:34,280 --> 00:52:37,270
equals AR right because my type Checker
is broken I've forgotten to do a check

2554
00:52:37,270 --> 00:52:37,280
is broken I've forgotten to do a check
 

2555
00:52:37,280 --> 00:52:40,950
is broken I've forgotten to do a check
now my code doesn't compile so I've just

2556
00:52:40,950 --> 00:52:40,960
now my code doesn't compile so I've just
 

2557
00:52:40,960 --> 00:52:43,150
now my code doesn't compile so I've just
eliminated the possibility of a bug in

2558
00:52:43,150 --> 00:52:43,160
eliminated the possibility of a bug in
 

2559
00:52:43,160 --> 00:52:45,670
eliminated the possibility of a bug in
my interpreter right if I wasn't doing

2560
00:52:45,670 --> 00:52:45,680
my interpreter right if I wasn't doing
 

2561
00:52:45,680 --> 00:52:48,190
my interpreter right if I wasn't doing
all this fancy type stuff type stuff I

2562
00:52:48,190 --> 00:52:48,200
all this fancy type stuff type stuff I
 

2563
00:52:48,200 --> 00:52:51,030
all this fancy type stuff type stuff I
might have forgotten this and if I did

2564
00:52:51,030 --> 00:52:51,040
might have forgotten this and if I did
 

2565
00:52:51,040 --> 00:52:53,309
might have forgotten this and if I did
so then I would produce bad code I would

2566
00:52:53,309 --> 00:52:53,319
so then I would produce bad code I would
 

2567
00:52:53,319 --> 00:52:55,750
so then I would produce bad code I would
accept programs from the user that don't

2568
00:52:55,750 --> 00:52:55,760
accept programs from the user that don't
 

2569
00:52:55,760 --> 00:52:58,829
accept programs from the user that don't
make any sense

2570
00:52:58,829 --> 00:52:58,839

 

2571
00:52:58,839 --> 00:53:01,270

right if I went into GHC and deleted the

2572
00:53:01,270 --> 00:53:01,280
right if I went into GHC and deleted the
 

2573
00:53:01,280 --> 00:53:02,750
right if I went into GHC and deleted the
line of code that does this and of

2574
00:53:02,750 --> 00:53:02,760
line of code that does this and of
 

2575
00:53:02,760 --> 00:53:04,430
line of code that does this and of
course there is just a line of code GHC

2576
00:53:04,430 --> 00:53:04,440
course there is just a line of code GHC
 

2577
00:53:04,440 --> 00:53:07,870
course there is just a line of code GHC
that does basically this um you know GHC

2578
00:53:07,870 --> 00:53:07,880
that does basically this um you know GHC
 

2579
00:53:07,880 --> 00:53:09,829
that does basically this um you know GHC
would still compile but now it would

2580
00:53:09,829 --> 00:53:09,839
would still compile but now it would
 

2581
00:53:09,839 --> 00:53:11,910
would still compile but now it would
accept bad programs right so we don't

2582
00:53:11,910 --> 00:53:11,920
accept bad programs right so we don't
 

2583
00:53:11,920 --> 00:53:14,150
accept bad programs right so we don't
want to do that

2584
00:53:14,150 --> 00:53:14,160
want to do that
 

2585
00:53:14,160 --> 00:53:16,670
want to do that
um okay so the the the reason again of

2586
00:53:16,670 --> 00:53:16,680
um okay so the the the reason again of
 

2587
00:53:16,680 --> 00:53:18,990
um okay so the the the reason again of
showing that is that this is really

2588
00:53:18,990 --> 00:53:19,000
showing that is that this is really
 

2589
00:53:19,000 --> 00:53:20,190
showing that is that this is really
where the rubber is hitting the road

2590
00:53:20,190 --> 00:53:20,200
where the rubber is hitting the road
 

2591
00:53:20,200 --> 00:53:22,750
where the rubber is hitting the road
this is why we do all this fancy type

2592
00:53:22,750 --> 00:53:22,760
this is why we do all this fancy type
 

2593
00:53:22,760 --> 00:53:27,750
this is why we do all this fancy type
stuff okay um

2594
00:53:27,750 --> 00:53:27,760
stuff okay um
 

2595
00:53:27,760 --> 00:53:29,150
stuff okay um
so I'm going to try to go a little bit

2596
00:53:29,150 --> 00:53:29,160
so I'm going to try to go a little bit
 

2597
00:53:29,160 --> 00:53:30,510
so I'm going to try to go a little bit
faster because I want to leave time for

2598
00:53:30,510 --> 00:53:30,520
faster because I want to leave time for
 

2599
00:53:30,520 --> 00:53:32,990
faster because I want to leave time for
for questions um okay so that was the

2600
00:53:32,990 --> 00:53:33,000
for questions um okay so that was the
 

2601
00:53:33,000 --> 00:53:38,430
for questions um okay so that was the
code so um so step four uh evaluation

2602
00:53:38,430 --> 00:53:38,440
code so um so step four uh evaluation
 

2603
00:53:38,440 --> 00:53:39,789
code so um so step four uh evaluation
right so we've type checked now we need

2604
00:53:39,789 --> 00:53:39,799
right so we've type checked now we need
 

2605
00:53:39,799 --> 00:53:41,030
right so we've type checked now we need
to evaluate the

2606
00:53:41,030 --> 00:53:41,040
to evaluate the
 

2607
00:53:41,040 --> 00:53:43,910
to evaluate the
thing well actually this one's really

2608
00:53:43,910 --> 00:53:43,920
thing well actually this one's really
 

2609
00:53:43,920 --> 00:53:47,750
thing well actually this one's really
easy um at this point we have this this

2610
00:53:47,750 --> 00:53:47,760
easy um at this point we have this this
 

2611
00:53:47,760 --> 00:53:51,030
easy um at this point we have this this
well this this um uh this

2612
00:53:51,030 --> 00:53:51,040
well this this um uh this
 

2613
00:53:51,040 --> 00:53:53,990
well this this um uh this
index and so as I'm transforming it from

2614
00:53:53,990 --> 00:53:54,000
index and so as I'm transforming it from
 

2615
00:53:54,000 --> 00:53:57,270
index and so as I'm transforming it from
one thing to another if I make any

2616
00:53:57,270 --> 00:53:57,280
one thing to another if I make any
 

2617
00:53:57,280 --> 00:53:59,870
one thing to another if I make any
mistakes at all I'm going to get type

2618
00:53:59,870 --> 00:53:59,880
mistakes at all I'm going to get type
 

2619
00:53:59,880 --> 00:54:03,069
mistakes at all I'm going to get type
errors um and so maybe easy as an

2620
00:54:03,069 --> 00:54:03,079
errors um and so maybe easy as an
 

2621
00:54:03,079 --> 00:54:06,870
errors um and so maybe easy as an
overstatement but um it turns out that

2622
00:54:06,870 --> 00:54:06,880
overstatement but um it turns out that
 

2623
00:54:06,880 --> 00:54:08,190
overstatement but um it turns out that
that doing evaluation with to Brown

2624
00:54:08,190 --> 00:54:08,200
that doing evaluation with to Brown
 

2625
00:54:08,200 --> 00:54:10,230
that doing evaluation with to Brown
indices is very easy to get wrong but

2626
00:54:10,230 --> 00:54:10,240
indices is very easy to get wrong but
 

2627
00:54:10,240 --> 00:54:12,069
indices is very easy to get wrong but
every kind of mistake I could think of

2628
00:54:12,069 --> 00:54:12,079
every kind of mistake I could think of
 

2629
00:54:12,079 --> 00:54:13,589
every kind of mistake I could think of
and I thought of many while implementing

2630
00:54:13,589 --> 00:54:13,599
and I thought of many while implementing
 

2631
00:54:13,599 --> 00:54:16,549
and I thought of many while implementing
this I was told nice type errors to to

2632
00:54:16,549 --> 00:54:16,559
this I was told nice type errors to to
 

2633
00:54:16,559 --> 00:54:18,750
this I was told nice type errors to to
sort of guide me in the right direction

2634
00:54:18,750 --> 00:54:18,760
sort of guide me in the right direction
 

2635
00:54:18,760 --> 00:54:21,829
sort of guide me in the right direction
right when I transform the from one form

2636
00:54:21,829 --> 00:54:21,839
right when I transform the from one form
 

2637
00:54:21,839 --> 00:54:23,309
right when I transform the from one form
to another I always need to make sure to

2638
00:54:23,309 --> 00:54:23,319
to another I always need to make sure to
 

2639
00:54:23,319 --> 00:54:25,710
to another I always need to make sure to
be preserving types and even with just

2640
00:54:25,710 --> 00:54:25,720
be preserving types and even with just
 

2641
00:54:25,720 --> 00:54:28,549
be preserving types and even with just
int and bu functions that's enough for

2642
00:54:28,549 --> 00:54:28,559
int and bu functions that's enough for
 

2643
00:54:28,559 --> 00:54:30,390
int and bu functions that's enough for
for it to sort of know when I've done

2644
00:54:30,390 --> 00:54:30,400
for it to sort of know when I've done
 

2645
00:54:30,400 --> 00:54:32,349
for it to sort of know when I've done
something wrong it' be very hard to get

2646
00:54:32,349 --> 00:54:32,359
something wrong it' be very hard to get
 

2647
00:54:32,359 --> 00:54:34,910
something wrong it' be very hard to get
the evaluation wrong but still get still

2648
00:54:34,910 --> 00:54:34,920
the evaluation wrong but still get still
 

2649
00:54:34,920 --> 00:54:36,710
the evaluation wrong but still get still
get my code to

2650
00:54:36,710 --> 00:54:36,720
get my code to
 

2651
00:54:36,720 --> 00:54:39,549
get my code to
compile um so after I got all of this

2652
00:54:39,549 --> 00:54:39,559
compile um so after I got all of this
 

2653
00:54:39,559 --> 00:54:41,150
compile um so after I got all of this
working I wanted to see is this actually

2654
00:54:41,150 --> 00:54:41,160
working I wanted to see is this actually
 

2655
00:54:41,160 --> 00:54:43,470
working I wanted to see is this actually
realistic can we do things that a proper

2656
00:54:43,470 --> 00:54:43,480
realistic can we do things that a proper
 

2657
00:54:43,480 --> 00:54:46,030
realistic can we do things that a proper
compiler or interpreter might want to do

2658
00:54:46,030 --> 00:54:46,040
compiler or interpreter might want to do
 

2659
00:54:46,040 --> 00:54:47,349
compiler or interpreter might want to do
um so I implemented common sub

2660
00:54:47,349 --> 00:54:47,359
um so I implemented common sub
 

2661
00:54:47,359 --> 00:54:48,270
um so I implemented common sub
expression

2662
00:54:48,270 --> 00:54:48,280
expression
 

2663
00:54:48,280 --> 00:54:52,309
expression
elimination um so so we can actually um

2664
00:54:52,309 --> 00:54:52,319
elimination um so so we can actually um
 

2665
00:54:52,319 --> 00:54:53,710
elimination um so so we can actually um
oh no I'm not going to I'm not going to

2666
00:54:53,710 --> 00:54:53,720
oh no I'm not going to I'm not going to
 

2667
00:54:53,720 --> 00:54:57,390
oh no I'm not going to I'm not going to
bother with it um we can we can imagine

2668
00:54:57,390 --> 00:54:57,400
bother with it um we can we can imagine
 

2669
00:54:57,400 --> 00:54:58,829
bother with it um we can we can imagine
um uh not imagine there there's a

2670
00:54:58,829 --> 00:54:58,839
um uh not imagine there there's a
 

2671
00:54:58,839 --> 00:55:01,309
um uh not imagine there there's a
command colon csse in The Interpreter

2672
00:55:01,309 --> 00:55:01,319
command colon csse in The Interpreter
 

2673
00:55:01,319 --> 00:55:02,750
command colon csse in The Interpreter
that will take an expression with

2674
00:55:02,750 --> 00:55:02,760
that will take an expression with
 

2675
00:55:02,760 --> 00:55:04,390
that will take an expression with
multiple common sub expressions and

2676
00:55:04,390 --> 00:55:04,400
multiple common sub expressions and
 

2677
00:55:04,400 --> 00:55:07,190
multiple common sub expressions and
optimize it um and even with all of

2678
00:55:07,190 --> 00:55:07,200
optimize it um and even with all of
 

2679
00:55:07,200 --> 00:55:08,870
optimize it um and even with all of
these types we can do

2680
00:55:08,870 --> 00:55:08,880
these types we can do
 

2681
00:55:08,880 --> 00:55:12,470
these types we can do
this um and again there were various

2682
00:55:12,470 --> 00:55:12,480
this um and again there were various
 

2683
00:55:12,480 --> 00:55:13,990
this um and again there were various
pitfalls but I was saved from all the

2684
00:55:13,990 --> 00:55:14,000
pitfalls but I was saved from all the
 

2685
00:55:14,000 --> 00:55:15,190
pitfalls but I was saved from all the
pitfalls I didn't have to worry about

2686
00:55:15,190 --> 00:55:15,200
pitfalls I didn't have to worry about
 

2687
00:55:15,200 --> 00:55:16,270
pitfalls I didn't have to worry about
shadowing I didn't have to worry about

2688
00:55:16,270 --> 00:55:16,280
shadowing I didn't have to worry about
 

2689
00:55:16,280 --> 00:55:18,430
shadowing I didn't have to worry about
substitution all of that stuff because

2690
00:55:18,430 --> 00:55:18,440
substitution all of that stuff because
 

2691
00:55:18,440 --> 00:55:20,190
substitution all of that stuff because
anytime I made a mistake I got type

2692
00:55:20,190 --> 00:55:20,200
anytime I made a mistake I got type
 

2693
00:55:20,200 --> 00:55:22,950
anytime I made a mistake I got type
errors um much easier to just get type

2694
00:55:22,950 --> 00:55:22,960
errors um much easier to just get type
 

2695
00:55:22,960 --> 00:55:24,990
errors um much easier to just get type
errors up front than having to think of

2696
00:55:24,990 --> 00:55:25,000
errors up front than having to think of
 

2697
00:55:25,000 --> 00:55:27,549
errors up front than having to think of
oh 50 programs to build up a test Suite

2698
00:55:27,549 --> 00:55:27,559
oh 50 programs to build up a test Suite
 

2699
00:55:27,559 --> 00:55:29,150
oh 50 programs to build up a test Suite
to see if my common sub expression

2700
00:55:29,150 --> 00:55:29,160
to see if my common sub expression
 

2701
00:55:29,160 --> 00:55:31,630
to see if my common sub expression
elimination is working um one

2702
00:55:31,630 --> 00:55:31,640
elimination is working um one
 

2703
00:55:31,640 --> 00:55:33,750
elimination is working um one
interesting part of this is is that as

2704
00:55:33,750 --> 00:55:33,760
interesting part of this is is that as
 

2705
00:55:33,760 --> 00:55:35,710
interesting part of this is is that as
you might imagine so we're processing

2706
00:55:35,710 --> 00:55:35,720
you might imagine so we're processing
 

2707
00:55:35,720 --> 00:55:37,430
you might imagine so we're processing
this this expression and I I need to

2708
00:55:37,430 --> 00:55:37,440
this this expression and I I need to
 

2709
00:55:37,440 --> 00:55:39,710
this this expression and I I need to
build up some structure which Maps

2710
00:55:39,710 --> 00:55:39,720
build up some structure which Maps
 

2711
00:55:39,720 --> 00:55:43,549
build up some structure which Maps
Expressions to um uh to names right so I

2712
00:55:43,549 --> 00:55:43,559
Expressions to um uh to names right so I
 

2713
00:55:43,559 --> 00:55:45,270
Expressions to um uh to names right so I
can see oh I've seen this expression

2714
00:55:45,270 --> 00:55:45,280
can see oh I've seen this expression
 

2715
00:55:45,280 --> 00:55:47,670
can see oh I've seen this expression
before so we need to have this mapping

2716
00:55:47,670 --> 00:55:47,680
before so we need to have this mapping
 

2717
00:55:47,680 --> 00:55:49,870
before so we need to have this mapping
um so there's a uh in in the unordered

2718
00:55:49,870 --> 00:55:49,880
um so there's a uh in in the unordered
 

2719
00:55:49,880 --> 00:55:51,870
um so there's a uh in in the unordered
containers Library we have this hashmap

2720
00:55:51,870 --> 00:55:51,880
containers Library we have this hashmap
 

2721
00:55:51,880 --> 00:55:55,349
containers Library we have this hashmap
type well I generalized it to be to map

2722
00:55:55,349 --> 00:55:55,359
type well I generalized it to be to map
 

2723
00:55:55,359 --> 00:55:57,510
type well I generalized it to be to map
from uh keys to values where the keys

2724
00:55:57,510 --> 00:55:57,520
from uh keys to values where the keys
 

2725
00:55:57,520 --> 00:55:59,549
from uh keys to values where the keys
and the values were indexed by some

2726
00:55:59,549 --> 00:55:59,559
and the values were indexed by some
 

2727
00:55:59,559 --> 00:56:02,750
and the values were indexed by some
other uh type I right so this is going

2728
00:56:02,750 --> 00:56:02,760
other uh type I right so this is going
 

2729
00:56:02,760 --> 00:56:05,349
other uh type I right so this is going
to be the type of of of expression and

2730
00:56:05,349 --> 00:56:05,359
to be the type of of of expression and
 

2731
00:56:05,359 --> 00:56:06,789
to be the type of of of expression and
so this was this meant that it was rich

2732
00:56:06,789 --> 00:56:06,799
so this was this meant that it was rich
 

2733
00:56:06,799 --> 00:56:08,950
so this was this meant that it was rich
enough that once I identified ah this

2734
00:56:08,950 --> 00:56:08,960
enough that once I identified ah this
 

2735
00:56:08,960 --> 00:56:10,630
enough that once I identified ah this
expression is the same as this one not

2736
00:56:10,630 --> 00:56:10,640
expression is the same as this one not
 

2737
00:56:10,640 --> 00:56:11,829
expression is the same as this one not
only do I know that the expressions are

2738
00:56:11,829 --> 00:56:11,839
only do I know that the expressions are
 

2739
00:56:11,839 --> 00:56:13,589
only do I know that the expressions are
the same but the types are the same and

2740
00:56:13,589 --> 00:56:13,599
the same but the types are the same and
 

2741
00:56:13,599 --> 00:56:15,510
the same but the types are the same and
so I could sort of merge them together

2742
00:56:15,510 --> 00:56:15,520
so I could sort of merge them together
 

2743
00:56:15,520 --> 00:56:17,589
so I could sort of merge them together
otherwise I need to use an unsafe coer

2744
00:56:17,589 --> 00:56:17,599
otherwise I need to use an unsafe coer
 

2745
00:56:17,599 --> 00:56:20,510
otherwise I need to use an unsafe coer
somewhere um so the way I did this is I

2746
00:56:20,510 --> 00:56:20,520
somewhere um so the way I did this is I
 

2747
00:56:20,520 --> 00:56:22,150
somewhere um so the way I did this is I
I literally took the code from unordered

2748
00:56:22,150 --> 00:56:22,160
I literally took the code from unordered
 

2749
00:56:22,160 --> 00:56:23,670
I literally took the code from unordered
containers and I just sort of downloaded

2750
00:56:23,670 --> 00:56:23,680
containers and I just sort of downloaded
 

2751
00:56:23,680 --> 00:56:27,190
containers and I just sort of downloaded
it from GitHub and changed the def of

2752
00:56:27,190 --> 00:56:27,200
it from GitHub and changed the def of
 

2753
00:56:27,200 --> 00:56:30,670
it from GitHub and changed the def of
the data type from that to that and then

2754
00:56:30,670 --> 00:56:30,680
the data type from that to that and then
 

2755
00:56:30,680 --> 00:56:33,309
the data type from that to that and then
just kept trying to compile and getting

2756
00:56:33,309 --> 00:56:33,319
just kept trying to compile and getting
 

2757
00:56:33,319 --> 00:56:34,430
just kept trying to compile and getting
and getting an error and then just sort

2758
00:56:34,430 --> 00:56:34,440
and getting an error and then just sort
 

2759
00:56:34,440 --> 00:56:36,430
and getting an error and then just sort
of adding what was obviously should what

2760
00:56:36,430 --> 00:56:36,440
of adding what was obviously should what
 

2761
00:56:36,440 --> 00:56:38,430
of adding what was obviously should what
obviously should have gone there um this

2762
00:56:38,430 --> 00:56:38,440
obviously should have gone there um this
 

2763
00:56:38,440 --> 00:56:40,910
obviously should have gone there um this
was really quite fun it was 2,000 lines

2764
00:56:40,910 --> 00:56:40,920
was really quite fun it was 2,000 lines
 

2765
00:56:40,920 --> 00:56:43,349
was really quite fun it was 2,000 lines
of code that I had no familiarity with

2766
00:56:43,349 --> 00:56:43,359
of code that I had no familiarity with
 

2767
00:56:43,359 --> 00:56:44,630
of code that I had no familiarity with
at all and it took me about an hour to

2768
00:56:44,630 --> 00:56:44,640
at all and it took me about an hour to
 

2769
00:56:44,640 --> 00:56:47,190
at all and it took me about an hour to
do all of this um which which was which

2770
00:56:47,190 --> 00:56:47,200
do all of this um which which was which
 

2771
00:56:47,200 --> 00:56:48,349
do all of this um which which was which
was great and the type errors were

2772
00:56:48,349 --> 00:56:48,359
was great and the type errors were
 

2773
00:56:48,359 --> 00:56:49,390
was great and the type errors were
really quite

2774
00:56:49,390 --> 00:56:49,400
really quite
 

2775
00:56:49,400 --> 00:56:53,510
really quite
nice um okay so pulling out of the weeds

2776
00:56:53,510 --> 00:56:53,520
nice um okay so pulling out of the weeds
 

2777
00:56:53,520 --> 00:56:54,829
nice um okay so pulling out of the weeds
a little bit so again if you fallen

2778
00:56:54,829 --> 00:56:54,839
a little bit so again if you fallen
 

2779
00:56:54,839 --> 00:56:56,829
a little bit so again if you fallen
asleep maybe now is a time to tune tune

2780
00:56:56,829 --> 00:56:56,839
asleep maybe now is a time to tune tune
 

2781
00:56:56,839 --> 00:57:00,470
asleep maybe now is a time to tune tune
in again um uh so what have I done here

2782
00:57:00,470 --> 00:57:00,480
in again um uh so what have I done here
 

2783
00:57:00,480 --> 00:57:02,349
in again um uh so what have I done here
so in my compiler now this isn't just

2784
00:57:02,349 --> 00:57:02,359
so in my compiler now this isn't just
 

2785
00:57:02,359 --> 00:57:04,910
so in my compiler now this isn't just
even about Lambda calculus but um what I

2786
00:57:04,910 --> 00:57:04,920
even about Lambda calculus but um what I
 

2787
00:57:04,920 --> 00:57:06,470
even about Lambda calculus but um what I
wanted to do is I wanted to identify a

2788
00:57:06,470 --> 00:57:06,480
wanted to do is I wanted to identify a
 

2789
00:57:06,480 --> 00:57:08,910
wanted to do is I wanted to identify a
data invariant the invariant was that my

2790
00:57:08,910 --> 00:57:08,920
data invariant the invariant was that my
 

2791
00:57:08,920 --> 00:57:11,589
data invariant the invariant was that my
expressions are well typed I want to be

2792
00:57:11,589 --> 00:57:11,599
expressions are well typed I want to be
 

2793
00:57:11,599 --> 00:57:14,390
expressions are well typed I want to be
able to to to know that that must be

2794
00:57:14,390 --> 00:57:14,400
able to to to know that that must be
 

2795
00:57:14,400 --> 00:57:17,710
able to to to know that that must be
true then I I think up a way of of

2796
00:57:17,710 --> 00:57:17,720
true then I I think up a way of of
 

2797
00:57:17,720 --> 00:57:19,910
true then I I think up a way of of
adding more types to my program to check

2798
00:57:19,910 --> 00:57:19,920
adding more types to my program to check
 

2799
00:57:19,920 --> 00:57:22,309
adding more types to my program to check
that data invariant so now I can be sure

2800
00:57:22,309 --> 00:57:22,319
that data invariant so now I can be sure
 

2801
00:57:22,319 --> 00:57:24,670
that data invariant so now I can be sure
that that invariant is always true even

2802
00:57:24,670 --> 00:57:24,680
that that invariant is always true even
 

2803
00:57:24,680 --> 00:57:28,150
that that invariant is always true even
as my even as my data evolves

2804
00:57:28,150 --> 00:57:28,160
as my even as my data evolves
 

2805
00:57:28,160 --> 00:57:31,910
as my even as my data evolves
um so once I add that to my data type

2806
00:57:31,910 --> 00:57:31,920
um so once I add that to my data type
 

2807
00:57:31,920 --> 00:57:33,829
um so once I add that to my data type
now I have to prove that my code

2808
00:57:33,829 --> 00:57:33,839
now I have to prove that my code
 

2809
00:57:33,839 --> 00:57:36,789
now I have to prove that my code
respects the invariant so what I mean by

2810
00:57:36,789 --> 00:57:36,799
respects the invariant so what I mean by
 

2811
00:57:36,799 --> 00:57:40,589
respects the invariant so what I mean by
this is um is like in my parer so

2812
00:57:40,589 --> 00:57:40,599
this is um is like in my parer so
 

2813
00:57:40,599 --> 00:57:43,190
this is um is like in my parer so
originally my my ux my invariant was

2814
00:57:43,190 --> 00:57:43,200
originally my my ux my invariant was
 

2815
00:57:43,200 --> 00:57:44,750
originally my my ux my invariant was
it's well scoped but then I had to do

2816
00:57:44,750 --> 00:57:44,760
it's well scoped but then I had to do
 

2817
00:57:44,760 --> 00:57:46,470
it's well scoped but then I had to do
all sorts of stuff to the parser to get

2818
00:57:46,470 --> 00:57:46,480
all sorts of stuff to the parser to get
 

2819
00:57:46,480 --> 00:57:50,549
all sorts of stuff to the parser to get
that to work then once my um internal

2820
00:57:50,549 --> 00:57:50,559
that to work then once my um internal
 

2821
00:57:50,559 --> 00:57:52,150
that to work then once my um internal
expression with my type checked

2822
00:57:52,150 --> 00:57:52,160
expression with my type checked
 

2823
00:57:52,160 --> 00:57:54,109
expression with my type checked
expression was well typed then I had to

2824
00:57:54,109 --> 00:57:54,119
expression was well typed then I had to
 

2825
00:57:54,119 --> 00:57:56,710
expression was well typed then I had to
make sure that my type checker was was

2826
00:57:56,710 --> 00:57:56,720
make sure that my type checker was was
 

2827
00:57:56,720 --> 00:57:58,510
make sure that my type checker was was
absolutely correct so that's what I mean

2828
00:57:58,510 --> 00:57:58,520
absolutely correct so that's what I mean
 

2829
00:57:58,520 --> 00:58:00,589
absolutely correct so that's what I mean
by prove my code respects the

2830
00:58:00,589 --> 00:58:00,599
by prove my code respects the
 

2831
00:58:00,599 --> 00:58:02,990
by prove my code respects the
invariant um and my common sub

2832
00:58:02,990 --> 00:58:03,000
invariant um and my common sub
 

2833
00:58:03,000 --> 00:58:04,430
invariant um and my common sub
expression Eliminator had to make sure

2834
00:58:04,430 --> 00:58:04,440
expression Eliminator had to make sure
 

2835
00:58:04,440 --> 00:58:06,109
expression Eliminator had to make sure
not to combine expressions of different

2836
00:58:06,109 --> 00:58:06,119
not to combine expressions of different
 

2837
00:58:06,119 --> 00:58:07,990
not to combine expressions of different
type from different areas of the

2838
00:58:07,990 --> 00:58:08,000
type from different areas of the
 

2839
00:58:08,000 --> 00:58:10,990
type from different areas of the
code um and then we can repeat we can

2840
00:58:10,990 --> 00:58:11,000
code um and then we can repeat we can
 

2841
00:58:11,000 --> 00:58:13,190
code um and then we can repeat we can
look for more properties that we might

2842
00:58:13,190 --> 00:58:13,200
look for more properties that we might
 

2843
00:58:13,200 --> 00:58:16,789
look for more properties that we might
want to add um so for example we I have

2844
00:58:16,789 --> 00:58:16,799
want to add um so for example we I have
 

2845
00:58:16,799 --> 00:58:19,470
want to add um so for example we I have
not you know done any invariance in in

2846
00:58:19,470 --> 00:58:19,480
not you know done any invariance in in
 

2847
00:58:19,480 --> 00:58:21,670
not you know done any invariance in in
my program that shows that evaluation is

2848
00:58:21,670 --> 00:58:21,680
my program that shows that evaluation is
 

2849
00:58:21,680 --> 00:58:23,230
my program that shows that evaluation is
correct right if I have this big

2850
00:58:23,230 --> 00:58:23,240
correct right if I have this big
 

2851
00:58:23,240 --> 00:58:24,950
correct right if I have this big
expression of type in I might

2852
00:58:24,950 --> 00:58:24,960
expression of type in I might
 

2853
00:58:24,960 --> 00:58:27,190
expression of type in I might
accidentally replace that with five

2854
00:58:27,190 --> 00:58:27,200
accidentally replace that with five
 

2855
00:58:27,200 --> 00:58:28,710
accidentally replace that with five
and and nothing bad would happen but

2856
00:58:28,710 --> 00:58:28,720
and and nothing bad would happen but
 

2857
00:58:28,720 --> 00:58:30,430
and and nothing bad would happen but
maybe I want to go through and and add

2858
00:58:30,430 --> 00:58:30,440
maybe I want to go through and and add
 

2859
00:58:30,440 --> 00:58:34,349
maybe I want to go through and and add
more types to be able to do that um okay

2860
00:58:34,349 --> 00:58:34,359
more types to be able to do that um okay
 

2861
00:58:34,359 --> 00:58:37,470
more types to be able to do that um okay
so this worked this was actually quite

2862
00:58:37,470 --> 00:58:37,480
so this worked this was actually quite
 

2863
00:58:37,480 --> 00:58:39,789
so this worked this was actually quite
uh bu building this the type errors some

2864
00:58:39,789 --> 00:58:39,799
uh bu building this the type errors some
 

2865
00:58:39,799 --> 00:58:42,190
uh bu building this the type errors some
of them were long but for the most part

2866
00:58:42,190 --> 00:58:42,200
of them were long but for the most part
 

2867
00:58:42,200 --> 00:58:43,549
of them were long but for the most part
they were really quite helpful there was

2868
00:58:43,549 --> 00:58:43,559
they were really quite helpful there was
 

2869
00:58:43,559 --> 00:58:46,069
they were really quite helpful there was
a few dark Corners that I could I could

2870
00:58:46,069 --> 00:58:46,079
a few dark Corners that I could I could
 

2871
00:58:46,079 --> 00:58:48,230
a few dark Corners that I could I could
describe if someone wants um of areas

2872
00:58:48,230 --> 00:58:48,240
describe if someone wants um of areas
 

2873
00:58:48,240 --> 00:58:49,710
describe if someone wants um of areas
that I think GHC really needs to improve

2874
00:58:49,710 --> 00:58:49,720
that I think GHC really needs to improve
 

2875
00:58:49,720 --> 00:58:53,270
that I think GHC really needs to improve
although I realize GHC has improved

2876
00:58:53,270 --> 00:58:53,280
although I realize GHC has improved
 

2877
00:58:53,280 --> 00:58:56,829
although I realize GHC has improved
since I since I wrote this since I wrote

2878
00:58:56,829 --> 00:58:56,839
since I since I wrote this since I wrote
 

2879
00:58:56,839 --> 00:58:58,549
since I since I wrote this since I wrote
stitch in in in one particular way that

2880
00:58:58,549 --> 00:58:58,559
stitch in in in one particular way that
 

2881
00:58:58,559 --> 00:59:00,230
stitch in in in one particular way that
really got me we now have Standalone

2882
00:59:00,230 --> 00:59:00,240
really got me we now have Standalone
 

2883
00:59:00,240 --> 00:59:02,510
really got me we now have Standalone
kind signatures which really really got

2884
00:59:02,510 --> 00:59:02,520
kind signatures which really really got
 

2885
00:59:02,520 --> 00:59:05,430
kind signatures which really really got
me at one point while doing this um so

2886
00:59:05,430 --> 00:59:05,440
me at one point while doing this um so
 

2887
00:59:05,440 --> 00:59:07,549
me at one point while doing this um so
we're we're ready for this now I will

2888
00:59:07,549 --> 00:59:07,559
we're we're ready for this now I will
 

2889
00:59:07,559 --> 00:59:08,789
we're we're ready for this now I will
say I want to connect this back I

2890
00:59:08,789 --> 00:59:08,799
say I want to connect this back I
 

2891
00:59:08,799 --> 00:59:10,349
say I want to connect this back I
mentioned there was this talk earlier

2892
00:59:10,349 --> 00:59:10,359
mentioned there was this talk earlier
 

2893
00:59:10,359 --> 00:59:13,589
mentioned there was this talk earlier
from um Marco um who whose last name

2894
00:59:13,589 --> 00:59:13,599
from um Marco um who whose last name
 

2895
00:59:13,599 --> 00:59:15,150
from um Marco um who whose last name
escapes me unfortunately but uh he's a

2896
00:59:15,150 --> 00:59:15,160
escapes me unfortunately but uh he's a
 

2897
00:59:15,160 --> 00:59:18,109
escapes me unfortunately but uh he's a
he's a s can you can you say that loud I

2898
00:59:18,109 --> 00:59:18,119
he's a s can you can you say that loud I
 

2899
00:59:18,119 --> 00:59:21,589
he's a s can you can you say that loud I
don't want s San Pelini thank you yes

2900
00:59:21,589 --> 00:59:21,599
don't want s San Pelini thank you yes
 

2901
00:59:21,599 --> 00:59:25,589
don't want s San Pelini thank you yes
okay um so uh so Marco is a developer at

2902
00:59:25,589 --> 00:59:25,599
okay um so uh so Marco is a developer at
 

2903
00:59:25,599 --> 00:59:26,549
okay um so uh so Marco is a developer at
habo

2904
00:59:26,549 --> 00:59:26,559
habo
 

2905
00:59:26,559 --> 00:59:28,430
habo
and and and his talk was about how it's

2906
00:59:28,430 --> 00:59:28,440
and and and his talk was about how it's
 

2907
00:59:28,440 --> 00:59:32,990
and and and his talk was about how it's
good to avoid fancy types um and I agree

2908
00:59:32,990 --> 00:59:33,000
good to avoid fancy types um and I agree
 

2909
00:59:33,000 --> 00:59:36,309
good to avoid fancy types um and I agree
with that too so I spend a lot of my

2910
00:59:36,309 --> 00:59:36,319
with that too so I spend a lot of my
 

2911
00:59:36,319 --> 00:59:39,309
with that too so I spend a lot of my
time hacking on GHC um g in the code of

2912
00:59:39,309 --> 00:59:39,319
time hacking on GHC um g in the code of
 

2913
00:59:39,319 --> 00:59:42,990
time hacking on GHC um g in the code of
GHC we use very few GHC extensions right

2914
00:59:42,990 --> 00:59:43,000
GHC we use very few GHC extensions right
 

2915
00:59:43,000 --> 00:59:45,029
GHC we use very few GHC extensions right
because it's actually easier to program

2916
00:59:45,029 --> 00:59:45,039
because it's actually easier to program
 

2917
00:59:45,039 --> 00:59:46,309
because it's actually easier to program
sometimes without all of these fancy

2918
00:59:46,309 --> 00:59:46,319
sometimes without all of these fancy
 

2919
00:59:46,319 --> 00:59:48,549
sometimes without all of these fancy
types but sometimes it's really

2920
00:59:48,549 --> 00:59:48,559
types but sometimes it's really
 

2921
00:59:48,559 --> 00:59:50,150
types but sometimes it's really
important that we we have something

2922
00:59:50,150 --> 00:59:50,160
important that we we have something
 

2923
00:59:50,160 --> 00:59:51,270
important that we we have something
right or sometimes we want to express

2924
00:59:51,270 --> 00:59:51,280
right or sometimes we want to express
 

2925
00:59:51,280 --> 00:59:53,230
right or sometimes we want to express
something that's hard to express so for

2926
00:59:53,230 --> 00:59:53,240
something that's hard to express so for
 

2927
00:59:53,240 --> 00:59:55,710
something that's hard to express so for
example uh typable that's that's a

2928
00:59:55,710 --> 00:59:55,720
example uh typable that's that's a
 

2929
00:59:55,720 --> 00:59:58,309
example uh typable that's that's a
component of GC that has a ton of type

2930
00:59:58,309 --> 00:59:58,319
component of GC that has a ton of type
 

2931
00:59:58,319 --> 01:00:00,589
component of GC that has a ton of type
extensions to be able to power uh

2932
01:00:00,589 --> 01:00:00,599
extensions to be able to power uh
 

2933
01:00:00,599 --> 01:00:02,750
extensions to be able to power uh
typable and type rep to enable Dynamic

2934
01:00:02,750 --> 01:00:02,760
typable and type rep to enable Dynamic
 

2935
01:00:02,760 --> 01:00:06,309
typable and type rep to enable Dynamic
typing um there's uh and there's a few

2936
01:00:06,309 --> 01:00:06,319
typing um there's uh and there's a few
 

2937
01:00:06,319 --> 01:00:07,870
typing um there's uh and there's a few
data structures within GHC that we sort

2938
01:00:07,870 --> 01:00:07,880
data structures within GHC that we sort
 

2939
01:00:07,880 --> 01:00:09,069
data structures within GHC that we sort
of want to have a little bit more

2940
01:00:09,069 --> 01:00:09,079
of want to have a little bit more
 

2941
01:00:09,079 --> 01:00:10,910
of want to have a little bit more
protection around that we use some extra

2942
01:00:10,910 --> 01:00:10,920
protection around that we use some extra
 

2943
01:00:10,920 --> 01:00:14,069
protection around that we use some extra
typing stuff um so we the idea here is

2944
01:00:14,069 --> 01:00:14,079
typing stuff um so we the idea here is
 

2945
01:00:14,079 --> 01:00:15,710
typing stuff um so we the idea here is
that it's good to be fancy but only when

2946
01:00:15,710 --> 01:00:15,720
that it's good to be fancy but only when
 

2947
01:00:15,720 --> 01:00:18,390
that it's good to be fancy but only when
you really care about something right in

2948
01:00:18,390 --> 01:00:18,400
you really care about something right in
 

2949
01:00:18,400 --> 01:00:21,950
you really care about something right in
my interpreter um if I wanted to sort of

2950
01:00:21,950 --> 01:00:21,960
my interpreter um if I wanted to sort of
 

2951
01:00:21,960 --> 01:00:23,470
my interpreter um if I wanted to sort of
change the way information flowed

2952
01:00:23,470 --> 01:00:23,480
change the way information flowed
 

2953
01:00:23,480 --> 01:00:25,029
change the way information flowed
through it it might be quite challenging

2954
01:00:25,029 --> 01:00:25,039
through it it might be quite challenging
 

2955
01:00:25,039 --> 01:00:27,430
through it it might be quite challenging
to do that at this Point um so it's

2956
01:00:27,430 --> 01:00:27,440
to do that at this Point um so it's
 

2957
01:00:27,440 --> 01:00:29,349
to do that at this Point um so it's
definitely better to write the thing

2958
01:00:29,349 --> 01:00:29,359
definitely better to write the thing
 

2959
01:00:29,359 --> 01:00:31,190
definitely better to write the thing
first make sure you know that it's it's

2960
01:00:31,190 --> 01:00:31,200
first make sure you know that it's it's
 

2961
01:00:31,200 --> 01:00:32,750
first make sure you know that it's it's
sort of working and then add the types

2962
01:00:32,750 --> 01:00:32,760
sort of working and then add the types
 

2963
01:00:32,760 --> 01:00:35,230
sort of working and then add the types
later um if you really want to

2964
01:00:35,230 --> 01:00:35,240
later um if you really want to
 

2965
01:00:35,240 --> 01:00:37,910
later um if you really want to
verify um okay so so I said at the

2966
01:00:37,910 --> 01:00:37,920
verify um okay so so I said at the
 

2967
01:00:37,920 --> 01:00:40,150
verify um okay so so I said at the
beginning that I spent a lot of time uh

2968
01:00:40,150 --> 01:00:40,160
beginning that I spent a lot of time uh
 

2969
01:00:40,160 --> 01:00:42,029
beginning that I spent a lot of time uh
uh thinking about uh dependent types and

2970
01:00:42,029 --> 01:00:42,039
uh thinking about uh dependent types and
 

2971
01:00:42,039 --> 01:00:44,670
uh thinking about uh dependent types and
hascal so that's sort of the M my main

2972
01:00:44,670 --> 01:00:44,680
hascal so that's sort of the M my main
 

2973
01:00:44,680 --> 01:00:47,510
hascal so that's sort of the M my main
driver is is that um I I believe

2974
01:00:47,510 --> 01:00:47,520
driver is is that um I I believe
 

2975
01:00:47,520 --> 01:00:50,230
driver is is that um I I believe
dependent types are the future um and

2976
01:00:50,230 --> 01:00:50,240
dependent types are the future um and
 

2977
01:00:50,240 --> 01:00:51,510
dependent types are the future um and
and that that it's something that you

2978
01:00:51,510 --> 01:00:51,520
and that that it's something that you
 

2979
01:00:51,520 --> 01:00:53,230
and that that it's something that you
know when we start teaching everyone to

2980
01:00:53,230 --> 01:00:53,240
know when we start teaching everyone to
 

2981
01:00:53,240 --> 01:00:54,789
know when we start teaching everyone to
program at age 10 they should be

2982
01:00:54,789 --> 01:00:54,799
program at age 10 they should be
 

2983
01:00:54,799 --> 01:00:56,710
program at age 10 they should be
learning dependent types

2984
01:00:56,710 --> 01:00:56,720
learning dependent types
 

2985
01:00:56,720 --> 01:01:00,589
learning dependent types
we are a long way from that now but once

2986
01:01:00,589 --> 01:01:00,599
we are a long way from that now but once
 

2987
01:01:00,599 --> 01:01:02,549
we are a long way from that now but once
upon a time I'm sure people would have

2988
01:01:02,549 --> 01:01:02,559
upon a time I'm sure people would have
 

2989
01:01:02,559 --> 01:01:04,589
upon a time I'm sure people would have
thought it was absolutely crazy to think

2990
01:01:04,589 --> 01:01:04,599
thought it was absolutely crazy to think
 

2991
01:01:04,599 --> 01:01:06,230
thought it was absolutely crazy to think
about teaching calculus to high

2992
01:01:06,230 --> 01:01:06,240
about teaching calculus to high
 

2993
01:01:06,240 --> 01:01:08,190
about teaching calculus to high
schoolers and yet that's quite common

2994
01:01:08,190 --> 01:01:08,200
schoolers and yet that's quite common
 

2995
01:01:08,200 --> 01:01:10,510
schoolers and yet that's quite common
now right so maybe there will be a day

2996
01:01:10,510 --> 01:01:10,520
now right so maybe there will be a day
 

2997
01:01:10,520 --> 01:01:11,630
now right so maybe there will be a day
that we teach dependent types to

2998
01:01:11,630 --> 01:01:11,640
that we teach dependent types to
 

2999
01:01:11,640 --> 01:01:15,390
that we teach dependent types to
10-year-olds I hope that happens um so

3000
01:01:15,390 --> 01:01:15,400
10-year-olds I hope that happens um so
 

3001
01:01:15,400 --> 01:01:17,309
10-year-olds I hope that happens um so
uh so dependent types so this has grown

3002
01:01:17,309 --> 01:01:17,319
uh so dependent types so this has grown
 

3003
01:01:17,319 --> 01:01:19,150
uh so dependent types so this has grown
to a team effort really started I I was

3004
01:01:19,150 --> 01:01:19,160
to a team effort really started I I was
 

3005
01:01:19,160 --> 01:01:21,309
to a team effort really started I I was
sort of pushing uh Stephanie wrick my my

3006
01:01:21,309 --> 01:01:21,319
sort of pushing uh Stephanie wrick my my
 

3007
01:01:21,319 --> 01:01:23,309
sort of pushing uh Stephanie wrick my my
thesis adviser uh was sort of the the

3008
01:01:23,309 --> 01:01:23,319
thesis adviser uh was sort of the the
 

3009
01:01:23,319 --> 01:01:24,990
thesis adviser uh was sort of the the
force behind me pushing but but it's

3010
01:01:24,990 --> 01:01:25,000
force behind me pushing but but it's
 

3011
01:01:25,000 --> 01:01:27,349
force behind me pushing but but it's
it's it's grown so so here's here's sort

3012
01:01:27,349 --> 01:01:27,359
it's it's grown so so here's here's sort
 

3013
01:01:27,359 --> 01:01:29,230
it's it's grown so so here's here's sort
of a a small constellation of people who

3014
01:01:29,230 --> 01:01:29,240
of a a small constellation of people who
 

3015
01:01:29,240 --> 01:01:30,750
of a a small constellation of people who
who have contributed this is all just in

3016
01:01:30,750 --> 01:01:30,760
who have contributed this is all just in
 

3017
01:01:30,760 --> 01:01:33,150
who have contributed this is all just in
the in the last year um so people sort

3018
01:01:33,150 --> 01:01:33,160
the in the last year um so people sort
 

3019
01:01:33,160 --> 01:01:34,829
the in the last year um so people sort
of toward the top and more code people

3020
01:01:34,829 --> 01:01:34,839
of toward the top and more code people
 

3021
01:01:34,839 --> 01:01:37,870
of toward the top and more code people
toward the bottom uh uh more more Theory

3022
01:01:37,870 --> 01:01:37,880
toward the bottom uh uh more more Theory
 

3023
01:01:37,880 --> 01:01:39,150
toward the bottom uh uh more more Theory
um several of these people are in

3024
01:01:39,150 --> 01:01:39,160
um several of these people are in
 

3025
01:01:39,160 --> 01:01:41,710
um several of these people are in
attendance um in this room at the moment

3026
01:01:41,710 --> 01:01:41,720
attendance um in this room at the moment
 

3027
01:01:41,720 --> 01:01:43,750
attendance um in this room at the moment
I see two of them right now uh uh

3028
01:01:43,750 --> 01:01:43,760
I see two of them right now uh uh
 

3029
01:01:43,760 --> 01:01:45,950
I see two of them right now uh uh
changor and Simon ning ning is is is

3030
01:01:45,950 --> 01:01:45,960
changor and Simon ning ning is is is
 

3031
01:01:45,960 --> 01:01:48,109
changor and Simon ning ning is is is
here at hll exchange um I think

3032
01:01:48,109 --> 01:01:48,119
here at hll exchange um I think
 

3033
01:01:48,119 --> 01:01:49,549
here at hll exchange um I think
Stephanie talked about dependent types

3034
01:01:49,549 --> 01:01:49,559
Stephanie talked about dependent types
 

3035
01:01:49,559 --> 01:01:53,589
Stephanie talked about dependent types
here last year um so uh just one one

3036
01:01:53,589 --> 01:01:53,599
here last year um so uh just one one
 

3037
01:01:53,599 --> 01:01:56,309
here last year um so uh just one one
thing I would like to comment while this

3038
01:01:56,309 --> 01:01:56,319
thing I would like to comment while this
 

3039
01:01:56,319 --> 01:01:59,470
thing I would like to comment while this
slide is is up so uh we see here on the

3040
01:01:59,470 --> 01:01:59,480
slide is is up so uh we see here on the
 

3041
01:01:59,480 --> 01:02:04,349
slide is is up so uh we see here on the
slide uh three women um and that ratio

3042
01:02:04,349 --> 01:02:04,359
slide uh three women um and that ratio
 

3043
01:02:04,359 --> 01:02:06,789
slide uh three women um and that ratio
of of women to men in the dependent

3044
01:02:06,789 --> 01:02:06,799
of of women to men in the dependent
 

3045
01:02:06,799 --> 01:02:08,910
of of women to men in the dependent
types work seems to be much much higher

3046
01:02:08,910 --> 01:02:08,920
types work seems to be much much higher
 

3047
01:02:08,920 --> 01:02:10,670
types work seems to be much much higher
than in attendance here at hascal

3048
01:02:10,670 --> 01:02:10,680
than in attendance here at hascal
 

3049
01:02:10,680 --> 01:02:14,789
than in attendance here at hascal
exchange um so in in in in software you

3050
01:02:14,789 --> 01:02:14,799
exchange um so in in in in software you
 

3051
01:02:14,799 --> 01:02:16,230
exchange um so in in in in software you
know we like to we we we always like to

3052
01:02:16,230 --> 01:02:16,240
know we like to we we we always like to
 

3053
01:02:16,240 --> 01:02:17,349
know we like to we we we always like to
think when there's a when there's a bug

3054
01:02:17,349 --> 01:02:17,359
think when there's a when there's a bug
 

3055
01:02:17,359 --> 01:02:18,750
think when there's a when there's a bug
there has to be there's there's

3056
01:02:18,750 --> 01:02:18,760
there has to be there's there's
 

3057
01:02:18,760 --> 01:02:19,870
there has to be there's there's
something that causes that it doesn't

3058
01:02:19,870 --> 01:02:19,880
something that causes that it doesn't
 

3059
01:02:19,880 --> 01:02:23,510
something that causes that it doesn't
just happen on its own right so uh I I I

3060
01:02:23,510 --> 01:02:23,520
just happen on its own right so uh I I I
 

3061
01:02:23,520 --> 01:02:25,430
just happen on its own right so uh I I I
don't have any Grand theories of exactly

3062
01:02:25,430 --> 01:02:25,440
don't have any Grand theories of exactly
 

3063
01:02:25,440 --> 01:02:26,670
don't have any Grand theories of exactly
why this is happened there's many

3064
01:02:26,670 --> 01:02:26,680
why this is happened there's many
 

3065
01:02:26,680 --> 01:02:27,950
why this is happened there's many
theories out there I'm not going to I'm

3066
01:02:27,950 --> 01:02:27,960
theories out there I'm not going to I'm
 

3067
01:02:27,960 --> 01:02:30,029
theories out there I'm not going to I'm
not going to go into that and I have

3068
01:02:30,029 --> 01:02:30,039
not going to go into that and I have
 

3069
01:02:30,039 --> 01:02:32,430
not going to go into that and I have
every belief that that everyone is is

3070
01:02:32,430 --> 01:02:32,440
every belief that that everyone is is
 

3071
01:02:32,440 --> 01:02:34,150
every belief that that everyone is is
always wants to be as inclusive as

3072
01:02:34,150 --> 01:02:34,160
always wants to be as inclusive as
 

3073
01:02:34,160 --> 01:02:35,870
always wants to be as inclusive as
possible I I really do believe that but

3074
01:02:35,870 --> 01:02:35,880
possible I I really do believe that but
 

3075
01:02:35,880 --> 01:02:37,950
possible I I really do believe that but
clearly there's something wrong

3076
01:02:37,950 --> 01:02:37,960
clearly there's something wrong
 

3077
01:02:37,960 --> 01:02:41,269
clearly there's something wrong
somewhere um and even if it's not us it

3078
01:02:41,269 --> 01:02:41,279
somewhere um and even if it's not us it
 

3079
01:02:41,279 --> 01:02:43,269
somewhere um and even if it's not us it
it sort of incomp upon us to do what we

3080
01:02:43,269 --> 01:02:43,279
it sort of incomp upon us to do what we
 

3081
01:02:43,279 --> 01:02:46,630
it sort of incomp upon us to do what we
can to make it not wrong um and and I I

3082
01:02:46,630 --> 01:02:46,640
can to make it not wrong um and and I I
 

3083
01:02:46,640 --> 01:02:48,390
can to make it not wrong um and and I I
I I again I don't I don't know exactly

3084
01:02:48,390 --> 01:02:48,400
I I again I don't I don't know exactly
 

3085
01:02:48,400 --> 01:02:50,430
I I again I don't I don't know exactly
what even what I mean by that other than

3086
01:02:50,430 --> 01:02:50,440
what even what I mean by that other than
 

3087
01:02:50,440 --> 01:02:52,750
what even what I mean by that other than
I just want to sort of raise awareness

3088
01:02:52,750 --> 01:02:52,760
I just want to sort of raise awareness
 

3089
01:02:52,760 --> 01:02:53,710
I just want to sort of raise awareness
around

3090
01:02:53,710 --> 01:02:53,720
around
 

3091
01:02:53,720 --> 01:02:57,750
around
this um okay so uh so grown to a team

3092
01:02:57,750 --> 01:02:57,760
this um okay so uh so grown to a team
 

3093
01:02:57,760 --> 01:03:01,230
this um okay so uh so grown to a team
effort um interestingly dependent types

3094
01:03:01,230 --> 01:03:01,240
effort um interestingly dependent types
 

3095
01:03:01,240 --> 01:03:03,510
effort um interestingly dependent types
aren't really weren't really that much

3096
01:03:03,510 --> 01:03:03,520
aren't really weren't really that much
 

3097
01:03:03,520 --> 01:03:08,029
aren't really weren't really that much
needed uh uh for Stitch um so uh we had

3098
01:03:08,029 --> 01:03:08,039
needed uh uh for Stitch um so uh we had
 

3099
01:03:08,039 --> 01:03:09,670
needed uh uh for Stitch um so uh we had
to use a few Singleton Singletons are

3100
01:03:09,670 --> 01:03:09,680
to use a few Singleton Singletons are
 

3101
01:03:09,680 --> 01:03:12,670
to use a few Singleton Singletons are
sort of uh a mockup of dependent types

3102
01:03:12,670 --> 01:03:12,680
sort of uh a mockup of dependent types
 

3103
01:03:12,680 --> 01:03:14,990
sort of uh a mockup of dependent types
um uh but uh it was only in a few places

3104
01:03:14,990 --> 01:03:15,000
um uh but uh it was only in a few places
 

3105
01:03:15,000 --> 01:03:18,390
um uh but uh it was only in a few places
it wasn't really so bad um so there's

3106
01:03:18,390 --> 01:03:18,400
it wasn't really so bad um so there's
 

3107
01:03:18,400 --> 01:03:21,269
it wasn't really so bad um so there's
lots of activity with GHC proposals that

3108
01:03:21,269 --> 01:03:21,279
lots of activity with GHC proposals that
 

3109
01:03:21,279 --> 01:03:22,910
lots of activity with GHC proposals that
are working in this direction some are

3110
01:03:22,910 --> 01:03:22,920
are working in this direction some are
 

3111
01:03:22,920 --> 01:03:26,150
are working in this direction some are
under discussion right now um so I

3112
01:03:26,150 --> 01:03:26,160
under discussion right now um so I
 

3113
01:03:26,160 --> 01:03:27,390
under discussion right now um so I
strongly encourage you if you're

3114
01:03:27,390 --> 01:03:27,400
strongly encourage you if you're
 

3115
01:03:27,400 --> 01:03:29,750
strongly encourage you if you're
interested in this uh to go here and

3116
01:03:29,750 --> 01:03:29,760
interested in this uh to go here and
 

3117
01:03:29,760 --> 01:03:31,670
interested in this uh to go here and
look at some of these proposals and and

3118
01:03:31,670 --> 01:03:31,680
look at some of these proposals and and
 

3119
01:03:31,680 --> 01:03:34,069
look at some of these proposals and and
we do want Community feedback because uh

3120
01:03:34,069 --> 01:03:34,079
we do want Community feedback because uh
 

3121
01:03:34,079 --> 01:03:36,510
we do want Community feedback because uh
you know GHC is is something we all use

3122
01:03:36,510 --> 01:03:36,520
you know GHC is is something we all use
 

3123
01:03:36,520 --> 01:03:39,190
you know GHC is is something we all use
here um and as new features come in they

3124
01:03:39,190 --> 01:03:39,200
here um and as new features come in they
 

3125
01:03:39,200 --> 01:03:41,750
here um and as new features come in they
will affect all of us and so we really

3126
01:03:41,750 --> 01:03:41,760
will affect all of us and so we really
 

3127
01:03:41,760 --> 01:03:43,510
will affect all of us and so we really
do want feedback there's this proposals

3128
01:03:43,510 --> 01:03:43,520
do want feedback there's this proposals
 

3129
01:03:43,520 --> 01:03:46,230
do want feedback there's this proposals
process it's very active uh I I think

3130
01:03:46,230 --> 01:03:46,240
process it's very active uh I I think
 

3131
01:03:46,240 --> 01:03:48,230
process it's very active uh I I think
it's been supremely helpful in figuring

3132
01:03:48,230 --> 01:03:48,240
it's been supremely helpful in figuring
 

3133
01:03:48,240 --> 01:03:49,910
it's been supremely helpful in figuring
out what's good and what what what's

3134
01:03:49,910 --> 01:03:49,920
out what's good and what what what's
 

3135
01:03:49,920 --> 01:03:53,390
out what's good and what what what's
maybe not as good for for inclusion in

3136
01:03:53,390 --> 01:03:53,400
maybe not as good for for inclusion in
 

3137
01:03:53,400 --> 01:03:57,269
maybe not as good for for inclusion in
GHC um so this coming uh uh school year

3138
01:03:57,269 --> 01:03:57,279
GHC um so this coming uh uh school year
 

3139
01:03:57,279 --> 01:03:59,589
GHC um so this coming uh uh school year
um I will be working on GHC full-time so

3140
01:03:59,589 --> 01:03:59,599
um I will be working on GHC full-time so
 

3141
01:03:59,599 --> 01:04:00,829
um I will be working on GHC full-time so
I'm normally based outside of

3142
01:04:00,829 --> 01:04:00,839
I'm normally based outside of
 

3143
01:04:00,839 --> 01:04:03,109
I'm normally based outside of
Philadelphia uh this year I've moved to

3144
01:04:03,109 --> 01:04:03,119
Philadelphia uh this year I've moved to
 

3145
01:04:03,119 --> 01:04:07,430
Philadelphia uh this year I've moved to
to Cambridge UK um uh uh Cambridge is a

3146
01:04:07,430 --> 01:04:07,440
to Cambridge UK um uh uh Cambridge is a
 

3147
01:04:07,440 --> 01:04:09,510
to Cambridge UK um uh uh Cambridge is a
lovely place but in particular um it's

3148
01:04:09,510 --> 01:04:09,520
lovely place but in particular um it's
 

3149
01:04:09,520 --> 01:04:11,430
lovely place but in particular um it's
it's where Simon works and so Simon and

3150
01:04:11,430 --> 01:04:11,440
it's where Simon works and so Simon and
 

3151
01:04:11,440 --> 01:04:12,829
it's where Simon works and so Simon and
I are s of spending a lot of time

3152
01:04:12,829 --> 01:04:12,839
I are s of spending a lot of time
 

3153
01:04:12,839 --> 01:04:14,710
I are s of spending a lot of time
confabbing about about you know

3154
01:04:14,710 --> 01:04:14,720
confabbing about about you know
 

3155
01:04:14,720 --> 01:04:17,670
confabbing about about you know
improving GHC uh and and you know I will

3156
01:04:17,670 --> 01:04:17,680
improving GHC uh and and you know I will
 

3157
01:04:17,680 --> 01:04:19,470
improving GHC uh and and you know I will
start be start start to bug him more and

3158
01:04:19,470 --> 01:04:19,480
start be start start to bug him more and
 

3159
01:04:19,480 --> 01:04:21,589
start be start start to bug him more and
more about dependent types as time goes

3160
01:04:21,589 --> 01:04:21,599
more about dependent types as time goes
 

3161
01:04:21,599 --> 01:04:24,510
more about dependent types as time goes
on um and and so and I expect the past

3162
01:04:24,510 --> 01:04:24,520
on um and and so and I expect the past
 

3163
01:04:24,520 --> 01:04:25,710
on um and and so and I expect the past
couple of years have been a little slow

3164
01:04:25,710 --> 01:04:25,720
couple of years have been a little slow
 

3165
01:04:25,720 --> 01:04:27,950
couple of years have been a little slow
flow in in this regard um I've had a lot

3166
01:04:27,950 --> 01:04:27,960
flow in in this regard um I've had a lot
 

3167
01:04:27,960 --> 01:04:29,390
flow in in this regard um I've had a lot
of teaching responsibilities I expect

3168
01:04:29,390 --> 01:04:29,400
of teaching responsibilities I expect
 

3169
01:04:29,400 --> 01:04:31,710
of teaching responsibilities I expect
that to to lessen considerably uh thanks

3170
01:04:31,710 --> 01:04:31,720
that to to lessen considerably uh thanks
 

3171
01:04:31,720 --> 01:04:33,670
that to to lessen considerably uh thanks
to some support from

3172
01:04:33,670 --> 01:04:33,680
to some support from
 

3173
01:04:33,680 --> 01:04:38,510
to some support from
tweo um so um uh I'd love to have more

3174
01:04:38,510 --> 01:04:38,520
tweo um so um uh I'd love to have more
 

3175
01:04:38,520 --> 01:04:41,150
tweo um so um uh I'd love to have more
people coming and contributing to to

3176
01:04:41,150 --> 01:04:41,160
people coming and contributing to to
 

3177
01:04:41,160 --> 01:04:43,349
people coming and contributing to to
this dependent types effort um

3178
01:04:43,349 --> 01:04:43,359
this dependent types effort um
 

3179
01:04:43,359 --> 01:04:45,710
this dependent types effort um
commenting on the proposals is a really

3180
01:04:45,710 --> 01:04:45,720
commenting on the proposals is a really
 

3181
01:04:45,720 --> 01:04:47,109
commenting on the proposals is a really
great way to start you don't need to

3182
01:04:47,109 --> 01:04:47,119
great way to start you don't need to
 

3183
01:04:47,119 --> 01:04:49,390
great way to start you don't need to
know type Theory to be able to do that

3184
01:04:49,390 --> 01:04:49,400
know type Theory to be able to do that
 

3185
01:04:49,400 --> 01:04:51,150
know type Theory to be able to do that
um H you don't need to know GHC

3186
01:04:51,150 --> 01:04:51,160
um H you don't need to know GHC
 

3187
01:04:51,160 --> 01:04:52,789
um H you don't need to know GHC
internals to be able to do that right

3188
01:04:52,789 --> 01:04:52,799
internals to be able to do that right
 

3189
01:04:52,799 --> 01:04:55,069
internals to be able to do that right
you're all users of hcll these proposals

3190
01:04:55,069 --> 01:04:55,079
you're all users of hcll these proposals
 

3191
01:04:55,079 --> 01:04:57,910
you're all users of hcll these proposals
are sort of you're facing so please

3192
01:04:57,910 --> 01:04:57,920
are sort of you're facing so please
 

3193
01:04:57,920 --> 01:05:01,549
are sort of you're facing so please
participate um so my goal so the so so

3194
01:05:01,549 --> 01:05:01,559
participate um so my goal so the so so
 

3195
01:05:01,559 --> 01:05:03,789
participate um so my goal so the so so
in type Theory we use pi to talk about

3196
01:05:03,789 --> 01:05:03,799
in type Theory we use pi to talk about
 

3197
01:05:03,799 --> 01:05:06,549
in type Theory we use pi to talk about
dependent types so my My Hope Is that we

3198
01:05:06,549 --> 01:05:06,559
dependent types so my My Hope Is that we
 

3199
01:05:06,559 --> 01:05:09,710
dependent types so my My Hope Is that we
will have dependent Types on Pi Day of

3200
01:05:09,710 --> 01:05:09,720
will have dependent Types on Pi Day of
 

3201
01:05:09,720 --> 01:05:12,510
will have dependent Types on Pi Day of
2021 um so that's that's still a year

3202
01:05:12,510 --> 01:05:12,520
2021 um so that's that's still a year
 

3203
01:05:12,520 --> 01:05:14,829
2021 um so that's that's still a year
and a half away so so right in America

3204
01:05:14,829 --> 01:05:14,839
and a half away so so right in America
 

3205
01:05:14,839 --> 01:05:17,390
and a half away so so right in America
Pi Day is is March 14th because we write

3206
01:05:17,390 --> 01:05:17,400
Pi Day is is March 14th because we write
 

3207
01:05:17,400 --> 01:05:21,470
Pi Day is is March 14th because we write
three and then 14 in the date um so um

3208
01:05:21,470 --> 01:05:21,480
three and then 14 in the date um so um
 

3209
01:05:21,480 --> 01:05:23,589
three and then 14 in the date um so um
so that's that's the hope we'll we'll

3210
01:05:23,589 --> 01:05:23,599
so that's that's the hope we'll we'll
 

3211
01:05:23,599 --> 01:05:26,510
so that's that's the hope we'll we'll
we'll see if we get there um uh uh I I

3212
01:05:26,510 --> 01:05:26,520
we'll see if we get there um uh uh I I
 

3213
01:05:26,520 --> 01:05:28,390
we'll see if we get there um uh uh I I
am hoping I'll say it publicly so now

3214
01:05:28,390 --> 01:05:28,400
am hoping I'll say it publicly so now
 

3215
01:05:28,400 --> 01:05:30,910
am hoping I'll say it publicly so now
now Simon has to has to respect this or

3216
01:05:30,910 --> 01:05:30,920
now Simon has to has to respect this or
 

3217
01:05:30,920 --> 01:05:35,710
now Simon has to has to respect this or
or or or put it down publicly my get I

3218
01:05:35,710 --> 01:05:35,720
or or or put it down publicly my get I
 

3219
01:05:35,720 --> 01:05:38,710
or or or put it down publicly my get I
know I know my My Hope Is by midwinter

3220
01:05:38,710 --> 01:05:38,720
know I know my My Hope Is by midwinter
 

3221
01:05:38,720 --> 01:05:41,349
know I know my My Hope Is by midwinter
to to have a dependently typed core

3222
01:05:41,349 --> 01:05:41,359
to to have a dependently typed core
 

3223
01:05:41,359 --> 01:05:43,190
to to have a dependently typed core
language inside of GHC that won't

3224
01:05:43,190 --> 01:05:43,200
language inside of GHC that won't
 

3225
01:05:43,200 --> 01:05:44,910
language inside of GHC that won't
actually affect users at all and then to

3226
01:05:44,910 --> 01:05:44,920
actually affect users at all and then to
 

3227
01:05:44,920 --> 01:05:48,829
actually affect users at all and then to
sort of work my way up from there um

3228
01:05:48,829 --> 01:05:48,839
sort of work my way up from there um
 

3229
01:05:48,839 --> 01:05:50,150
sort of work my way up from there um
okay and that's all I've got thanks very

3230
01:05:50,150 --> 01:05:50,160
okay and that's all I've got thanks very
 

3231
01:05:50,160 --> 01:05:52,190
okay and that's all I've got thanks very
much I'm happy for any questions

3232
01:05:52,190 --> 01:05:52,200
much I'm happy for any questions
 

3233
01:05:52,200 --> 01:06:01,750
much I'm happy for any questions
[Applause]

3234
01:06:01,750 --> 01:06:01,760

 

3235
01:06:01,760 --> 01:06:06,589

the function check the function check um

3236
01:06:06,589 --> 01:06:06,599
the function check the function check um
 

3237
01:06:06,599 --> 01:06:08,910
the function check the function check um
there was no guarantee that the checked

3238
01:06:08,910 --> 01:06:08,920
there was no guarantee that the checked
 

3239
01:06:08,920 --> 01:06:10,990
there was no guarantee that the checked
expression had any relation to the

3240
01:06:10,990 --> 01:06:11,000
expression had any relation to the
 

3241
01:06:11,000 --> 01:06:13,470
expression had any relation to the
unchecked expression that's true I was

3242
01:06:13,470 --> 01:06:13,480
unchecked expression that's true I was
 

3243
01:06:13,480 --> 01:06:15,670
unchecked expression that's true I was
wondering if you could also index on the

3244
01:06:15,670 --> 01:06:15,680
wondering if you could also index on the
 

3245
01:06:15,680 --> 01:06:17,630
wondering if you could also index on the
unchecked expressions and if that would

3246
01:06:17,630 --> 01:06:17,640
unchecked expressions and if that would
 

3247
01:06:17,640 --> 01:06:22,510
unchecked expressions and if that would
be easy so not without dependent types

3248
01:06:22,510 --> 01:06:22,520
be easy so not without dependent types
 

3249
01:06:22,520 --> 01:06:24,670
be easy so not without dependent types
um yes so so so just to sort of broaden

3250
01:06:24,670 --> 01:06:24,680
um yes so so so just to sort of broaden
 

3251
01:06:24,680 --> 01:06:26,349
um yes so so so just to sort of broaden
that out a little bit so in in the check

3252
01:06:26,349 --> 01:06:26,359
that out a little bit so in in the check
 

3253
01:06:26,359 --> 01:06:29,789
that out a little bit so in in the check
function um of course I could have just

3254
01:06:29,789 --> 01:06:29,799
function um of course I could have just
 

3255
01:06:29,799 --> 01:06:32,309
function um of course I could have just
ignored the input and then produced any

3256
01:06:32,309 --> 01:06:32,319
ignored the input and then produced any
 

3257
01:06:32,319 --> 01:06:34,829
ignored the input and then produced any
old properly typed thing as output and

3258
01:06:34,829 --> 01:06:34,839
old properly typed thing as output and
 

3259
01:06:34,839 --> 01:06:36,309
old properly typed thing as output and
that would still be accepted that would

3260
01:06:36,309 --> 01:06:36,319
that would still be accepted that would
 

3261
01:06:36,319 --> 01:06:39,470
that would still be accepted that would
still compile in in GHC and that's bad

3262
01:06:39,470 --> 01:06:39,480
still compile in in GHC and that's bad
 

3263
01:06:39,480 --> 01:06:40,670
still compile in in GHC and that's bad
right I would want to have some

3264
01:06:40,670 --> 01:06:40,680
right I would want to have some
 

3265
01:06:40,680 --> 01:06:43,269
right I would want to have some
relationship between them um doing that

3266
01:06:43,269 --> 01:06:43,279
relationship between them um doing that
 

3267
01:06:43,279 --> 01:06:46,349
relationship between them um doing that
I think would require much more power um

3268
01:06:46,349 --> 01:06:46,359
I think would require much more power um
 

3269
01:06:46,359 --> 01:06:48,109
I think would require much more power um
so I could probably mock it up with

3270
01:06:48,109 --> 01:06:48,119
so I could probably mock it up with
 

3271
01:06:48,119 --> 01:06:51,190
so I could probably mock it up with
Singletons maybe um actually probably

3272
01:06:51,190 --> 01:06:51,200
Singletons maybe um actually probably
 

3273
01:06:51,200 --> 01:06:52,829
Singletons maybe um actually probably
could I'd be surprised if I couldn't but

3274
01:06:52,829 --> 01:06:52,839
could I'd be surprised if I couldn't but
 

3275
01:06:52,839 --> 01:06:54,430
could I'd be surprised if I couldn't but
it would it would be ugly and painful

3276
01:06:54,430 --> 01:06:54,440
it would it would be ugly and painful
 

3277
01:06:54,440 --> 01:06:55,750
it would it would be ugly and painful
and so once we have dependent types be

3278
01:06:55,750 --> 01:06:55,760
and so once we have dependent types be
 

3279
01:06:55,760 --> 01:07:04,470
and so once we have dependent types be
able to do

3280
01:07:04,470 --> 01:07:04,480

 

3281
01:07:04,480 --> 01:07:10,829

that other

3282
01:07:10,829 --> 01:07:10,839

 

3283
01:07:10,839 --> 01:07:13,780

question okay thanks all for coming

3284
01:07:13,780 --> 01:07:13,790
question okay thanks all for coming
 

3285
01:07:13,790 --> 01:07:19,599
question okay thanks all for coming
[Applause]

